%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Computational Physics I (PHYS 3500K)}
\date{Jul 21, 2025}
\release{}
\author{Andreas Papaefstathiou}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Introduction}
\end{DUlineblock}

\sphinxAtStartPar
This book is constructed from the repository dedicated to
Computational Physics I (PHYS 3500K) at Kennesaw State University.

\sphinxAtStartPar
Here, you will find examples and notes pertaining to the course, as well as additional material.

\sphinxAtStartPar
Note that the repository is meant to evolve during the
semester. Solutions to the homework problems are given to the students
taking the course, and they can be provided from the author upon
request.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter1/Chapter1::doc}]{\sphinxcrossref{Making Computers Obey}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter2/Chapter2::doc}]{\sphinxcrossref{Computer Number Representations}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter3/Chapter3::doc}]{\sphinxcrossref{Randomness and Random Walks}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter4/Chapter4::doc}]{\sphinxcrossref{Numerical Differentiation and Integration}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter5/Chapter5::doc}]{\sphinxcrossref{Monte Carlo Methods}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter6/Chapter6::doc}]{\sphinxcrossref{Matrix Computing, Trial\sphinxhyphen{}and\sphinxhyphen{}Error Searching and Data Fitting}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter7/Chapter7::doc}]{\sphinxcrossref{Ordinary Differential Equations}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter8/Chapter8::doc}]{\sphinxcrossref{An Introduction to Nonlinear Dynamics and Chaos}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter9/Chapter9::doc}]{\sphinxcrossref{Boundary Value and Eigenvalue Problems}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter10/Chapter10::doc}]{\sphinxcrossref{Partial Differential Equations}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Chapters/Chapter11/Chapter11::doc}]{\sphinxcrossref{More Monte Carlo: The Metropolis Algorithm}}}

\end{itemize}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large About the Author}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxhref{https://facultyweb.kennesaw.edu/apapaefs/}{Andreas Papaefstathiou} is Assistant Professor of Physics at Kennesaw State University. This website was originally created in January 2024 and is updated on a best\sphinxhyphen{}effort basis.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large References}
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Computational Physics, Problem Solving with Python \sphinxhyphen{} Rubin H. Landau, Manuel J. Páez, Christian C. Bordeianu.

\item {} 
\sphinxAtStartPar
Computational Physics (Fortran Version) \sphinxhyphen{} Steve E. Koonin, Dawn C. Meredith.

\item {} 
\sphinxAtStartPar
Nonlinear Dynamics and Chaos \sphinxhyphen{} Steven H. Strogatz.

\end{itemize}

\sphinxstepscope


\chapter{Making Computers Obey}
\label{\detokenize{Chapters/Chapter1/Chapter1:making-computers-obey}}\label{\detokenize{Chapters/Chapter1/Chapter1::doc}}

\section{Machine Language}
\label{\detokenize{Chapters/Chapter1/Chapter1:machine-language}}
\sphinxAtStartPar
Computers always do exactly as they are told! Instructions they understand are in a machine language.

\sphinxAtStartPar
But when writing and running programs, we communicate to the computer through “shells”, in high\sphinxhyphen{}level languages (e.g. Python, Java, Fortran, C, …), or through problem\sphinxhyphen{}solving environments (e.g. Maple, Mathematica, Matlab, …).

\sphinxAtStartPar
Eventually these commands/programs are translated into the basic machine language that the hardware understands.


\section{Shells, Operating Systems and Compilers}
\label{\detokenize{Chapters/Chapter1/Chapter1:shells-operating-systems-and-compilers}}
\sphinxAtStartPar
A shell: is a command\sphinxhyphen{}line interpreter: a small set of programs run by a computer that respond to the commands that you key in. The job of th eshell is to run programs, compilers and utilities. A demonstration of this will be given during the lectures, but we won’t be using shells extensively!

\sphinxAtStartPar
Operating systems, e.g. Unix, DOS, Linux, MacOS, Windows, are a group of programs used by the computer to communicate with users and devices, to store and read data, and to execute programs.

\sphinxAtStartPar
When you submit a program to your computer in a high\sphinxhyphen{}level language, the computer uses a compiler to process it. The compiler translates your program into machine language.

\sphinxAtStartPar
Fortran and C (e.g.) read the entire program and then translate it into basic machine instructions. These are known as “compiled languages”.

\sphinxAtStartPar
BASIC/Maple translate each line of program as it is entered. These are “interpreted languages”.

\sphinxAtStartPar
Python and Java are a mix of both.


\section{Programming Warmup}
\label{\detokenize{Chapters/Chapter1/Chapter1:programming-warmup}}
\sphinxAtStartPar
Here’s some “pseudocode” for a program that intends to calculate the area of a circle:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{read} \PYG{n}{radius} \PYG{c+c1}{\PYGZsh{} the input }
\PYG{n}{calculate} \PYG{n}{area} \PYG{n}{of} \PYG{n}{circle} \PYG{c+c1}{\PYGZsh{} the numerics}
\PYG{n+nb}{print} \PYG{n}{area} \PYG{c+c1}{\PYGZsh{} the output}
\end{sphinxVerbatim}

\sphinxAtStartPar
To actually get the computer to do the numerics, we have to specify an \sphinxstylestrong{algorithm}. The pseudocode would then look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{read} \PYG{n}{radius} \PYG{c+c1}{\PYGZsh{} the input}
\PYG{n}{PI} \PYG{o}{=} \PYG{l+m+mf}{3.14} \PYG{c+c1}{\PYGZsh{} a constant}
\PYG{n}{area} \PYG{o}{=} \PYG{n}{PI} \PYG{o}{*} \PYG{n}{r} \PYG{o}{*} \PYG{n}{r} \PYG{c+c1}{\PYGZsh{} the algorithm}
\PYG{n+nb}{print} \PYG{n}{area} \PYG{c+c1}{\PYGZsh{} output}
\end{sphinxVerbatim}


\section{Structure and Reproducible Program Design}
\label{\detokenize{Chapters/Chapter1/Chapter1:structure-and-reproducible-program-design}}
\sphinxAtStartPar
Programming is a written art that blends the elements of science, math, and computer science into a set of instructions that permit a computer to accomplish a desired task.

\sphinxAtStartPar
It is important that the source code of your program itself is available to others so that they can reproduce and extend your results!

\sphinxAtStartPar
Reproducibility is an essential ingredient in science.

\sphinxAtStartPar
In addition to the grammar of the computer language, a scientific program should include a number of essential elements to ensure the program’s validity and useability.

\sphinxAtStartPar
As with other arts, it is recommended that until you know better, you should follow some simple rules:

\sphinxAtStartPar
A good program should:
\begin{itemize}
\item {} 
\sphinxAtStartPar
give correct answers.

\item {} 
\sphinxAtStartPar
be clear and easy to read, with the action of each part easy to analyze.

\item {} 
\sphinxAtStartPar
document itself for the readers/programmer.

\item {} 
\sphinxAtStartPar
be easy to use.

\item {} 
\sphinxAtStartPar
be built out of small programs that can be independently verified.

\item {} 
\sphinxAtStartPar
be easy to modify and robust enough to keep giving correct answers arfter modification and simple debugging.

\item {} 
\sphinxAtStartPar
document the data fomats used.

\item {} 
\sphinxAtStartPar
use trusted libraries.

\item {} 
\sphinxAtStartPar
be published or passed onto others to use and to develop further.

\end{itemize}

\sphinxAtStartPar
An elementary way to make any program clear is to structure it with indentation, skipped lines, parentheses, all placed strategically.

\sphinxAtStartPar
Python uses indentation as a structure element, as well as for clarity.


\section{Introduction to Python}
\label{\detokenize{Chapters/Chapter1/Chapter1:introduction-to-python}}
\sphinxAtStartPar
From the Python tutorial: \sphinxurl{https://docs.python.org/3.12/tutorial/index.html}
\begin{quote}

\sphinxAtStartPar
“Python is an easy to learn, powerful programming language.

\sphinxAtStartPar
It has efficient high\sphinxhyphen{}level data structures and a simple but effective approach to object\sphinxhyphen{}oriented programming.

\sphinxAtStartPar
Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.”
\end{quote}

\sphinxAtStartPar
Today we will learn how to use Python in a jupyter notebook (such as this one) and use it to solve some basic problems, including visualization.


\subsection{What is Python?}
\label{\detokenize{Chapters/Chapter1/Chapter1:what-is-python}}
\sphinxAtStartPar
Python is an interpreted, interactive, object\sphinxhyphen{}oriented programming language. It incorporates modules, exceptions, dynamic typing, very high level dynamic data types, and classes.


\subsection{Aside: Why is it called that?!}
\label{\detokenize{Chapters/Chapter1/Chapter1:aside-why-is-it-called-that}}
\sphinxAtStartPar
When he began implementing Python, Guido van Rossum was also reading the published scripts from “Monty Python’s Flying Circus”, a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python.


\subsection{Jupyter Notebooks, the Gitlab repository and Binder}
\label{\detokenize{Chapters/Chapter1/Chapter1:jupyter-notebooks-the-gitlab-repository-and-binder}}
\sphinxAtStartPar
There are many ways to use Python. We will explore some of them (see Options 1\sphinxhyphen{}3), but I will mainly be using jupyter notebooks, such as the one you are currently looking at. The easiest option is to use “binder” (\sphinxurl{https://mybinder.org/}) in conjunction with the course code/notes repository: \sphinxurl{https://github.com/apapaefs/phys3500k\_sp25}.

\sphinxAtStartPar
You will find the environment you see here (if you are in class right now!), along with the course files.


\subsection{Let’s write some code!}
\label{\detokenize{Chapters/Chapter1/Chapter1:let-s-write-some-code}}
\sphinxAtStartPar
We can already write code in this notebook:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello Whimsical World of Pythonic Physics!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello Whimsical World of Pythonic Physics!
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Try it now!
Congratulations! You’ve written your first program in Python!

\sphinxAtStartPar
Let’s now define some variables:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{eggs} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{text1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Break the}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{text2} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eggs}\PYG{l+s+s2}{\PYGZdq{}} \PYG{c+c1}{\PYGZsh{} comments are written this way in Python}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can use Python as a calculator:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{42}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
84
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8}\PYG{o}{/}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that the above is a float of double precision! (see later)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
9
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
And you can use variables during these operations:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{eggs} \PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It’s very easy to manipulate text in Python (represented by “strings”). You can define strings as above, either in “” or ‘’.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3} \PYG{o}{=} \PYG{n}{text1} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{eggs}\PYG{p}{)} \PYG{o}{+}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{text2}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{text3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Break the 3 eggs
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Strings can be indexed:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}B\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}r\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Negative integers start counting from the right:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}s\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}g\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also “slice” strings:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} characters from position 0 (included) to 2 (excluded)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Br\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} characters from position 2 (included) to 5 (excluded)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}eak\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{text3}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} characters from position 4 (included) to the end}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}k the 3 eggs\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
len() tells you how long a string is:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{text3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
16
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Lists are used to group together values. They are written as a list of comma\sphinxhyphen{}separated values (items) between square brackets. They may contain items of different types but usually the items all have the same type.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Like strings, lists can be indexed and sliced:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} indexing returns the item}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
16
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} indexing returns the last item}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
25
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} returns the second element up to the end}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[4, 9, 16, 25]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Lists also support operations like concatenation:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{81}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cubes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{65}\PYG{p}{,} \PYG{l+m+mi}{125}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} something\PYGZsq{}s wrong here}
\PYG{l+m+mi}{4} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}  \PYG{c+c1}{\PYGZsh{} the cube of 4 is 64, not 65!}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cubes}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{64}  \PYG{c+c1}{\PYGZsh{} replace the wrong value}
\PYG{n}{cubes}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 8, 27, 64, 125]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also add new items at the end of the list, by using the list.append() method:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cubes}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{216}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} add the cube of 6}
\PYG{n}{cubes}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{7} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} and the cube of 7}
\PYG{n}{cubes}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 8, 27, 64, 125, 216, 343]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
len() also applies to lists:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{cubes}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{cubes}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Control Flow Tools}
\label{\detokenize{Chapters/Chapter1/Chapter1:control-flow-tools}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{if}} Statements}
\label{\detokenize{Chapters/Chapter1/Chapter1:if-statements}}
\sphinxAtStartPar
One of the most well\sphinxhyphen{}known statement type is the \sphinxcode{\sphinxupquote{if}} statement. An example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Please enter an integer: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{StdinNotImplementedError}\PYG{g+gWhitespace}{                  }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Please enter an integer: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nn}{File /usr/local/lib/python3.11/site\PYGZhy{}packages/ipykernel/kernelbase.py:1281,} in \PYG{n+ni}{Kernel.raw\PYGZus{}input}\PYG{n+nt}{(self, prompt)}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1279} \PYG{k}{if} \PYG{o+ow}{not} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}allow\PYGZus{}stdin}\PYG{p}{:}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1280}     \PYG{n}{msg} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{raw\PYGZus{}input was called, but this frontend does not support input requests.}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+ne}{\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1281}     \PYG{k}{raise} \PYG{n}{StdinNotImplementedError}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1282} \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}input\PYGZus{}request}\PYG{p}{(}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1283}     \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1284}     \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}parent\PYGZus{}ident}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shell}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1285}     \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}parent}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shell}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1286}     \PYG{n}{password}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
\PYG{g+gWhitespace}{   }\PYG{l+m+mi}{1287} \PYG{p}{)}

\PYG{n+ne}{StdinNotImplementedError}: raw\PYGZus{}input was called, but this frontend does not support input requests.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:} 
    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Negative integer detected, changed to zero!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Zero}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:} 
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Positive integer, not one}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Positive integer, not one
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
‘elif’ is short for ‘else if’, there can be any number of such statements (including none). ‘else’ is optional and is ‘triggered’ if all other statements are not satisfied.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{for}} and \sphinxstyleliteralintitle{\sphinxupquote{while}} Statements}
\label{\detokenize{Chapters/Chapter1/Chapter1:for-and-while-statements}}
\sphinxAtStartPar
Python’s \sphinxcode{\sphinxupquote{for}} statement iterates over the items of any sequence (e.g. a list or a string), in the order they appear in the sequence. E.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} measure the length of all the strings in a list:}
\PYG{n}{words} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Einstein}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Galileo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Copernicus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Einstein 8
Galileo 7
Copernicus 10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If instead you want to iterate over the sequence of numbers, the range() function comes in handy:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Einstein 8
Galileo 7
Copernicus 10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
or, equivalently:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 Einstein 8
1 Galileo 7
2 Copernicus 10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{while}} statement continues until the given condition stops being true:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{words}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{j} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 Einstein 8
1 Galileo 7
2 Copernicus 10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s use a \sphinxcode{\sphinxupquote{while}} loop to write down the first few terms in the Fibonacci series:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Fibonacci series:}
\PYG{c+c1}{\PYGZsh{} the sum of two elements defines the next}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} define the first two}
\PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} do this while the number a is less than 10, stop when it exceeds 10.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} print the next number in the series}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{b}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{+}\PYG{n}{c} \PYG{c+c1}{\PYGZsh{} a becomes the next number to be printed, and calculate the one after that.}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{c}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
5
8
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{break}} and \sphinxstyleliteralintitle{\sphinxupquote{continue}} Statements, and \sphinxstyleliteralintitle{\sphinxupquote{else}} Clauses on Loops}
\label{\detokenize{Chapters/Chapter1/Chapter1:break-and-continue-statements-and-else-clauses-on-loops}}
\sphinxAtStartPar
The break statement breaks out the innermost enclosing for or while loop. E.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{w} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Galileo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
        \PYG{k}{continue}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Einstein
Copernicus
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{for}} or \sphinxcode{\sphinxupquote{while}} loop can include an \sphinxcode{\sphinxupquote{else}} clause. In a \sphinxcode{\sphinxupquote{for}} loop the \sphinxcode{\sphinxupquote{else}} clause is executed after the loop reaches its final iteration. In a \sphinxcode{\sphinxupquote{while}} loop, it’s executed after the loop’s condition becomes false. In either kind of loop, the \sphinxcode{\sphinxupquote{else}} clause is \sphinxstyleemphasis{not} executed if the loop was terminated by a \sphinxcode{\sphinxupquote{break}}.

\sphinxAtStartPar
In the following example, an \sphinxcode{\sphinxupquote{else}} clause is used at the end of a \sphinxcode{\sphinxupquote{for}} loop which contains an \sphinxcode{\sphinxupquote{if}} statement that checks whether a number is divisible by all numbers smaller than itself. (The \sphinxcode{\sphinxupquote{n \% x}} part calculates the remainder of the division n/x).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{n}\PYG{o}{\PYGZpc{}}\PYG{k}{x}==0:
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{equals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{o}{/}\PYG{n}{x}\PYG{p}{)}
            \PYG{k}{break} \PYG{c+c1}{\PYGZsh{} we have found a number smaller than n is a factor of n, so n is not a prime number! \PYGZhy{}\PYGZgt{} break the for loop here \PYGZhy{}\PYGZgt{} else is not executed!}
    \PYG{k}{else}\PYG{p}{:} 
        \PYG{c+c1}{\PYGZsh{} loop fell through without finding a factor }
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is a prime number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2 is a prime number
3 is a prime number
4 equals 2 * 2.0
5 is a prime number
6 equals 2 * 3.0
7 is a prime number
8 equals 2 * 4.0
9 equals 3 * 3.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{continue}} statement continues with the next iteration of the loop:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{num} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Found an even number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{num}\PYG{p}{)}
        \PYG{k}{continue}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Found an odd number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{num}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Found an even number 2
Found an odd number 3
Found an even number 4
Found an odd number 5
Found an even number 6
Found an odd number 7
Found an even number 8
Found an odd number 9
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Defining Functions}
\label{\detokenize{Chapters/Chapter1/Chapter1:defining-functions}}
\sphinxAtStartPar
We can create a function that writes the Fibonacci series to an arbitrary boundary:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fib}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}    \PYG{c+c1}{\PYGZsh{} write Fibonacci series up to n}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Print a Fibonacci series up to n.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{def}} introduces a function definition. It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the function’s documentation string.

\sphinxAtStartPar
We can execute the function by calling it with a parameter, e.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{2000}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Functions without \sphinxcode{\sphinxupquote{return}} statements return \sphinxcode{\sphinxupquote{None}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{2000}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 None
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can instead create a function that \sphinxstyleemphasis{returns} the values we are after, e.g. in a list:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fib2}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} return Fibonacci series up to n}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return a list containing the Fibonacci series up to n.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{n}{result}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} see below}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
And we can call it to create a list, e.g. \sphinxcode{\sphinxupquote{fib100}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f100} \PYG{o}{=} \PYG{n}{fib2}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f100}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{append}} is a \sphinxcode{\sphinxupquote{method}} that acts on the list object \sphinxcode{\sphinxupquote{result}} to add a new element at its end.

\sphinxAtStartPar
For more details on defining functions, see \sphinxurl{https://docs.python.org/3/tutorial/controlflow.html\#more-on-defining-functions}. We will discuss some of those aspects where necessary during the course.


\section{Data Structures}
\label{\detokenize{Chapters/Chapter1/Chapter1:data-structures}}

\subsection{List Methods}
\label{\detokenize{Chapters/Chapter1/Chapter1:list-methods}}
\sphinxAtStartPar
We already mentionewd the \sphinxcode{\sphinxupquote{list.append()}}  method for a list. The list data type has some more methods, some of which are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.append(x)}}: Add an item to the end of the list. Equivalent to \sphinxcode{\sphinxupquote{a{[}len(a):{]} = {[}x{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.insert(i, x)}}: Insert an item at a given position. The first argument is the index of the element before which to insert, so \sphinxcode{\sphinxupquote{a.insert(0, x)}} inserts at the front of the list, and \sphinxcode{\sphinxupquote{a.insert(len(a), x)}} is equivalent to \sphinxcode{\sphinxupquote{a.append(x)}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.remove(x)}}: Remove the first item from the list whose value is equal to x. It raises a ValueError if there is no such item.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.pop({[}i{]})}}: Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.clear()}}: Remove all items from the list.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.count(x)}}: Return the number of times x appears in the list.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.reverse()}}: Reverse the elements of the list in place.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.sort(*, key=None, reverse=False)}}: Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for their explanation).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.reverse()}}: Reverse the elements of the list in place.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list.copy()}}: Return a shallow copy of the list. Equivalent to \sphinxcode{\sphinxupquote{a{[}:{]}}}.

\end{itemize}

\sphinxAtStartPar
The following examples use several of the list methods:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kiwi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tangerine}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Find next banana starting at position 4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fruits}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}banana\PYGZsq{}, \PYGZsq{}apple\PYGZsq{}, \PYGZsq{}kiwi\PYGZsq{}, \PYGZsq{}banana\PYGZsq{}, \PYGZsq{}pear\PYGZsq{}, \PYGZsq{}apple\PYGZsq{}, \PYGZsq{}orange\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grape}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fruits}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}banana\PYGZsq{}, \PYGZsq{}apple\PYGZsq{}, \PYGZsq{}kiwi\PYGZsq{}, \PYGZsq{}banana\PYGZsq{}, \PYGZsq{}pear\PYGZsq{}, \PYGZsq{}apple\PYGZsq{}, \PYGZsq{}orange\PYGZsq{}, \PYGZsq{}grape\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fruits}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}apple\PYGZsq{}, \PYGZsq{}apple\PYGZsq{}, \PYGZsq{}banana\PYGZsq{}, \PYGZsq{}banana\PYGZsq{}, \PYGZsq{}grape\PYGZsq{}, \PYGZsq{}kiwi\PYGZsq{}, \PYGZsq{}orange\PYGZsq{}, \PYGZsq{}pear\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}pear\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{List Comprehensions}
\label{\detokenize{Chapters/Chapter1/Chapter1:list-comprehensions}}
\sphinxAtStartPar
List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.

\sphinxAtStartPar
E.g. let’s assume we want to create a list of squares, like:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{squares}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{squares}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can instead use a \sphinxstyleemphasis{list comprehension}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{squares}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A list comprehension consists of brackets containing an expression followed by a \sphinxcode{\sphinxupquote{for}} clause, then zero or more for or \sphinxcode{\sphinxupquote{if}} clauses. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it.

\sphinxAtStartPar
E.g. Let’s say we want the even numbers in the squares list:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{even\PYGZus{}squares} \PYG{o}{=} \PYG{p}{[}\PYG{n}{y} \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{squares} \PYG{k}{if} \PYG{n}{y}\PYG{o}{\PYGZpc{}}\PYG{k}{2} == 0]
\PYG{n}{even\PYGZus{}squares}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 4, 16, 36, 64]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Tuples and Sequences}
\label{\detokenize{Chapters/Chapter1/Chapter1:tuples-and-sequences}}
\sphinxAtStartPar
We saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). There is also another standard sequence data type: the tuple.

\sphinxAtStartPar
A tuple consists of a number of values separated by commas, for instance:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{12345}\PYG{p}{,} \PYG{l+m+mi}{54321}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello!}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
12345
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Tuples may be nested:}
\PYG{n}{u} \PYG{o}{=} \PYG{n}{t}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{u}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
((12345, 54321, \PYGZsq{}hello!\PYGZsq{}), (1, 2, 3, 4, 5))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists.

\sphinxAtStartPar
Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are \sphinxstyleemphasis{immutable}, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later) or indexing. Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Tuples are immutable:}
\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{88888}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{61}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{2}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} Tuples are immutable:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{88888}

\PYG{n+ne}{TypeError}: \PYGZsq{}tuple\PYGZsq{} object does not support item assignment
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Dictionaries}
\label{\detokenize{Chapters/Chapter1/Chapter1:dictionaries}}
\sphinxAtStartPar
Another useful data type built into Python is the dictionary. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by \sphinxstyleemphasis{keys}, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like append() and extend().

\sphinxAtStartPar
It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: \{\}. Placing a comma\sphinxhyphen{}separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output.

\sphinxAtStartPar
The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with del. If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non\sphinxhyphen{}existent key.

\sphinxAtStartPar
Performing \sphinxcode{\sphinxupquote{list(d)}} on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use \sphinxcode{\sphinxupquote{sorted(d)}} instead). To check whether a single key is in the dictionary, use the in keyword.

\sphinxAtStartPar
Here is a small example using a dictionary:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tel} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4098}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sape}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4139}\PYG{p}{\PYGZcb{}}
\PYG{n}{tel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{guido}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4127}
\PYG{n}{tel}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}jack\PYGZsq{}: 4098, \PYGZsq{}sape\PYGZsq{}: 4139, \PYGZsq{}guido\PYGZsq{}: 4127\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4098
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{tel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sape}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{irv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4127}
\PYG{n}{tel}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}jack\PYGZsq{}: 4098, \PYGZsq{}guido\PYGZsq{}: 4127, \PYGZsq{}irv\PYGZsq{}: 4127\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{tel}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}jack\PYGZsq{}, \PYGZsq{}guido\PYGZsq{}, \PYGZsq{}irv\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{tel}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}guido\PYGZsq{}, \PYGZsq{}irv\PYGZsq{}, \PYGZsq{}jack\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{guido}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{tel}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jack}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{tel}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{dict()}} constructor builds dictionaries directly from sequences of key\sphinxhyphen{}value pairs:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sape}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4139}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{guido}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4127}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4098}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}sape\PYGZsq{}: 4139, \PYGZsq{}guido\PYGZsq{}: 4127, \PYGZsq{}jack\PYGZsq{}: 4098\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}2: 4, 4: 16, 6: 36\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{sape}\PYG{o}{=}\PYG{l+m+mi}{4139}\PYG{p}{,} \PYG{n}{guido}\PYG{o}{=}\PYG{l+m+mi}{4127}\PYG{p}{,} \PYG{n}{jack}\PYG{o}{=}\PYG{l+m+mi}{4098}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}sape\PYGZsq{}: 4139, \PYGZsq{}guido\PYGZsq{}: 4127, \PYGZsq{}jack\PYGZsq{}: 4098\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Looping Techniques}
\label{\detokenize{Chapters/Chapter1/Chapter1:looping-techniques}}
\sphinxAtStartPar
When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the \sphinxcode{\sphinxupquote{items()}} method:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{knights} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gallahad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the pure}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{robin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the brave}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{knights}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
gallahad the pure
robin the brave
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the enumerate() function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{toe}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 tic
1 tac
2 toe
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To loop over two or more sequences at the same time, the entries can be paired with the zip() function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{questions} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quest}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{favorite color}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{answers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lancelot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the holy grail}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{q}\PYG{p}{,} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{questions}\PYG{p}{,} \PYG{n}{answers}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{What is your }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s1}{?  It is }\PYG{l+s+si}{\PYGZob{}1\PYGZcb{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To loop over a sequence in sorted order, use the \sphinxcode{\sphinxupquote{sorted()}} function which returns a new sorted list while leaving the source unaltered.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{basket} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{basket}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
apple
apple
banana
orange
orange
pear
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{set()}} on a sequence eliminates duplicate elements. The use of \sphinxcode{\sphinxupquote{sorted()}} in combination with \sphinxcode{\sphinxupquote{set()}} over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{basket} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{basket}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
apple
banana
orange
pear
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Modules}
\label{\detokenize{Chapters/Chapter1/Chapter1:modules}}

\subsection{User\sphinxhyphen{}Defined Modules}
\label{\detokenize{Chapters/Chapter1/Chapter1:user-defined-modules}}
\sphinxAtStartPar
If you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. The same happens when you open a new jupyter notebook. Therefore, if you want to write a somewhat longer program, you are better off using a text editor to prepare the input for the interpreter and running it with that file as input instead. This is known as creating a script. As your program gets longer, you may want to split it into several files for easier maintenance. You may also want to use a handy function that you’ve written in several programs without copying its definition into each program.

\sphinxAtStartPar
To support this, Python has a way to put definitions in a file and use them in a script or in an interactive instance of the interpreter. Such a file is called a \sphinxstyleemphasis{module}; definitions from a module can be imported into other modules or into the main module (the collection of variables that you have access to in a script executed at the top level and in calculator mode).

\sphinxAtStartPar
A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py appended. Within a module, the module’s name (as a string) is available as the value of the global variable \sphinxcode{\sphinxupquote{\_\_name\_\_}}. For instance, we have created a file called \sphinxcode{\sphinxupquote{fibo.py}} in the current directory with the following contents:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Fibonacci numbers module}

\PYG{k}{def} \PYG{n+nf}{fib}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}    \PYG{c+c1}{\PYGZsh{} write Fibonacci series up to n}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{fib2}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} return Fibonacci series up to n}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{n}{result}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s import this module:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{fibo}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
This does not add the names of the functions defined in fibo directly to the current namespace; it only adds the module name fibo there. Using the module name you can access the functions:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibo}\PYG{o}{.}\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibo}\PYG{o}{.}\PYG{n}{fib2}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibo}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}fibo\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There is a variant of the import statement that imports names from a module directly into the importing module’s namespace. For example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fibo} \PYG{k+kn}{import} \PYG{n}{fib}\PYG{p}{,} \PYG{n}{fib2}
\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There is even a variant to import all names that a module defines:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fibo} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If the module name is followed by \sphinxcode{\sphinxupquote{as}}, then the name following \sphinxcode{\sphinxupquote{as}} is bound directly to the imported module. This is effectively importing the module in the same way that \sphinxcode{\sphinxupquote{import fibo}} will do, with the only difference of it being available as \sphinxcode{\sphinxupquote{fib}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{fibo} \PYG{k}{as} \PYG{n+nn}{fib}
\PYG{n}{fib}\PYG{o}{.}\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It can also be used when utilising \sphinxcode{\sphinxupquote{from}} with similar effects:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fibo} \PYG{k+kn}{import} \PYG{n}{fib} \PYG{k}{as} \PYG{n}{fibonacci}
\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Standard Modules and the Standard Library}
\label{\detokenize{Chapters/Chapter1/Chapter1:standard-modules-and-the-standard-library}}
\sphinxAtStartPar
Python comes with a library of standard modules, described in a separate document, the Python Library Reference (“Library Reference” hereafter). The built\sphinxhyphen{}in function dir() is used to find out which names a module defines. It returns a sorted list of strings:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{fibo}
\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{fibo}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}\PYGZus{}\PYGZus{}builtins\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}cached\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}loader\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}package\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}\PYGZus{}\PYGZus{}spec\PYGZus{}\PYGZus{}\PYGZsq{},
 \PYGZsq{}fib\PYGZsq{},
 \PYGZsq{}fib2\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
For a longer introduction to the standard library, check out: \sphinxurl{https://docs.python.org/3/tutorial/stdlib.html}. Here, we will go through a few basic modules, and we will introduce more during the course.

\sphinxAtStartPar
The math module gives access to the underlying C library functions for floating point math:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.7071067811865476
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{math}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
10.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The random module provides tools for making random selections:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}banana\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{random}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} sampling without replacement}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[91, 73, 7, 46, 38, 20, 93, 64, 85, 32]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} random float}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.2067182414422717
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{random}\PYG{o}{.}\PYG{n}{randrange}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The statistics module calculates basic statistical properties (the mean, median, variance, etc.) of numeric data:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{statistics}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.75}\PYG{p}{,} \PYG{l+m+mf}{1.75}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{statistics}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{statistics}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{statistics}\PYG{o}{.}\PYG{n}{variance}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.6071428571428572
1.25
1.3720238095238095
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{NumPy}
\label{\detokenize{Chapters/Chapter1/Chapter1:numpy}}
\sphinxAtStartPar
NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.

\sphinxAtStartPar
To access NumPy and its functions import it:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Python lists vs NumPy arrays:

\sphinxAtStartPar
NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogeneous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren’t homogeneous.

\sphinxAtStartPar
NumPy arrays are faster and more compact than Python lists. An array consumes less memory and is convenient to use. NumPy uses much less memory to store data and it provides a mechanism of specifying the data types. This allows the code to be optimized even further.

\sphinxAtStartPar
One way we can initialize NumPy arrays is from Python lists, using nested lists for two\sphinxhyphen{} or higher\sphinxhyphen{}dimensional data.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The elements can be accessed in the same way as lists, e.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can add the arrays together with the plus sign.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ones} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{+} \PYG{n}{ones}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([2, 3])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can, of course, do more than just addition!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{\PYGZhy{}} \PYG{n}{ones}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([0, 1])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{*} \PYG{n}{data}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1, 4])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{/} \PYG{n}{data}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1., 1.])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Basic operations are simple with NumPy. If you want to find the sum of the elements in an array, you’d use \sphinxcode{\sphinxupquote{sum()}}. This works for 1D arrays, 2D arrays, and arrays in higher dimensions.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There are times when you might want to carry out an operation between an array and a single number (also called an operation between a vector and a scalar) or between arrays of two different sizes:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{*} \PYG{l+m+mf}{1.6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1.6, 3.2])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
With NumPy you can create and manipulate matrices, generate random numbers, and much more! We will discuss specific applications during the course, but see \sphinxurl{https://numpy.org/doc/stable/index.html} for detailed documentation.


\subsection{SciPy}
\label{\detokenize{Chapters/Chapter1/Chapter1:scipy}}
\sphinxAtStartPar
SciPy provides algorithms for optimization, integration, interpolation, eigenvalue problems, algebraic equations, differential equations, statistics and many other classes of problems. It is built on NumPy . It adds significant power to Python by providing the user with high\sphinxhyphen{}level commands and classes for manipulating and visualizing data.

\sphinxAtStartPar
Some subpackages of interest to physics are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Physical and mathematical constants (\sphinxcode{\sphinxupquote{scipy.constants}})

\item {} 
\sphinxAtStartPar
Special functions (\sphinxcode{\sphinxupquote{scipy.special}})

\item {} 
\sphinxAtStartPar
Integration (\sphinxcode{\sphinxupquote{scipy.integrate}})

\item {} 
\sphinxAtStartPar
Optimization (\sphinxcode{\sphinxupquote{scipy.interpolate}})

\item {} 
\sphinxAtStartPar
Fourier transforms (\sphinxcode{\sphinxupquote{scipy.fft}})

\item {} 
\sphinxAtStartPar
Signal processing (\sphinxcode{\sphinxupquote{scipy.signal}})

\item {} 
\sphinxAtStartPar
Linear Algebra (\sphinxcode{\sphinxupquote{scipy.linalg}})

\item {} 
\sphinxAtStartPar
Spatial data structures and algorithms (\sphinxcode{\sphinxupquote{scipy.spatial}})

\end{itemize}

\sphinxAtStartPar
See \sphinxurl{https://docs.scipy.org/doc/scipy/tutorial/index.html\#subpackages} for the full list of subpackages.

\sphinxAtStartPar
Some examples:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{special}\PYG{p}{,} \PYG{n}{integrate}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{speed\PYGZus{}of\PYGZus{}light} \PYG{c+c1}{\PYGZsh{} get the speed of light}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
299792458.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Compute the first ten zeros of integer\PYGZhy{}order Bessel functions Jn.}
\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{special}\PYG{o}{.}\PYG{n}{jn\PYGZus{}zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([ 5.1356223 ,  8.41724414, 11.61984117, 14.79595178, 17.95981949,
       21.11699705, 24.27011231, 27.42057355, 30.5692045 , 33.71651951])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the definite integral of sinx/x in [0,1]}
\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{integrate}\PYG{o}{.}\PYG{n}{quad}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0.9460830703671831, 1.0503632079297089e\PYGZhy{}14)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Matplotlib (Plotting)}
\label{\detokenize{Chapters/Chapter1/Chapter1:matplotlib-plotting}}
\sphinxAtStartPar
“If I can’t picture it, I can’t understand it.” \sphinxhyphen{} Albert Einstein

\sphinxAtStartPar
From the Matplotlib page: \sphinxurl{https://matplotlib.org}:
\begin{quote}

\sphinxAtStartPar
Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. Matplotlib makes easy things easy and hard things possible.
\end{quote}

\sphinxAtStartPar
Let’s start with a minimal example here (following \sphinxurl{https://matplotlib.org/stable/users/getting\_started/}):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array from 0 to 2pi, 200 equallys\PYGZhy{}paced points  }
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} take the NumPy array and create another one, where each term is now the sine of each of the elements of the above NumPy array}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single set of axes.}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8af0507c8edecb95d8936beb7dd92ebd7c6ae97370e3c4c003438b1825b8c2ba}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s add a title, axis labels and a legend:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array from 0 to 2pi, 200 equallys\PYGZhy{}paced points  }
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} take the NumPy array and create another one, where each term is now the sine of each of the elements of the above NumPy array}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sin (x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A first plot using Matplotlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{93ea03d46fdd0973b4c79eb89bb0cb1b55d03bca5c6392e3aead8ff304209b24}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also change the labels of the axes to whatever you like, and plot vertical (or horizontal) lines:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array from 0 to 2pi, 200 equallys\PYGZhy{}paced points  }
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} take the NumPy array and create another one, where each term is now the sine of each of the elements of the above NumPy array}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sin (x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A first plot using Matplotlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mf}{1.5} \PYG{o}{*} \PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticklabels}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}3}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}2}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}5}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}3}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot vertical lines at pi/2, pi, 3pi/2, 2pi, 5pi/2, 3pi}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{e777a7eef460e8a778a33d385bcf3668c9dd73f1e3c2d934ac91f7411c0467e7}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
One can plot with different colors and linestyles. See \sphinxurl{https://matplotlib.org/stable/api/\_as\_gen/matplotlib.lines.Line2D.html\#matplotlib.lines.Line2D.set\_linestyle} for linestyles and \sphinxurl{https://matplotlib.org/stable/users/explain/colors/colors.html} for colors.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array from 0 to 2pi, 200 equallys\PYGZhy{}paced points  }
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} take the NumPy array and create another one, where each term is now the sine of each of the elements of the above NumPy array}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} also get a cosine }

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A first plot using Matplotlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{1.1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a cos curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{aec14eb9dcfa69edb15f48dc4942a75fa533e15543a62d991132b487d3f39c9c}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also create scatter plots! Here’s an example, where we generate a completely uncorrelated set and a slightly correlated set:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array from 0 to 2pi, 200 equallys\PYGZhy{}paced points }
\PYG{c+c1}{\PYGZsh{} Now suppose that we have random noise around the curve y = x: }
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} generates a NumPy array of size 200 with random floats in [0,1)}

\PYG{c+c1}{\PYGZsh{} now generate a completely uncorrelated sample of size 200 }
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}b\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A scatter plot using Matplotlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, marker styles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linearly\PYGZhy{}correlated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uncorrelated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{framealpha}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend, make it opaque}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{fe36666ae935afb0b0fe9f797ccaa78f1a421a6641e8361d6047364e87fffbd6}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Matplotlib can also generate 2D plots, e.g. contours:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} make data: X and Y are defined over a 100x100 grid between (\PYGZhy{}1,1) in both dimensions. }
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} now calculate a function over this grid, e.g.: }
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{X}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{Y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{levels} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} calculate six \PYGZsq{}levels\PYGZsq{} on the contour}

\PYG{c+c1}{\PYGZsh{} plot}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make the contour:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{n}{levels}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{3c12ea15a54860e228b74f4eabadcf75b9598363c146abfd620643a9de41110c}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This can also be a “filled” contour, and you can add a color bar to help understand the contour:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} make data: X and Y are defined over a 100x100 grid between (\PYGZhy{}1,1) in both dimensions. }
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} now calculate a function over this grid, e.g.: }
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{X}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{Y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{levels} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} calculate six \PYGZsq{}levels\PYGZsq{} on the contour}

\PYG{c+c1}{\PYGZsh{} plot}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make the contour:}
\PYG{n}{cs} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{n}{levels}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} add a color bar:}
\PYG{n}{cbar} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cs}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cfb76c26deb5363e9450ac669425e3483cd752e39d3fa942261c5b7e66ead85c}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also plot in three\sphinxhyphen{}dimensions:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{cm}

\PYG{c+c1}{\PYGZsh{} Make data}
\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{p}{)}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{p}{)}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} You need the data to be defined over a grid }
\PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{X}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{Y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the surface}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{subplot\PYGZus{}kw}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{projection}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot\PYGZus{}surface}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{n}{Z}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Blues}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{xticklabels}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
       \PYG{n}{yticklabels}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
       \PYG{n}{zticklabels}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} remove tick labels}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{6531876f4437b553650ffa9fea9aeab254b116fa853e53e78329a82b2a174b01}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There’s tons of functionality in Matplotlib! For examples, check out: \sphinxurl{https://matplotlib.org/stable/plot\_types/index.html} and \sphinxurl{https://matplotlib.org/stable/gallery/index.html}.


\section{Other Useful Modules}
\label{\detokenize{Chapters/Chapter1/Chapter1:other-useful-modules}}

\subsection{pandas}
\label{\detokenize{Chapters/Chapter1/Chapter1:pandas}}
\sphinxAtStartPar
According to the pandas webpage: \sphinxurl{https://pandas.pydata.org}
\begin{quote}

\sphinxAtStartPar
pandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool,
built on top of the Python programming language.
\end{quote}

\sphinxAtStartPar
pandas is useful when working with tabular data, such as data stored in spreadsheets or databases. pandas can help you to explore, clean, and process your data. In pandas, a data table is called a \sphinxcode{\sphinxupquote{DataFrame}}.

\sphinxAtStartPar
We will introduce some pandas functionality during the course.


\subsection{PrettyTable}
\label{\detokenize{Chapters/Chapter1/Chapter1:prettytable}}
\sphinxAtStartPar
PrettyTable is “a simple Python library for easily displaying tabular data in a visually appealing ASCII table format”. (\sphinxurl{https://pypi.org/project/prettytable/}).

\sphinxAtStartPar
Here’s an example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{prettytable} \PYG{k+kn}{import} \PYG{n}{PrettyTable}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{PrettyTable}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{field\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Particle Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Electric Charge}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Spin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{add\PYGZus{}row}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Electron}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1/2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{add\PYGZus{}row}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Photon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{add\PYGZus{}row}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Higgs Boson}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{add\PYGZus{}row}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Positron}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1/2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{add\PYGZus{}row}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Graviton}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
| Particle Name | Electric Charge | Spin |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|    Electron   |        \PYGZhy{}1       | 1/2  |
|     Photon    |        0        |  1   |
|  Higgs Boson  |        0        |  1   |
|    Positron   |        +1       | 1/2  |
|    Graviton   |        0        |  2   |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{tqdm}
\label{\detokenize{Chapters/Chapter1/Chapter1:tqdm}}
\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{tqdm}} you can instantly make your loops show a smart progress meter. e.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tqdm} \PYG{k+kn}{import} \PYG{n}{tqdm}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{tqdm}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
100\PYGZpc{}|████████████████████████████████████████████████████████████████████████████████████| 20/20 [00:02\PYGZlt{}00:00,  9.42it/s]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{SymPy}
\label{\detokenize{Chapters/Chapter1/Chapter1:sympy}}
\sphinxAtStartPar
From the SymPy webpage (\sphinxurl{https://www.sympy.org/en/index.html}):
\begin{quote}

\sphinxAtStartPar
SymPy is a Python library for symbolic mathematics. It aims to become a full\sphinxhyphen{}featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.
\end{quote}

\sphinxAtStartPar
Here’s an example of what SymPy can do:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{nu} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x t z nu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{n}{use\PYGZus{}unicode}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} take the derivative of sin(x) * exp(x) wrt. x:}
\PYG{n}{diff}\PYG{p}{(}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{88611eda9401879419468b7500587c3015c489a63bc89f2aabd0b928b3462da4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} integrate the above to get the function back!}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{28d55be824980dc741ad40fc753a8617acf0e2bc0151d38183c60f184acb074d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} calculate the integral of sin(x**2) dx from \PYGZhy{}infinity to +infinity:}
\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{oo}\PYG{p}{,} \PYG{n}{oo}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2ea61f491bea77a259ec499d541af4127d50eb61b5efd4cc20ed04bdd77394ae}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} find the limit of sin(x)/x as x\PYGZhy{}\PYGZgt{}0:}
\PYG{n}{limit}\PYG{p}{(}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{d81096050bd44ce57b5d5fe4208dfd494a47c011aecee7a2c422785cd87b6ef4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} solve the equation x**2 \PYGZhy{} 2 = 0 for x:}
\PYG{n}{solve}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{9cbb813dd92da3329623663c900326d767d72e12f725ce314541001f5d472b5f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also output directly in LaTeX!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{latex}\PYG{p}{(}\PYG{n}{Integral}\PYG{p}{(}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}\PYGZbs{}\PYGZbs{}int\PYGZbs{}\PYGZbs{}limits\PYGZus{}\PYGZob{}0\PYGZcb{}\PYGZca{}\PYGZob{}\PYGZbs{}\PYGZbs{}pi\PYGZcb{} \PYGZbs{}\PYGZbs{}cos\PYGZca{}\PYGZob{}2\PYGZcb{}\PYGZob{}\PYGZbs{}\PYGZbs{}left(x \PYGZbs{}\PYGZbs{}right)\PYGZcb{}\PYGZbs{}\PYGZbs{}, dx\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{n}{use\PYGZus{}unicode}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Machine Learning with PyTorch}
\label{\detokenize{Chapters/Chapter1/Chapter1:machine-learning-with-pytorch}}
\sphinxAtStartPar
According to Wikipedia (\sphinxurl{https://en.wikipedia.org/wiki/PyTorch}):
\begin{quote}

\sphinxAtStartPar
PyTorch is a machine learning framework based on the Torch library, used for applications such as computer vision and natural language processing, originally developed by Meta AI and now part of the Linux Foundation umbrella.
\end{quote}

\sphinxstepscope


\chapter{Computer Number Representations}
\label{\detokenize{Chapters/Chapter2/Chapter2:computer-number-representations}}\label{\detokenize{Chapters/Chapter2/Chapter2::doc}}

\section{Introduction to Computer Number Representations}
\label{\detokenize{Chapters/Chapter2/Chapter2:introduction-to-computer-number-representations}}
\sphinxAtStartPar
Computers are powerful, but they are \sphinxstyleemphasis{finite}.

\sphinxAtStartPar
A problem in computer design is how to represent an arbitrary number using a finite amount of memory space, and then how to deal with the limitations arising from this representation.

\sphinxAtStartPar
Computer memories are based on magnetic or electronic realizations of a spin pointing up or down. Therefore, the most elementary units of computer memory are two binary integers (bits) 0 and 1.

\sphinxAtStartPar
All numbers are stored in computer memory in the binary form, i.e. as long strings of 0s and 1s.

\sphinxAtStartPar
\(N\) bits can store integers in the range \([0, 2^{N-1}]\). \(N-1\) since the first bit represents the sign: e.g. 0 for positive numbers.

\sphinxAtStartPar
The description of a particular computer’s system or language states the “word length”, i.e. the number of bits used to store a number.

\sphinxAtStartPar
The length is often expressed in bytes (i.e. a \sphinxstyleemphasis{mouthful of bits!}), where:

\sphinxAtStartPar
1 byte = 1 B = 8 bits

\sphinxAtStartPar
Memory sizes are measured in bytes, kilobytes, megabytes, gigabytes, terabytes, petabytes.

\sphinxAtStartPar
1 K = 1 kB = \(2^{10}\) bytes = 1024 bytes.

\sphinxAtStartPar
1 byte is also the amount of memory needed to store a single letter like “a”. This adds up to a typical printed page requiring \textasciitilde{}3 kB.

\sphinxAtStartPar
Memory in older personal computers (PCs): uses 8\sphinxhyphen{}bit words, and therefore for these systems, the maximum integer was \(2^7 = 128\).

\sphinxAtStartPar
With 64\sphinxhyphen{}bit (modern PCs): \(1 - 2^{63} \simeq 1-10^{19}\).

\sphinxAtStartPar
Trying to store a number larger than the hardware/software was designed for (overflow) was common in older machines!


\section{Floating\sphinxhyphen{}Point Numbers}
\label{\detokenize{Chapters/Chapter2/Chapter2:floating-point-numbers}}
\sphinxAtStartPar
Real numbers are represented on computers in either fixed\sphinxhyphen{}point or floating\sphinxhyphen{}point notations.

\sphinxAtStartPar
In fixed\sphinxhyphen{}point notation, numbers are represented with a fixed number of places beyond the decimal point (e.g. integers).

\sphinxAtStartPar
Most scientific computations use double\sphinxhyphen{}precision floating\sphinxhyphen{}point numbers with 64 bits = 8 B. (Note that in particle physics, and other fields of physics, quadruple precision is necessary for some calculations! There are specialized libraries for this purpose).

\sphinxAtStartPar
64 bit double precision floating\sphinxhyphen{}point numbers are called \sphinxcode{\sphinxupquote{float}} in Python.

\sphinxAtStartPar
In 1987 the Institute of Electrical \& Electronics Engineers (IEEE) and the American National Standards Institute (ANSI) adopted the IEEE754 standard for floating point arithmetics.

\sphinxAtStartPar
Bit allocation (IEEE754 standard):
\begin{itemize}
\item {} 
\sphinxAtStartPar
1 bit is allocated to the sign indicator, \(s\).

\item {} 
\sphinxAtStartPar
11 bits are allocated to the exponent, \(e\).

\item {} 
\sphinxAtStartPar
52 bits are allocated to the fraction, \(f\).

\end{itemize}

\sphinxAtStartPar
A 64\sphinxhyphen{}bit (double precision) float can then be represented in decimal (base 10) by the formula:

\sphinxAtStartPar
\(n= (-1)^s\times 2^{e-1023} \times (1+f)\)

\sphinxAtStartPar
The value subtracted from the exponent is known as the \sphinxstyleemphasis{bias}, 1023 in this case.

\sphinxAtStartPar
Let’s see how this formula can be used to represent a number:
\begin{quote}

\sphinxAtStartPar
What is the number 1 10000000010 1000000000000000000000000000000000000000000000000000 (IEEE754) in base 10?

\sphinxAtStartPar
Answer:

\sphinxAtStartPar
The sign of the number is \((-1)^1=-1\).

\sphinxAtStartPar
The exponent in decimal is \(e = 1\cdot 2^{10} + 1 \cdot 2^1 = 1026\) and therefore the total exponent is \(1026 - 1023 = 3\).

\sphinxAtStartPar
The fraction is \(f = 1 \cdot \frac{1}{2^1} + 0 \cdot \frac{1}{2^2} + ... = 0.5\).

\sphinxAtStartPar
So:

\sphinxAtStartPar
\(n = (-1)^1 \times 2^3 \times (1+0.5) = -12.0\) in base 10.
\end{quote}

\sphinxAtStartPar
Let’s try the opposite operation: given a number in base 10, let’s try to find a binary representation:
\begin{quote}

\sphinxAtStartPar
What is 15.0 (in base 10) in IEEE754 binary? What is the largest number smaller than 15.0? What is the smallest number larger than 15.0?

\sphinxAtStartPar
The number is positive, so \(s=0\).

\sphinxAtStartPar
We then ask for the exponent \(2^{e-1023}\) to give us the last number which is a power of two that is smaller than 15.0. i.e. \(2^3 = 8\), and therefore \(e=1026\). In binary form 1026 is: 2\textasciicircum{}1 + 2\textasciicircum{}10 or 10000000010.

\sphinxAtStartPar
Then the fraction remains. To obtain this we solve:

\sphinxAtStartPar
\((1+f) = n/2^3\) so: \(f = 15/8 -1 = 0.875\). To get the binary representation try: \(0.875 = 1 \cdot \frac{1}{2^1} + 1 \cdot \frac{1}{2^2} + 1 \cdot \frac{1}{2^3}\), so 0.875(base 10) = 1110000000000000000000000000000000000000000000000000 (base 2).

\sphinxAtStartPar
Putting these numbers together gives us the representation of 15.0 in IEEE754:

\sphinxAtStartPar
0 10000000010 1110000000000000000000000000000000000000000000000000

\sphinxAtStartPar
The next smallest number is: 0 10000000010 1101111111111111111111111111111111111111111111111111, which we can calculate to be:

\sphinxAtStartPar
\(n = (-1)^0 \times 2^3 \times (1 \cdot \frac{1}{2^1} + 1 \cdot \frac{1}{2^2} + 1 \cdot \frac{1}{2^4} + 1 \cdot \frac{1}{2^5} + ... + 1 \cdot \frac{1}{2^{52}}) = 14.9999999999999982236431605997\)

\sphinxAtStartPar
and the next largest number is:  0 10000000010 1110000000000000000000000000000000000000000000000001 = 15.0000000000000017763568394003
\end{quote}

\sphinxAtStartPar
From the above, we can conclude that the IEEE754 number representing 15.0 also represents real numbers halfway between its immediate neighbors. Any computation that results in a number within this interval will be assigned the number 15.0

\sphinxAtStartPar
We call the distance from one number to the next the \sphinxstyleemphasis{gap}. Since the fraction is multiplied by \(2^{e-1023}\), the gap grows as the number represented grows. The gap at any given number can be computed using numpy:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{np}\PYG{o}{.}\PYG{n}{spacing}\PYG{p}{(}\PYG{l+m+mf}{1e9}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.float64(1.1920928955078125e\PYGZhy{}07)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There are special cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
When \(e=0\): the leading 1 in the fraction takes the value 0 instead. The result is called a \sphinxstyleemphasis{subnormal} number and is computed by \(n=(-1)^s 2^{-1023} (0+f)\).

\item {} 
\sphinxAtStartPar
When \(e=2047\) and \(f\) is non zero, then the result is “not a number”, \sphinxcode{\sphinxupquote{NAN}}, i.e. undefined.

\item {} 
\sphinxAtStartPar
When \(e=2047\), \(f=0\), \(s=0\) the result is positive infinity, \sphinxcode{\sphinxupquote{+INF}}.

\item {} 
\sphinxAtStartPar
When \(e=2047\), \(f=0\), \(s=1\) the result is negative infinity, \sphinxcode{\sphinxupquote{\sphinxhyphen{}INF}}.

\end{itemize}

\sphinxAtStartPar
Overflow occurs when numbers exceed the maximum value that can be represented. Python will assign this number to \sphinxcode{\sphinxupquote{INF}}.

\sphinxAtStartPar
Underflow occurs when small nonzero values become too small, smaller than the smallest subnormal number. Python will assign a zero.

\sphinxAtStartPar
You can check these values using the sys module:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{max}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{min}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.7976931348623157e+308
2.2250738585072014e\PYGZhy{}308
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Errors and Uncertainties in Computations}
\label{\detokenize{Chapters/Chapter2/Chapter2:errors-and-uncertainties-in-computations}}

\subsection{Types of Errors}
\label{\detokenize{Chapters/Chapter2/Chapter2:types-of-errors}}
\sphinxAtStartPar
Four general types of errors exist to plague your computations:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Blunders or bad theory}: typos in program or data, fault in reasoning (i.e. in the theoretical description), using the wrong data files, etc..

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Random errors}: imprecision caused by events such as fluctuations in electronics, cosmic rays, etc..

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Approximation errors}: Imprecision arising from simplifying the math so that a problem can be solved on a computer. e.g. replacement of infinite series by a finite sums, of infinitesimal intervals by finite ones, by variable functions by constants, e.g.:

\end{enumerate}

\sphinxAtStartPar
\(\sin(x) = \sum_{n=1}^{\infty} \frac{ (-1)^{n-1} x^{2n-1} } { (2n-1)! }\) (exact)

\sphinxAtStartPar
vs.

\sphinxAtStartPar
\(\sin(x) \simeq \sum_{n=1}^{N} \frac{ (-1)^{n-1} x^{2n-1} } { (2n-1)! } + \epsilon(x,N)\)

\sphinxAtStartPar
\(\epsilon(x,N)\)  is the approximation (or algorithmic) error = the series from \(N+1\) to \(\infty\).

\sphinxAtStartPar
For any reasonable approximation, this error should decrease as \(N\) increases and should vanish in the limit \(N\rightarrow \infty\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Round\sphinxhyphen{}off errors}: Imprecision arising arising from the finite number of digits used to store floating\sphinxhyphen{}point numbers. This is analogous to the uncertainty in the measurement of a physical quantity in an elementary physics lab. Round\sphinxhyphen{}off errors accumulate as the computer handles more numbers, i.e. as the number of steps in a computation increases. This may cause some algorithms to become unstable with a rapid increase in error. In some cases the round\sphinxhyphen{}off error may become a major component in your answer, leading to “garbage”.

\end{enumerate}

\sphinxAtStartPar
e.g. if a computer stores 1/3 as 0.3333 and 2/3 as 0.6667, if we ask the computer to do 2*(1/3) \sphinxhyphen{} 2/3 = 0.6666 \sphinxhyphen{} 0.6667 = \sphinxhyphen{}0.0001. Although small, this error is non\sphinxhyphen{}zero. If this is repeated millions of times, the final answer might not even be small!


\subsection{Subtractive Cancelation}
\label{\detokenize{Chapters/Chapter2/Chapter2:subtractive-cancelation}}
\sphinxAtStartPar
Calculations employing numbers that are stored only approximately on the computer can only be expected to yield approximate answers.

\sphinxAtStartPar
We model the computer representation, \(x_c\), of the exact number \(x\), as:

\sphinxAtStartPar
\(x_c \simeq x ( 1 + \epsilon_x )\),

\sphinxAtStartPar
where \(\epsilon_x\) is the relative error in \(x_c\). We expect this to be of the same order as the “machine precision”. In particular, we expect double\sphinxhyphen{}precision numbers to have an error in the 15th decimal place.

\sphinxAtStartPar
We can apply this notation to simple subtraction: \(a = b - c\).

\sphinxAtStartPar
On a computer, this would be: \(a_c \simeq b_c - c_c \simeq b(1+\epsilon_b) - c( 1 + \epsilon_c)\).

\sphinxAtStartPar
So:

\sphinxAtStartPar
\(\frac{a_c}{a} \simeq 1 + \epsilon_b \frac{b}{a} - \frac{c}{a} \epsilon_c\)

\sphinxAtStartPar
Observe that: when we subtract two nearly equal numbers, i.e.,

\sphinxAtStartPar
\(  b \simeq c \gg a\)

\sphinxAtStartPar
Then:

\sphinxAtStartPar
\(\frac{a_c}{a} \equiv 1 + \epsilon_a \simeq 1 + \frac{b}{a} (\epsilon_b - \epsilon_c) \simeq 1 + \frac{b}{a}(|\epsilon_b|+|\epsilon_c|)\)

\sphinxAtStartPar
Even if the relative errors somewhat cancel, they are still multiplied by a large number, \(b/a\). This can significantly magnify the error. But since we cannot assume a sign for the errors, we can assume the worst, i.e. that they add up.

\sphinxAtStartPar
As a more explicit mathematical example, consider the constructing the expansion of \(e^{-x}\) for \sphinxstylestrong{large values of \(x\)}:

\sphinxAtStartPar
\(e^{-x} = 1 - x + \frac{x^2}{2!} - \frac{x^3}{3!} + ... \)

\sphinxAtStartPar
The first few terms are large, but of alternating sign, leading to an almost total cancelation in order to yield the final small result.

\sphinxAtStartPar
This subtractive cancelation can be eliminated by considering \(e^{-x} = 1/e^x\) instead, but round\sphinxhyphen{}off errors still remain, which we examine next.


\subsection{Round\sphinxhyphen{}off Errors}
\label{\detokenize{Chapters/Chapter2/Chapter2:round-off-errors}}
\sphinxAtStartPar
Error arises from a single division of the computer representations of two numbers:

\sphinxAtStartPar
\(a = \frac{b}{c} \rightarrow a_c = \frac{b_c}{c_c} = \frac{b}{c} \left( \frac{1+\epsilon_b}{1+\epsilon_c} \right)\),

\sphinxAtStartPar
so:

\sphinxAtStartPar
\(\frac{a_c}{a} = \frac{1+\epsilon_b}{1+\epsilon_c} \simeq (1+\epsilon_b) (1- \epsilon_c) \simeq 1 + \epsilon_b - \epsilon_c\),

\sphinxAtStartPar
where we have ignored terms of order \(\epsilon^2\).

\sphinxAtStartPar
We need to assume the worst for the error subtraction, and get:

\sphinxAtStartPar
\(\frac{a_c}{a} \simeq 1 + |\epsilon_b| + |\epsilon_c|\).

\sphinxAtStartPar
Can generalize this to estimate the error in the evaluation of a general function \(f(x)\):

\sphinxAtStartPar
\(\epsilon = \frac{ f(x) - f(x_c) } { f(x) } \simeq \frac{\mathrm{d} f(x) / \mathrm{d}x}{f(x)} (x-x_c)\).

\sphinxAtStartPar
E.g. for \(f(x) = \sqrt{1+x}\): \(\frac{ \mathrm{d} f}{\mathrm{d}x} = \frac{1}{2} \frac{1}{\sqrt{1+x}}\;.\)

\sphinxAtStartPar
\(\epsilon =  \frac{x - x_c}{2 (1+x) }\;.\)

\sphinxAtStartPar
e.g. Evaluate at \(x=\pi/4\) and assume an error in the 4th decimal place of \(x\), then we obtain a similar error of \(1.5\times 10^{-4}\) on \(f(x) = \sqrt{1+x}\).


\section{Round\sphinxhyphen{}off Error Accumulation}
\label{\detokenize{Chapters/Chapter2/Chapter2:round-off-error-accumulation}}
\sphinxAtStartPar
If a calculation has a large number of steps, we can view the error as a step in a random walk.

\sphinxAtStartPar
For a random walk (see later), the total distance \(R\), covered in \(N\) steps of length \(r\) is:

\sphinxAtStartPar
\(R = \sqrt{N} r\)

\sphinxAtStartPar
By analogy, the total relative error after \(N\) calculational steps, each with machine precision, \(\epsilon_m\), is on average:

\sphinxAtStartPar
\(\epsilon_\mathrm{ro} = \sqrt{N} \epsilon_m\)

\sphinxAtStartPar
If the round\sphinxhyphen{}off error does not accumulate in a random manner: a more detailed analysis is needed.

\sphinxAtStartPar
In some cases there may be no cancelation, and the error may increase as \(N \epsilon_m\) instead. Even worse, in some recursive algorithms, error generation can be coherent, leading to a \(N!\) increase in error.

\sphinxstepscope


\chapter{Randomness and Random Walks}
\label{\detokenize{Chapters/Chapter3/Chapter3:randomness-and-random-walks}}\label{\detokenize{Chapters/Chapter3/Chapter3::doc}}

\section{Deterministic Randomness}
\label{\detokenize{Chapters/Chapter3/Chapter3:deterministic-randomness}}
\sphinxAtStartPar
Some people are attracted to computing because of its deterministic nature. Nevertheless, many computer cycles are used for \sphinxstylestrong{Monte Carlo calculations}.

\sphinxAtStartPar
Monte Carlo calculations include elements of chance at their very core (hence the name). They involve \sphinxstyleemphasis{random\sphinxhyphen{}like} numbers generated by a computer to simulate naturally\sphinxhyphen{}random processes, such as thermal motion or radioactive decay.

\sphinxAtStartPar
Monte Carlo techniques are able to solve very challenging problems!


\section{Random Sequences}
\label{\detokenize{Chapters/Chapter3/Chapter3:random-sequences}}
\sphinxAtStartPar
We define a sequence \(r_1, r_2,...\) as random if there are no correlations between the coefficients.

\sphinxAtStartPar
But: being random does not mean all numbers in the sequence are equally likely to occur!

\sphinxAtStartPar
If all numbers in a sequence are equally likely to occur: the sequence is called \sphinxstylestrong{uniform}.

\sphinxAtStartPar
Mathematically: the likelihood of a number occurring is described by a distribution \(P(r)\), where \(P(r)\mathrm{d}r\) is the probability of finding \(r\) in the interval \([r, r+\mathrm{d}r]\).

\sphinxAtStartPar
For a \sphinxstylestrong{uniform distribution}: \(P(r) = \mathrm{constant}\).

\sphinxAtStartPar
The standard random number generator on computers generates \sphinxstyleemphasis{uniform} distributions between 0 and 1, i.e. it outputs numbers in this interval with equal probability, yet independent from the previous number.

\sphinxAtStartPar
By their nature: computers are deterministic devices, and therefore cannot create a random sequence. Computed random number sequences must contain correlations, and therefore cannot be truly random. This implies that if we know \(r_m\) and its preceding elements, then it is always possible to figure out \(r_{m+1}\). For this reason, computers are said to generate \sphinxstylestrong{pseudorandom numbers}.

\sphinxAtStartPar
A primitive alternative to this is to read off a table of truly random numbers, determined by  naturally\sphinxhyphen{}random process, such as radioactive decay, or to connect the computer to an experimental device that measures random events.


\subsection{Random Number Generation}
\label{\detokenize{Chapters/Chapter3/Chapter3:random-number-generation}}
\sphinxAtStartPar
Sequences of pseudorandom numbers can be generated on a computer via the “linear congruent” or “power residue” method:

\sphinxAtStartPar
To generate a pseudorandom sequence of numbers \(0 \leq r_i \leq M-1\) over the interval \([0, M-1]\), starting with \(r_1\), to obtain the next random number \(r_2\), multiply \(r_1\) by a constant \(a\), add another constant \(c\) and keep the \sphinxstyleemphasis{remainder}. Repeat this with \(r_2\) to get \(r_3\) and so on. So to get \(r_{i+1}\), given \(r_i\):

\sphinxAtStartPar
\(r_{i+1} = \mathrm{remainder} \left( \frac{a r_i + c}{M} \right)\)

\sphinxAtStartPar
The initial number, the \sphinxstyleemphasis{seed}, \(r_1\) is frequently supplied by the user.

\sphinxAtStartPar
In Python the remainder is given by the operator “\%”, i.e. the above equation would read: \sphinxcode{\sphinxupquote{rnext = (a * rprevious + c)\%M}}.

\sphinxAtStartPar
One can then divide the whole sequence by \(M\) to get numbers in the interval \([0,1]\).

\sphinxAtStartPar
If we want random numbers in an interval \([A,B]\) instead, then we can transform the generated sequence in the interval \([0,1]\), by:

\sphinxAtStartPar
\(x_i = A + (B-A) r_i\)

\sphinxAtStartPar
Note that the linear congruent method becomes completely correlated if a particular interger comes up a second time. The whole cycle then repeats.

\sphinxAtStartPar
If e.g. 48\sphinxhyphen{}bit arithmetic is used, then \(M \sim 2^{48} \simeq 3\times 10^{14}\). If your program would then use approximately these many random numbers (feasible, e.g. if your program is performing Monte Carlo simulations in many dimensions!), then you may need to “re\sphinxhyphen{}seed” (i.e. choose a new seed) to reset the sequence during intermediate steps.

\sphinxAtStartPar
In Python, the default \sphinxcode{\sphinxupquote{random.random()}} algorithm is the “Mersernne Twister”. It has an extremely long period: \(2^{19937} -1\) (a prime number) which is approximately \(4.3 \times 10^{6001}\). This is many orders of magnitude larger than the estimated number of particles in the observable universe (\(\sim 10^{87}\)).

\sphinxAtStartPar
See Wikipedia entry for more details, \sphinxurl{https://en.wikipedia.org/wiki/Mersenne\_Twister}, as well as original paper: \sphinxurl{https://dl.acm.org/doi/pdf/10.1145/272991.272995}.


\subsection{Generating Random Numbers of Arbitrary Distributions}
\label{\detokenize{Chapters/Chapter3/Chapter3:generating-random-numbers-of-arbitrary-distributions}}
\sphinxAtStartPar
Supose we possess a random number generator that yields uniform random numbers in the interval \([0,1]\). We can use it to generate random numbers according to any distribution using the \sphinxstyleemphasis{inversion method}.

\sphinxAtStartPar
The method proceeds as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Suppose we want to distribute random numbers according to a function \(f(x)\). We first calculate the \sphinxstyleemphasis{cumulative} distribution function (CDF) as: \(F(x) = \int^x_0 \mathrm{d}x f(x)\).

\item {} 
\sphinxAtStartPar
We then find the inverse of the desired CDF, i.e. we solve \(y=F(x)\) as \(F^{-1}(y)=x\).

\item {} 
\sphinxAtStartPar
If then “draw” \(y_0\) and calculate \(x_0 = F^{-1}(y_0)\), then \(x_0\) is distributed according to \(f(x)\).

\end{enumerate}

\sphinxAtStartPar
Here’s an example for \(f(x)=3x^2\) for \(x \in [0,1]\). Note that \(\int_0^1 \mathrm{d} x f(x)= 1\) for \(f(x)\) in \([0,1]\), as expected for a probability distribution.

\sphinxAtStartPar
The CDF is \(F(x) = x^3\). Then \(x = y^{1/3}\) and so we have:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random} 
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} We have x = (y)**(1/3) and we pick y in [0,1] }
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} generate 1000 points}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} generate random numbers in [0,1]}
    \PYG{n}{x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} create the real distribution for comparison. Use numpy\PYGZdq{}}
\PYG{n}{xcomp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{ycomp} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{square}\PYG{p}{(}\PYG{n}{xcomp}\PYG{p}{)}
    
\PYG{c+c1}{\PYGZsh{} create a histogram of x:}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}P(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Histogram}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make a histogram of the values, density=True normalizes the histogram}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generated values via inversion method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} compare to how we expect it to look like:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xcomp}\PYG{p}{,} \PYG{n}{ycomp}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{expected shape of \PYGZdl{}f(x) = 3x\PYGZca{}2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{3}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{random} 
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6} \PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}matplotlib\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This method predicates on the existence of an analytical expression for the CDF and its inverse, and therefore is not always useful! (see later)


\section{Random Walks}
\label{\detokenize{Chapters/Chapter3/Chapter3:random-walks}}
\sphinxAtStartPar
Consider a pizza brought into this room. The molecules from its smell collide randomly with other molecules in the air and eventually reach your nose.

\sphinxAtStartPar
The problem is to determine how many collisions, on average, a scent molecule makes in traveling a distance \(R\), given that it travels an average (root\sphinxhyphen{}mean\sphinxhyphen{}square) distance \(r_\mathrm{rms}\) between collisions.


\subsection{Random Walks: Theoretical Description}
\label{\detokenize{Chapters/Chapter3/Chapter3:random-walks-theoretical-description}}
\sphinxAtStartPar
A “walker” takes sequential steps with the direction of each step independent of the direction of the previous step.

\sphinxAtStartPar
Let’s consider a two\sphinxhyphen{}dimensional model. Start at the origin and take \(N\) steps in the \(xy\)\sphinxhyphen{}plane of lengths:

\sphinxAtStartPar
\((\Delta x_1, \Delta y_1), (\Delta x_2, \Delta y_2), ..., (\Delta x_N, \Delta y_N)\)

\sphinxAtStartPar
then, we have:

\sphinxAtStartPar
\(R^2 = (\Delta x_1 + \Delta x_2 + ... + \Delta x_N)^2 + (\Delta y_1 + \Delta y_2 + ... + \Delta y_N)^2\).

\sphinxAtStartPar
\(\Rightarrow R^2 = \Delta x_1^2 + \Delta x_2^2 + \Delta x_N^2 + 2 \Delta x_1 \Delta x_2 + 2 \Delta x_1 \Delta x_3 +  ... + (x \rightarrow y)\).

\sphinxAtStartPar
If a walk is random, then the walker is equally likely to travel in any direction at each step. If we take the average of \(R^2\) over a large number of such random steops, we expect that all cross terms would vanish:

\sphinxAtStartPar
\(\left< R^2 \right> = \left< (\Delta x_1^2 + \Delta y_1^2) + (\Delta x_2^2 + \Delta y_1^2) + .. + (\Delta x_N^2 + \Delta y_N^2) \right> = N \left<r^2\right> = N r_\mathrm{rms}^2\)

\sphinxAtStartPar
where \(r_\mathrm{rms} = \sqrt{\left< r^2 \right>}\).

\sphinxAtStartPar
So:

\sphinxAtStartPar
\(R_\mathrm{rms} = \sqrt{\left< R^2 \right>} = \sqrt{N} r_\mathrm{rms}\).

\sphinxAtStartPar
Let’s investigate this theoretical description through a simulation!

\sphinxAtStartPar
Before we do so, let’s introduce the concept of classes in Python (object\sphinxhyphen{}oriented programming), and use it in our example.


\section{Digression: Object\sphinxhyphen{}Oriented Programming in Python}
\label{\detokenize{Chapters/Chapter3/Chapter3:digression-object-oriented-programming-in-python}}
\sphinxAtStartPar
Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made.

\sphinxAtStartPar
The simplest form of a class definition looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ClassName}\PYG{p}{:}
    \PYG{o}{\PYGZlt{}}\PYG{n}{statement}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
    \PYG{o}{.}
    \PYG{o}{.}
    \PYG{o}{.}
    \PYG{o}{\PYGZlt{}}\PYG{n}{statement}\PYG{o}{\PYGZhy{}}\PYG{n}{N}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can read all about classes and object\sphinxhyphen{}oriented programming at: \sphinxurl{https://docs.python.org/3/tutorial/classes.html}. Here we are going to proceed by example.

\sphinxAtStartPar
Suppose we wish to create a new object that has the properties we expect from complex numbers. We want this object to have a real and imaginary part, and we want to easily access those, as well as perform various operations on it: e.g. get its modulus, complex conjugate or argument.

\sphinxAtStartPar
We can begin by defining a class as follows:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define a new class called Complex with real and imaginary parts (.r and .i):}
\PYG{k}{class} \PYG{n+nc}{Complex}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A simple complex number class\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{realpart}\PYG{p}{,} \PYG{n}{imagpart}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r} \PYG{o}{=} \PYG{n}{realpart}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i} \PYG{o}{=} \PYG{n}{imagpart}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I have created a new complex variable with r,i=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\_\_init\_\_()}} method is automatically invoked when you create an instance of this class:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create an \PYGZdq{}instance\PYGZdq{} of the Complex class: }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{Complex}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{4.5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the real part is 3.0 and the imaginary part is 4.5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{real part=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{imaginary part=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{Complex}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{o}{.}\PYG{n}{r}\PYG{p}{,} \PYG{n}{y}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I have created a new complex variable with r,i= 3.0 4.5
real part= 3.0
imaginary part= 4.5
I have created a new complex variable with r,i= 1.0 \PYGZhy{}1.5
1.0 \PYGZhy{}1.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can also add “attribute references”, i.e. functions that operate on instances of this function:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} define the Complex class, with mod(), arg() and cc() functions to return:}
\PYG{c+c1}{\PYGZsh{} modulus, argument and complex conjugate}
\PYG{c+c1}{\PYGZsh{} see https://en.wikipedia.org/wiki/Complex\PYGZus{}number for details }
\PYG{k}{class} \PYG{n+nc}{Complex}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A more advanced complex number class\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{realpart}\PYG{p}{,} \PYG{n}{imagpart}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r} \PYG{o}{=} \PYG{n}{realpart}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i} \PYG{o}{=} \PYG{n}{imagpart}

    \PYG{c+c1}{\PYGZsh{} the modulus:}
    \PYG{k}{def} \PYG{n+nf}{mod}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} the argument }
    \PYG{k}{def} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{!=}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{arg} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{atan}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{/}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{+}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{arg} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}
        \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{arg} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{arg} 

    \PYG{c+c1}{\PYGZsh{} the complex conjugate, return a Complex object with \PYGZhy{} the imaginary part}
    \PYG{k}{def} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{Complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create an \PYGZdq{}instance\PYGZdq{} of the updated Complex class: }
\PYG{n}{x} \PYG{o}{=}\PYG{n}{Complex}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{4.5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the real part is 3.0 and the imaginary part is 4.5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{real part=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{imaginary part=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
real part= 3.0
imaginary part= 4.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} get the modulus:}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5.408326913195984
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} get the argument:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{arg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.9827937232473289
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} get the complex conjugate, another instance of the Complex class:}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{cc}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.0
\PYGZhy{}4.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also define functions that act on two instantiations of the class. E.g. let’s say we want to be able to multiply two complex numbers together correctly.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} define the Complex class, with mod(), arg() and cc() functions to return:}
\PYG{c+c1}{\PYGZsh{} modulus, argument and complex conjugate}
\PYG{c+c1}{\PYGZsh{} see https://en.wikipedia.org/wiki/Complex\PYGZus{}number for details }
\PYG{k}{class} \PYG{n+nc}{Complex}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A more advanced complex number class\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{realpart}\PYG{p}{,} \PYG{n}{imagpart}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r} \PYG{o}{=} \PYG{n}{realpart}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i} \PYG{o}{=} \PYG{n}{imagpart}

    \PYG{c+c1}{\PYGZsh{} the modulus:}
    \PYG{k}{def} \PYG{n+nf}{mod}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} the argument }
    \PYG{k}{def} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{!=}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{arg} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{atan}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{/}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{+}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{arg} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}
        \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{arg} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{arg} 

    \PYG{c+c1}{\PYGZsh{} the complex conjugate, return a Complex object with \PYGZhy{} the imaginary part}
    \PYG{k}{def} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{Complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} multiply two complex numbers together:}
    \PYG{k}{def} \PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{Complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r} \PYG{o}{*} \PYG{n}{other}\PYG{o}{.}\PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i} \PYG{o}{*} \PYG{n}{other}\PYG{o}{.}\PYG{n}{i}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r} \PYG{o}{*} \PYG{n}{other}\PYG{o}{.}\PYG{n}{i} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i} \PYG{o}{*} \PYG{n}{other}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s try it out!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define two complex numbers:}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{Complex}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{4.5}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{Complex}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} multiply them to get another complex number}
\PYG{n}{h} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{h}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{h}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}6.0
10.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
(Check the answer!)

\sphinxAtStartPar
Or we can multiply x by its complex conjugate to get a real number:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} we can get the c.c. directly:}
\PYG{n}{u} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{cc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print the real part and the imaginary parts: the latter should be zero. }
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{i}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} the square root of the product x * x complex conjugate should the the modulus!}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
29.25
0.0
5.408326913195984
5.408326913195984
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Random\sphinxhyphen{}Walk Simulation}
\label{\detokenize{Chapters/Chapter3/Chapter3:random-walk-simulation}}
\sphinxAtStartPar
We can now proceed with a simulation of random walks. We will define a class called “walker”, which will allow us to define multiple walkers and make them walk around.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{math} 

\PYG{k}{class} \PYG{n+nc}{Walker}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A random walker class\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} instantiations of this class are initialized with an initial position}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{initialx}\PYG{p}{,} \PYG{n}{initialy}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} initialize the x and y positions:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{initialx}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{initialy}
        \PYG{c+c1}{\PYGZsh{} keep the initial positions:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{xinit} \PYG{o}{=} \PYG{n}{initialx}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{yinit} \PYG{o}{=} \PYG{n}{initialy}
        \PYG{c+c1}{\PYGZsh{} keep all the positions that the walker has moved through in a list:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{allx} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ally} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{allx}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{initialx}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ally}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{initialy}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} now let\PYGZsq{}s create a function that allows us to take random steps with a certain stepsize}
    \PYG{k}{def} \PYG{n+nf}{move}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{stepsize}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{deltax} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} choose random variables in the range [\PYGZhy{}1,1]}
        \PYG{n}{deltay} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} normalize to stepsize:}
        \PYG{n}{L} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{deltax}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{deltay}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{deltax} \PYG{o}{=} \PYG{n}{deltax}\PYG{o}{/}\PYG{n}{L}
        \PYG{n}{deltay} \PYG{o}{=} \PYG{n}{deltay}\PYG{o}{/}\PYG{n}{L}
        \PYG{c+c1}{\PYGZsh{} add these to the current position}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{deltax}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y} \PYG{o}{+} \PYG{n}{deltay}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{allx}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ally}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} get the distance from the starting position}
    \PYG{k}{def} \PYG{n+nf}{distance}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{xinit}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{yinit}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s test this out with a single walker starting from (0,0):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} initialize \PYGZdq{}Walker1\PYGZdq{}, an instance of the class Walker}
\PYG{n}{Walker1} \PYG{o}{=} \PYG{n}{Walker}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} move Walker1 1000 times with stepsize 1:}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Walker1}\PYG{o}{.}\PYG{n}{move}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the distance from the origin:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Walker1}\PYG{o}{.}\PYG{n}{distance}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
12.323614832708454
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Our next task is to initialize N (=9 to start with) walkers at the origin and follow their path visually! We are going to use matplotlib and evolve walkers “dynamically” on a graph.

\sphinxAtStartPar
It also will be interesting to investigate whether our theoretical expectations agree with this simulation.

\sphinxAtStartPar
Let’s also calculate, and store, the root\sphinxhyphen{}mean\sphinxhyphen{}square (rms) distance versus the of number of steps.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{time} \PYG{c+c1}{\PYGZsh{} various time functions}
\PYG{k+kn}{from} \PYG{n+nn}{tqdm} \PYG{k+kn}{import} \PYG{n}{tqdm} \PYG{c+c1}{\PYGZsh{} progress bar}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{ticker} \PYG{k}{as} \PYG{n+nn}{ticker} \PYG{c+c1}{\PYGZsh{} }

\PYG{c+c1}{\PYGZsh{} this allows us to access dynamic updating of the plot: }
\PYG{k+kn}{from} \PYG{n+nn}{IPython} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{clear\PYGZus{}output}

\PYG{c+c1}{\PYGZsh{} setup the axis:}
\PYG{n}{fig}\PYG{p}{,}\PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}get the dynamic display:}
\PYG{n}{dynamicdisplay} \PYG{o}{=} \PYG{n}{display}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{display\PYGZus{}id}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} put a grid on the graph:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{both}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the aspect ratio to 1:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set some parameters here:}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{9} \PYG{c+c1}{\PYGZsh{} the number of walkers}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{c+c1}{\PYGZsh{} the number of steps}
\PYG{n}{step} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} the step size}
\PYG{n}{Nupdate} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} the frequency of steps used to update the plot}

\PYG{c+c1}{\PYGZsh{} set the labels and limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{limitsize} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{*}\PYG{n}{step}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{limitsize}\PYG{p}{,}\PYG{n}{limitsize}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{limitsize}\PYG{p}{,}\PYG{n}{limitsize}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the major ticks to correspond to twice step size:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{step}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{step}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} initialize n walkers and put them in a list:}
\PYG{n}{WalkerList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{WalkerColor} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} create a list with the colors of each walker }
\PYG{n}{colors} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{magenta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cyan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brown}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{violet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} 9 colours}
\PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} counter to make sure we don\PYGZsq{}t go over the 9 colors}
\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n}{WalkerList}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Walker}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} set the color of each walker. If we w exceeds 8 then reset the counter j:}
    \PYG{k}{if} \PYG{n}{w}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{o}{*}\PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{8}\PYG{p}{:}
        \PYG{n}{j} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{else}\PYG{p}{:} 
        \PYG{k}{pass} 
    \PYG{n}{WalkerColor}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{colors}\PYG{p}{[}\PYG{n}{w}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{o}{*}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} now go through all the n walkers and get them to perform N steps}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{tqdm}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} go through all the walkers in the WalkerList}
    \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{n}{walker} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{WalkerList}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} move them one step in a random direction}
        \PYG{n}{walker}\PYG{o}{.}\PYG{n}{move}\PYG{p}{(}\PYG{n}{step}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{k}{Nupdate}==0: \PYGZsh{} only update every Nupdate steps
        \PYG{c+c1}{\PYGZsh{} plot them!}
        \PYG{c+c1}{\PYGZsh{} the list will contain the points so we can remove them later:}
        \PYG{n}{walkers\PYGZus{}plot} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{n}{walker} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{WalkerList}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{walkers\PYGZus{}plot}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{walker}\PYG{o}{.}\PYG{n}{allx}\PYG{p}{,} \PYG{n}{walker}\PYG{o}{.}\PYG{n}{ally}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{n}{WalkerColor}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{dynamicdisplay}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} update the figure in the notebook}
        \PYG{c+c1}{\PYGZsh{} remove the walkers from display for next run:}
        \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{n}{walker} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{WalkerList}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{wmarker} \PYG{o}{=} \PYG{n}{walkers\PYGZus{}plot}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{n}{wmarker}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} \PYGZdq{}sleep\PYGZdq{} for half a second to allow us to see the evolution}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8f502379c5d32637cd5f45e85d0d9d2e51ec236fe41a294561e3c6a09b4db7f9}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
100\PYGZpc{}|██████████| 100/100 [00:15\PYGZlt{}00:00,  6.33it/s]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{ec66c7a3376a824b4c7cd9bcc8fad763b86d6c21e249201fe8373349031d1316}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s plot the RMS distance versus the square root of N! First, let’s increase the number of walkers and the number of steps, without plotting:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{tqdm} \PYG{k+kn}{import} \PYG{n}{tqdm} \PYG{c+c1}{\PYGZsh{} progress bar}

\PYG{c+c1}{\PYGZsh{} set some parameters here:}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1000} \PYG{c+c1}{\PYGZsh{} the number of walkers}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10000} \PYG{c+c1}{\PYGZsh{} the number of steps}
\PYG{n}{step} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} the step size}
\PYG{n}{Nupdate} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} the frequency of steps used to update the plot}

\PYG{c+c1}{\PYGZsh{} initialize n walkers and put them in a list:}
\PYG{n}{WalkerList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n}{WalkerList}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Walker}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} list to store R squared average (i.e. the rms) *over all the walkers* after N steps:}
\PYG{n}{R\PYGZus{}rms\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} now go through all the n walkers and get them to perform N steps}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{tqdm}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Rsq\PYGZus{}av} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} variable used to calculate the square average}
    \PYG{c+c1}{\PYGZsh{} go through all the walkers in the WalkerList}
    \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{n}{walker} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{WalkerList}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} move them one step in a random direction}
        \PYG{n}{walker}\PYG{o}{.}\PYG{n}{move}\PYG{p}{(}\PYG{n}{step}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} add to the average:}
        \PYG{n}{Rsq\PYGZus{}av} \PYG{o}{=} \PYG{n}{Rsq\PYGZus{}av} \PYG{o}{+} \PYG{n}{walker}\PYG{o}{.}\PYG{n}{distance}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{c+c1}{\PYGZsh{} get the average and push it into the list:}
    \PYG{n}{R\PYGZus{}rms\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{Rsq\PYGZus{}av}\PYG{o}{/}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} divide by the number of walkers to get the average}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
100\PYGZpc{}|██████████| 10000/10000 [00:10\PYGZlt{}00:00, 960.48it/s]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} first, create a list for square root(N):}
\PYG{n}{sqrtN} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} the theoretical expectation is R\PYGZus{}rms = sqrt(N) * r\PYGZus{}rms (where r\PYGZus{}rms = step in this case):}
\PYG{n}{R\PYGZus{}rms\PYGZus{}theory} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{step} \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} setup the axis:}
\PYG{n}{fig}\PYG{p}{,}\PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sqrt}\PYG{l+s+si}{\PYGZob{}N\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{left\PYGZlt{}R\PYGZca{}2}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{right\PYGZgt{} = R\PYGZus{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}rms\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pseudo\PYGZhy{}experiment vs. Theory for }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ walkers}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} plot the pseudo\PYGZhy{}experiment result}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sqrtN}\PYG{p}{,} \PYG{n}{R\PYGZus{}rms\PYGZus{}list}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}R\PYGZus{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}rms\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{} from pseudo\PYGZhy{}experiment}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the theoretical expectation}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sqrtN}\PYG{p}{,} \PYG{n}{R\PYGZus{}rms\PYGZus{}theory}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}R\PYGZus{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}rms\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{} from theory}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{74c7a1d29997d812129aefae96f476c66ceb6bb09ac5c71d39ea527af9226a04}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
E.g. for \sphinxcode{\sphinxupquote{n = 1000}} walkers and \sphinxcode{\sphinxupquote{N = 10000}} steps, the agreement is excellent!

\sphinxstepscope


\chapter{Numerical Differentiation and Integration}
\label{\detokenize{Chapters/Chapter4/Chapter4:numerical-differentiation-and-integration}}\label{\detokenize{Chapters/Chapter4/Chapter4::doc}}

\section{Numerical Differentiation}
\label{\detokenize{Chapters/Chapter4/Chapter4:numerical-differentiation}}

\subsection{Introduction}
\label{\detokenize{Chapters/Chapter4/Chapter4:introduction}}
\sphinxAtStartPar
Suppose we have the trajectory of a projectile moving in the vertical direction as a function of time, \(y(t)\).

\sphinxAtStartPar
If we wish to determine its speed, we would need to take the derivative of the position with respect to time, i.e. \(v(t) = \mathrm{d}y/\mathrm{d}t\).

\sphinxAtStartPar
e.g. suppose the trajectory, \sphinxstyleemphasis{measured experimentally}, looks like the following plot:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array for time}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.9}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the function}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. }

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}t\PYGZdl{} [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y(t)\PYGZdl{} [m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The trajectory of a particle moving vertically}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y limit}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array for time}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}matplotlib\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Assuming we don’t know the analytic form of the function that generated the above, we would like to calculate the speed \(v(t)\) numerically.

\sphinxAtStartPar
The starting point is the mathematical definition of the derivative:

\sphinxAtStartPar
\( \frac{ \mathrm{d} y(t) } {\mathrm{d} t } \equiv \lim_{h\rightarrow 0} \frac{ y(t+h) - y(t) } { h} \).

\sphinxAtStartPar
Note that a computer would run into errors with this kind of limit:
\begin{itemize}
\item {} 
\sphinxAtStartPar
as \(h\) is made smaller, the numerator would fluctuate between 0 and machine precision, \(\epsilon_m\).

\item {} 
\sphinxAtStartPar
as the denominator, \(h\), approaches zero, overflow would occur.

\end{itemize}


\subsection{The Forward\sphinxhyphen{}Difference Derivative}
\label{\detokenize{Chapters/Chapter4/Chapter4:the-forward-difference-derivative}}
\sphinxAtStartPar
The simplest algorithm for numerical differentiation is called the forward\sphinxhyphen{}difference derivative, and it is obtained by simply removing the limit, still taking \(h\) reasonably small, i.e.:

\sphinxAtStartPar
\( \left.\frac{ \mathrm{d} y(t) } {\mathrm{d} t } \right|_\mathrm{fd} \equiv \frac{ y(t+h) - y(t) } { h} \).

\sphinxAtStartPar
What is the algorithmic (or approximation) error induced by this procedure?

\sphinxAtStartPar
To find out, let’s look at the Taylor series of \(y(t)\) a small step \(h\) away from \(y(t)\):

\sphinxAtStartPar
\(y(t+h) = y(t) + h \frac{\mathrm{d} y(t) } {\mathrm{d} t } + \frac{h^2}{2!} \frac{\mathrm{d}^2 y(t) } {\mathrm{d} t^2 } + \frac{h^3}{3!} \frac{\mathrm{d}^3 y(t) } {\mathrm{d} t^3 } + ...\).

\sphinxAtStartPar
Solving for \(\frac{ y(t+h) - y(t) } { h }\), which is nothing but the forward\sphinxhyphen{}difference derivative:

\sphinxAtStartPar
\(\left.\frac{ \mathrm{d} y(t) } {\mathrm{d} t } \right|_\mathrm{fd} =  \frac{ y(t+h) - y(t) } { h } =   \frac{ \mathrm{d} y(t) } {\mathrm{d} t } - \frac{h}{2} \frac{\mathrm{d}^2 y(t) } {\mathrm{d} t^2 } + ...\)

\sphinxAtStartPar
Therefore, the algorithmic error for the forward\sphinxhyphen{}difference derivative can be written as:

\sphinxAtStartPar
\(\epsilon^\mathrm{fd}_\mathrm{alg} \simeq \frac{h y''}{2}\), where \(y''\) is short\sphinxhyphen{}hand for the second derivative.

\sphinxAtStartPar
You can think of the approximation as using two points to represent the function by a straight line in the interval \(t\) to \(t+h\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} creates a NumPy array for time}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.9}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} take the NumPy array and create another one}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. }
\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}t\PYGZdl{} [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y(t)\PYGZdl{} [m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The forward\PYGZhy{}difference derivative}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y limit}

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} plot a segment of the line and the corresponding t values:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ymin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}t+h\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{cee22aca46e4bf095023ea5790a79553d0f0059de15aa4be60fcf42389040730}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Example 4.1: Calculate the forward\sphinxhyphen{}difference derivative for the above data points and plot it (in a NumPy array called \sphinxstyleliteralintitle{\sphinxupquote{y}})}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-1-calculate-the-forward-difference-derivative-for-the-above-data-points-and-plot-it-in-a-numpy-array-called-y}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The forward difference for the points \PYGZdq{}measured\PYGZdq{} in our pseudo\PYGZhy{}experiment:}

\PYG{c+c1}{\PYGZsh{} the forward difference: }
\PYG{n}{dydt\PYGZus{}FD} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. }

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}t\PYGZdl{} [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{left. }\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{frac}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{ y(t)\PYGZcb{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{t\PYGZcb{} }\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{right|\PYGZus{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}fd\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{} [m/s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The forward\PYGZhy{}difference derivative}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y limit}

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dydt\PYGZus{}FD}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{fd0043ab139a43fa9466c8391ac61fbbb84340873081a7e23c058567e83a62a4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Example 4.2: Calculate the forward\sphinxhyphen{}difference derivatives for f(t) = \textbackslash{}cos t and g(t) = \textbackslash{}exp(t) at t=0.1, 1., 100, for h=10\textasciicircum{}\{\sphinxhyphen{}6\}. Compare to the analytic results.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-2-calculate-the-forward-difference-derivatives-for-f-t-cos-t-and-g-t-exp-t-at-t-0-1-1-100-for-h-10-6-compare-to-the-analytic-results}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} define a function for the forward\PYGZhy{}difference derivative.}
\PYG{c+c1}{\PYGZsh{} In Python, you can pass a function as an argument to another function. This is known as a higher\PYGZhy{}order function.}
\PYG{k}{def} \PYG{n+nf}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculates the forward\PYGZhy{}difference derivative of a function func at t, with step size h\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{func}\PYG{p}{(}\PYG{n}{t}\PYG{o}{+}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{func}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}

\PYG{c+c1}{\PYGZsh{} calculate the derivatives at various points in an array t:}
\PYG{n}{tarray} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{100.}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} the step h is taken to be 1E\PYGZhy{}6:}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1E\PYGZhy{}6}

\PYG{c+c1}{\PYGZsh{} for the cos function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(cos(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} for the exp function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(exp(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
d(cos(t))/dt at t= 0.1 = \PYGZhy{}0.09983391413559417 vs analytic= \PYGZhy{}0.09983341664682815 with error= 4.974887660158522e\PYGZhy{}07
d(cos(t))/dt at t= 1.0 = \PYGZhy{}0.8414712548976411 vs analytic= \PYGZhy{}0.8414709848078965 with error= 2.7008974456954604e\PYGZhy{}07
d(cos(t))/dt at t= 100.0 = 0.5063652086523263 vs analytic= 0.5063656411097588 with error= 4.324574325309527e\PYGZhy{}07
d(exp(t))/dt at t= 0.1 = 1.105171470561217 vs analytic= 1.1051709180756477 with error= 5.524855692939923e\PYGZhy{}07
d(exp(t))/dt at t= 1.0 = 2.7182831874306146 vs analytic= 2.718281828459045 with error= 1.3589715694983795e\PYGZhy{}06
d(exp(t))/dt at t= 100.0 = 2.6881184788443713e+43 vs analytic= 2.6881171418161356e+43 with error= 1.3370282356702364e+37
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We will discuss errors in a bit! First let’s consider more algorithms for differentiation!


\subsection{The Central\sphinxhyphen{}Difference Derivative}
\label{\detokenize{Chapters/Chapter4/Chapter4:the-central-difference-derivative}}
\sphinxAtStartPar
Rather than making a single step \(h\) forward, we can make half a step forward and half a step backward to get the central\sphinxhyphen{}difference derivative:

\sphinxAtStartPar
\( \left.\frac{ \mathrm{d} y(t) } {\mathrm{d} t } \right|_\mathrm{cd} \equiv \frac{ y(t+h/2) - y(t-h/2) } { h} \).

\sphinxAtStartPar
To get an estimate of the algorithmic error, we first write down the Taylor series for \(y(t+h/2)\) and \(y(t-h/2)\):

\sphinxAtStartPar
\(y(t+h/2) = y(t) + \frac{h}{2} y'(t) + \frac{h^2}{8} y''(t) + \frac{h^3}{48} y'''(t) + \mathcal{O}(h^4)\)

\sphinxAtStartPar
\(y(t-h/2) = y(t) - \frac{h}{2} y'(t) + \frac{h^2}{8} y''(t) - \frac{h^3}{48} y'''(t) + \mathcal{O}(h^4)\)

\sphinxAtStartPar
and we subtract them to get:

\sphinxAtStartPar
\(y(t+h/2) - y(t-h/2) = h y'(t) + \frac{h^3}{24} y'''(t)+ \mathcal{O}(h^5)\)

\sphinxAtStartPar
All terms with an even power of \(h\) vanish!

\sphinxAtStartPar
so:

\sphinxAtStartPar
\( \left.\frac{ \mathrm{d} y(t) } {\mathrm{d} t } \right|_\mathrm{cd} = y'(t) + \frac{1}{24} h^2 y'''(t) + \mathcal{O}(h^5)\).

\sphinxAtStartPar
The central\sphinxhyphen{}difference algorithm is accurate to order \(h^2\) instead of \(h\).

\sphinxAtStartPar
Therefore, if the function is smooth, then one would expect \(y''' h^2 / 24 \ll y'' h / 2\), and we would expect the central\sphinxhyphen{}difference error to be much smaller than that with the forward\sphinxhyphen{}difference.

\sphinxAtStartPar
Let’s compare the results of Example 4.2, calculated with the forward\sphinxhyphen{}difference algorithm, now with the central\sphinxhyphen{}difference algorithm:


\subsubsection{Example 4.3: Calculate as in Example 4.2, but with the central\sphinxhyphen{}difference derivative}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-3-calculate-as-in-example-4-2-but-with-the-central-difference-derivative}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} define a function for the central\PYGZhy{}difference derivative.}
\PYG{k}{def} \PYG{n+nf}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculates the central\PYGZhy{}difference derivative of a function func at t, with step size h\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{func}\PYG{p}{(}\PYG{n}{t}\PYG{o}{+}\PYG{n}{h}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{func}\PYG{p}{(}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}

\PYG{c+c1}{\PYGZsh{} calculate the derivatives at various points in an array t:}
\PYG{n}{tarray} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{100.}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} the step h is taken to be 1E\PYGZhy{}8:}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1E\PYGZhy{}6}

\PYG{c+c1}{\PYGZsh{} for the cos function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(cos(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} for the exp function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(exp(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
d(cos(t))/dt at t= 0.1 = \PYGZhy{}0.09983341664465684 vs analytic= \PYGZhy{}0.09983341664682815 with error= 2.17131868041065e\PYGZhy{}12
d(cos(t))/dt at t= 1.0 = \PYGZhy{}0.8414709847803792 vs analytic= \PYGZhy{}0.8414709848078965 with error= 2.7517321754544355e\PYGZhy{}11
d(cos(t))/dt at t= 100.0 = 0.506365639862949 vs analytic= 0.5063656411097588 with error= 1.246809766541901e\PYGZhy{}09
d(exp(t))/dt at t= 0.1 = 1.10517091811424 vs analytic= 1.1051709180756477 with error= 3.859224051439014e\PYGZhy{}11
d(exp(t))/dt at t= 1.0 = 2.7182818285176324 vs analytic= 2.718281828459045 with error= 5.858735718788921e\PYGZhy{}11
d(exp(t))/dt at t= 100.0 = 2.6881171349366646e+43 vs analytic= 2.6881171418161356e+43 with error= 6.879470977972417e+34
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
For the specific choice of \(h\), the central\sphinxhyphen{}difference algorithm is clearly better! (But see below for an analysis of errors in each).


\subsection{Extrapolated\sphinxhyphen{}Difference Derivative}
\label{\detokenize{Chapters/Chapter4/Chapter4:extrapolated-difference-derivative}}
\sphinxAtStartPar
We can extend the central\sphinxhyphen{}difference approximation to use quarter steps instead of half steps, i.e., calculate:

\sphinxAtStartPar
\( \left.\frac{ \mathrm{d} y(t,h/2) } {\mathrm{d} t } \right|_\mathrm{cd} \equiv \frac{ y(t+h/4) - y(t-h/4) } { h/2 } \).

\sphinxAtStartPar
As before, expanding via Taylor series \(y(t+h/4)\) and \(y(t-h/4)\) yields an estimate of the approximation error:

\sphinxAtStartPar
\( \left.\frac{ \mathrm{d} y(t,h/2) } {\mathrm{d} t } \right|_\mathrm{cd} \simeq y'(t) + \frac{h^2}{96} y'''(t) + \mathcal{O}(h^4)\)

\sphinxAtStartPar
If we define \(D_\mathrm{cd} y(t,h) \equiv \left.\frac{ \mathrm{d} y(t,h) } {\mathrm{d} t } \right|_\mathrm{cd}\), we can combine two central\sphinxhyphen{}difference approximations to get the \sphinxstyleemphasis{extended\sphinxhyphen{}difference algorithm} as follows:

\sphinxAtStartPar
\(\left.\frac{ \mathrm{d} y(t) } {\mathrm{d} t } \right|_\mathrm{ed} \equiv \frac{ 4 D_\mathrm{cd} y(t, h/2) - D_\mathrm{cd} y (t,h) }{3}\).

\sphinxAtStartPar
And it can be shown (again via Taylor series expansions) that this algorithm has an error of \(\mathcal{O}(h^4)\):

\sphinxAtStartPar
\(\left.\frac{ \mathrm{d} y(t) } {\mathrm{d} t } \right|_\mathrm{ed} \simeq y'(t) - \frac{h^4}{4 \cdot 16 \cdot 120}y^{(5)}(t) + ... \).

\sphinxAtStartPar
Finally, when working with the aproximations, it is important to remember that they may work for well\sphinxhyphen{}behaved functions, they may fail badly for functions containing noise, which will most likely be the case if they are coming from measurements or other computations. In that case, it may be necessary to “smooth” the data or fit them with some analytic function (see later chapter) and then differentiate.


\section{Error Assessment in Numerical Differentiation}
\label{\detokenize{Chapters/Chapter4/Chapter4:error-assessment-in-numerical-differentiation}}

\subsection{Introduction}
\label{\detokenize{Chapters/Chapter4/Chapter4:id1}}
\sphinxAtStartPar
Numerical algorithms play a vital role in computational physics. When you encounter/invent and implement an algorithm, you must assess the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Does it converge?

\item {} 
\sphinxAtStartPar
How precise are the converged results?

\item {} 
\sphinxAtStartPar
How fast does it run?

\end{enumerate}

\sphinxAtStartPar
You may think that all algorithms converge if enough terms are used, and that if you want more precision you just use more terms!

\sphinxAtStartPar
But this is not always possible: some algorithms are asymptotic expansions that approximate a function in certain regions of parameter space, and converge only up to a point.

\sphinxAtStartPar
However, even if the series that underlies an algorithm is uniformly convergent, including more terms will decrease the algorithmic error, but will also \sphinxstyleemphasis{increase} the round\sphinxhyphen{}off errors that we previously discussed. And because round\sphinxhyphen{}off errors eventually diverge to infinity, we need to find the “sweet\sphinxhyphen{}spot” for the approximations.

\sphinxAtStartPar
Good algorithms require fewer steps and thus incur less round\sphinxhyphen{}off error!

\sphinxAtStartPar
The algorithmic (or approximation) errors, \(\epsilon_\mathrm{alg}\) in numerical differentiation decrease with decreasing step size, \(h\). In turn, round\sphinxhyphen{}off errors, \(\epsilon_\mathrm{ro}\), increase with decreasing step size.

\sphinxAtStartPar
The best value of \(h\) has to minimize the total error:

\sphinxAtStartPar
\(\epsilon_\mathrm{tot} = \epsilon_\mathrm{alg} + \epsilon_\mathrm{ro}\).

\sphinxAtStartPar
This “sweet spot” occurs when both errors are of the same order, i.e.:

\sphinxAtStartPar
\(\epsilon_\mathrm{alg} \simeq \epsilon_\mathrm{ro}\).

\sphinxAtStartPar
In the case of numerical differentiation, e.g. via the forward\sphinxhyphen{}difference algorithm, \(\left. \frac{ \mathrm{d} y(t) } {\mathrm{d} t }\right|_\mathrm{fd} =  \frac{ y(t+h) - y(t) } { h} \), as \(h\) is made continually smaller, we will eventually reach the worst\sphinxhyphen{}case round\sphinxhyphen{}off error where \(y(t+h)\) and \(y(t)\) differ by the machine precision \(\epsilon_m\). In that worst\sphinxhyphen{}case scenarion, the round\sphinxhyphen{}off error is:

\sphinxAtStartPar
\(\epsilon_\mathrm{ro} \simeq \frac{\epsilon_m}{h}\).

\sphinxAtStartPar
Therefore, for the forward\sphinxhyphen{}difference algorithm, the sweet\sphinxhyphen{}spot \(h\) occurs when:

\sphinxAtStartPar
\(\frac{\epsilon_m}{h} \simeq \epsilon_\mathrm{alg}^\mathrm{fd} = \frac{h y''}{2}\) or \(h_\mathrm{fd} = \sqrt{ \frac{2 \epsilon_m}{y''}}\).

\sphinxAtStartPar
For the central\sphinxhyphen{}difference algorithm:

\sphinxAtStartPar
\(\frac{\epsilon_m}{h} \simeq \epsilon_\mathrm{alg}^\mathrm{cd} = \frac{h^2 y'''}{24}\) or \(h_\mathrm{cd} = \sqrt[3]{ \frac{24 \epsilon_m}{y'''}}\).

\sphinxAtStartPar
Let’s assume that we have a function for which \(y' \simeq y'' \simeq y'''\) at the point of interest \(t\), which may be crude in general, but works reasonably for \(\cos t\) and \(\exp(t)\). For double precision floats, \(\epsilon_m \simeq 10^{-15}\), and then:

\sphinxAtStartPar
\(h_\mathrm{fd} \simeq 4 \times 10^{-8}\) which leads to \(\epsilon_\mathrm{fd} \simeq \frac{\epsilon_m}{h_\mathrm{fd}} \simeq 3\times 10^{-8}\),

\sphinxAtStartPar
and:

\sphinxAtStartPar
\(h_\mathrm{cd} \simeq 3 \times 10^{-5}\) which leads to \(\epsilon_\mathrm{cd} \simeq \frac{\epsilon_m}{h_\mathrm{cd}}\simeq 3\times 10^{-11}\),

\sphinxAtStartPar
One can observe that in this case, the central\sphinxhyphen{}difference algorithm achieves smaller error for a larger \(h\) value! Let’s now re\sphinxhyphen{}calculate the values of the derivatives of \(\cos t\) and \(\exp(t)\) using the “sweet\sphinxhyphen{}spot” step sizes in the next example.


\subsubsection{Example 4.4: Use the sweet\sphinxhyphen{}spot values of the step size to calculate the derivatives of \textbackslash{}cos (t) and \textbackslash{}exp(t) at the same points as the previous examples.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-4-use-the-sweet-spot-values-of-the-step-size-to-calculate-the-derivatives-of-cos-t-and-exp-t-at-the-same-points-as-the-previous-examples}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} We can use the functions already defined in this notebook for the forward difference and central difference. }

\PYG{c+c1}{\PYGZsh{} Forward difference: }
\PYG{c+c1}{\PYGZsh{} the step h is taken to be 4E\PYGZhy{}8:}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{4E\PYGZhy{}8}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Forward difference:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} for the cos function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(cos(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} for the exp function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(exp(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Central difference: }
\PYG{c+c1}{\PYGZsh{} the step h is taken to be 3E\PYGZhy{}5:}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{3E\PYGZhy{}5}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Central difference:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} for the cos function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(cos(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} for the exp function:}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tarray}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d(exp(t))/dt at t=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vs analytic=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Forward difference:
d(cos(t))/dt at t= 0.1 = \PYGZhy{}0.09983343596253746 vs analytic= \PYGZhy{}0.09983341664682815 with error= 1.9315709309797313e\PYGZhy{}08
d(cos(t))/dt at t= 1.0 = \PYGZhy{}0.8414709956605648 vs analytic= \PYGZhy{}0.8414709848078965 with error= 1.085266831957199e\PYGZhy{}08
d(cos(t))/dt at t= 100.0 = 0.5063656660642124 vs analytic= 0.5063656411097588 with error= 2.4954453614611793e\PYGZhy{}08
d(exp(t))/dt at t= 0.1 = 1.1051709380982544 vs analytic= 1.1051709180756477 with error= 2.0022606683767208e\PYGZhy{}08
d(exp(t))/dt at t= 1.0 = 2.7182818884696758 vs analytic= 2.718281828459045 with error= 6.001063068694634e\PYGZhy{}08
d(exp(t))/dt at t= 100.0 = 2.6881174087690013e+43 vs analytic= 2.6881171418161356e+43 with error= 2.669528657119537e+36

Central difference:
d(cos(t))/dt at t= 0.1 = \PYGZhy{}0.09983341664465684 vs analytic= \PYGZhy{}0.09983341664682815 with error= 2.17131868041065e\PYGZhy{}12
d(cos(t))/dt at t= 1.0 = \PYGZhy{}0.8414709847803792 vs analytic= \PYGZhy{}0.8414709848078965 with error= 2.7517321754544355e\PYGZhy{}11
d(cos(t))/dt at t= 100.0 = 0.5063656412507278 vs analytic= 0.5063656411097588 with error= 1.4096901423954478e\PYGZhy{}10
d(exp(t))/dt at t= 0.1 = 1.10517091811424 vs analytic= 1.1051709180756477 with error= 3.859224051439014e\PYGZhy{}11
d(exp(t))/dt at t= 1.0 = 2.718281828576844 vs analytic= 2.718281828459045 with error= 1.177991038048276e\PYGZhy{}10
d(exp(t))/dt at t= 100.0 = 2.6881171427769514e+43 vs analytic= 2.6881171418161356e+43 with error= 9.608157724429865e+33
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
These are of the same order as we expected from our considerations!

\sphinxAtStartPar
Let’s now dig deeper into the errors to get a visual representation of what’s happening.


\subsubsection{Example 4.5: Using the known analytical results calculate the \sphinxstyleemphasis{relative error}, \textbackslash{}varepsilon, obtained by both methods for the \textbackslash{}cos(t) and \textbackslash{}exp(t) functions at t=0.1, for varying step size h down to h\textbackslash{}simeq \textbackslash{}epsilon\_m \textbackslash{}simeq 10\textasciicircum{}\{\sphinxhyphen{}15\} and plot \textbackslash{}log\_\{10\}|\textbackslash{}varepsilon| vs. \textbackslash{}log\_\{10\} h. Comment on the behavior at small and large h}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-5-using-the-known-analytical-results-calculate-the-relative-error-varepsilon-obtained-by-both-methods-for-the-cos-t-and-exp-t-functions-at-t-0-1-for-varying-step-size-h-down-to-h-simeq-epsilon-m-simeq-10-15-and-plot-log-10-varepsilon-vs-log-10-h-comment-on-the-behavior-at-small-and-large-h}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{c+c1}{\PYGZsh{} First, let\PYGZsq{}s create the array of h:}
\PYG{n}{harray} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{n}{num}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{base}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the NumPy logspace returns numbers spaced evenly on a log scale.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Then let\PYGZsq{}s calculate the relative error and take the log (base 10) for each of the two algorithms:}

\PYG{c+c1}{\PYGZsh{} fix the point we are examining: }
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mf}{0.1}

\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s use list comprehension!}
\PYG{c+c1}{\PYGZsh{} cosine: }
\PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}cos\PYGZus{}FD} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(} \PYG{n+nb}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)} \PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n}{harray}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Forward\PYGZhy{}difference }
\PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}cos\PYGZus{}CD} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(} \PYG{n+nb}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)} \PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n}{harray}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Centra\PYGZhy{}Difference}

\PYG{c+c1}{\PYGZsh{} exp: }
\PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}exp\PYGZus{}FD} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(} \PYG{n+nb}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{n}{dfdt\PYGZus{}FD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)} \PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n}{harray}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Forward\PYGZhy{}difference }
\PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}exp\PYGZus{}CD} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(} \PYG{n+nb}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{n}{dfdt\PYGZus{}CD}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)} \PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n}{harray}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Centra\PYGZhy{}Difference}


\PYG{c+c1}{\PYGZsh{} get the log10 of h:}
\PYG{n}{log10\PYGZus{}h} \PYG{o}{=} \PYG{p}{[}\PYG{n}{math}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)} \PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n}{harray}\PYG{p}{]}
    
\PYG{c+c1}{\PYGZsh{} Now plot! Don\PYGZsq{}t forget the different labels! }
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{log\PYGZus{}}\PYG{l+s+si}{\PYGZob{}10\PYGZcb{}}\PYG{l+s+s1}{(h)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{log\PYGZus{}}\PYG{l+s+si}{\PYGZob{}10\PYGZcb{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{varepsilon)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error assessment in numerical derivatives}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the arrays relevant to the cosine:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{log10\PYGZus{}h}\PYG{p}{,} \PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}cos\PYGZus{}FD}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{cos(t)\PYGZdl{}, FD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{log10\PYGZus{}h}\PYG{p}{,} \PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}cos\PYGZus{}CD}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{cos(t)\PYGZdl{}, CD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the arrays relevant to the exponential:}
\PYG{c+c1}{\PYGZsh{} change the linestyle!}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{log10\PYGZus{}h}\PYG{p}{,} \PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}exp\PYGZus{}FD}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{exp(t)\PYGZdl{}, FD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{log10\PYGZus{}h}\PYG{p}{,} \PYG{n}{log10\PYGZus{}rel\PYGZus{}error\PYGZus{}exp\PYGZus{}CD}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{exp(t)\PYGZdl{}, CD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} ivnert the axes to show smaller values of h to the right:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{invert\PYGZus{}xaxis}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{3bcd6a157db8da24d2a9d08f0c1f1077d3fda136ce7333309b1ed608fdd541f8}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now let’s do the same exercise in class, with \(f(t) = \exp(t) \cos(t)\)!


\subsubsection{Example 4.6: Take the numerical derivative of the function f(t) = \textbackslash{}exp(t) \textbackslash{}cos(t) at t=0.1, and following Example 4.5, perform an error assessment.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-6-take-the-numerical-derivative-of-the-function-f-t-exp-t-cos-t-at-t-0-1-and-following-example-4-5-perform-an-error-assessment}}
\sphinxAtStartPar
(Solution in a separate notebook, Example4.6)


\section{Numerical Integration}
\label{\detokenize{Chapters/Chapter4/Chapter4:numerical-integration}}

\subsection{Introduction}
\label{\detokenize{Chapters/Chapter4/Chapter4:id2}}
\sphinxAtStartPar
A traditional way to perform integration by hand is to take a piece of graph paper and count the number of boxes, or \sphinxstyleemphasis{quadrilaterals} lying below the curve.

\sphinxAtStartPar
This is why numerical integration is also known as numerical \sphinxstyleemphasis{quadrature}, even when the method employed is much more sophisticated than simple box counting.

\sphinxAtStartPar
We start of our discussion of numerical integration with the Riemann definition of an integral, as the limit of the sum over boxes under a curve, as the box width \(h\) approaches zero:

\sphinxAtStartPar
\(\int_a^b f(x) \mathrm{d} x = \lim_{h\rightarrow 0} \left[ h \sum_{i=1}^{(b-a)/h} f(x_i) \right]\),

\sphinxAtStartPar
where \((b-a)/h = N\) counts the number of boxes.

\sphinxAtStartPar
The figure below is a graphical representation of the quadrature procedure:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{ticker} \PYG{k}{as} \PYG{n+nn}{ticker} \PYG{c+c1}{\PYGZsh{} }

\PYG{c+c1}{\PYGZsh{} define the x array and calculate over it the function to display }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.2}\PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. }

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}f(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The area under the curve \PYGZdl{}f(x)\PYGZdl{} from \PYGZdl{}a\PYGZdl{} to \PYGZdl{}b\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} put the ticks closer together:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mf}{0.02}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mf}{0.008}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the axis limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.520}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} fill the area under the curve:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,}\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} put a grid on the graph:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{both}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} hide x and y axes label marks}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{labelbottom}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{labelleft}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} put text at the right points on the x\PYGZhy{}axis:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.035}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.98}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.035}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}b\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} put the integral in the shaded region:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{int\PYGZus{}a\PYGZca{}b f(x) }\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{ x \PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{f9b319ea945ae585fcbc65693b5720de2854f1742574518cdd044b6dbeba451e}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The numerical integral of a function \(f(x)\) is approximated as a finite sum over boxes of height \(f(x_i)\) and width \(w_i\):

\sphinxAtStartPar
\(\int_a^b f(x) \mathrm{d} x \simeq \sum_{i=1}^N f(x_i) w_i\).

\sphinxAtStartPar
In this case the box width is finite. The above formula represents the standard form for all integration algorithms: the function \(f(x)\) is evaluated at \(N\) points in the interval \([a,b]\), and the function values \(f_i \equiv f(x_i)\) are summed with each term in the sum weighted by \(w_i\).

\sphinxAtStartPar
Generally, the precision increases as the number of points \(N\) gets larger, with the round\sphinxhyphen{}off error eventually limiting the increase. This is similar to what we observed in the case of differentiation.

\sphinxAtStartPar
A word of warning: in general, you should not attempt a numerical integration of an integrand that contains a singularity, without first removing the singularity by hand. You may be able to do this very simply by breaking the intervals down into several subintervals so that the singularity is at an endpoint where an integration point is not placed, or by change of variable.

\sphinxAtStartPar
Also, if the integrand has a very slow variation in some region, you can speed up the integration by changing to a variable that compresses that region and places fewer points there, or divides up the integral and performs several integrations.
|
Conversely, if your integrand has a very rapid variation in some region, you may want to change to variables that expand that region, to ensure that no oscillations (e.g.) are missed.


\subsection{The Trapezoid Rule}
\label{\detokenize{Chapters/Chapter4/Chapter4:the-trapezoid-rule}}
\sphinxAtStartPar
The trapezoid (British: trapezium) rule uses \sphinxstyleemphasis{evenly\sphinxhyphen{}spaced values} of \(x\), i.e. \(N\) points \(x_i\) (\(i=1,...N\)), spaced at a distance \(h\) apart throughout the integration region \([a,b]\) and includes the endpoints of the integration region.

\sphinxAtStartPar
This means that there are \((N-1)\) intervals of length \(h\):

\sphinxAtStartPar
\(h = \frac{b-a}{N-1}\), \(x_i = a + (i-1) h\), \(i=1,...,N\),

\sphinxAtStartPar
where we note that counting starts at \(i=1\) in the above formulae.

\sphinxAtStartPar
The trapezoid rule takes each integration interval \(i\) and constructs a trapezoid of width \(h\) in it. This approximates \(f(x)\) by a straight line in each interval \(i\) and uses the average height of the function at the edges of the straight line as the value for \(f\), i.e. \((f_i + f_{i+1})/2\).

\sphinxAtStartPar
The area of each such trapzoid is then:

\sphinxAtStartPar
\(\int_{x_i}^{x_i + h} f(x) \mathrm{d}x \simeq h \frac{ (f_i + f_{i+1}) } {2}  = \frac{1}{2} h f_i + \frac{1}{2}  hf_{i+1}\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{ticker} \PYG{k}{as} \PYG{n+nn}{ticker} \PYG{c+c1}{\PYGZsh{} }

\PYG{c+c1}{\PYGZsh{} define the x array and calculate over it the function to display }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.2}\PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. }

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}f(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The Trapezoid Rule}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} put the ticks closer together:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the axis limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.520}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} draw vertical lines to denote the limits of the trapezoids:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} show the trapezoid edges: }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{]}\PYG{p}{,}\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} label the trapezoids:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.02}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trap. 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.22}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trap. 2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.42}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trap. 3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.62}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trap. 4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.82}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trap. 5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} fill the area under the curve:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,}\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} hide x and y axes label marks}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{labelbottom}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{labelleft}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} put text at the right points on the x\PYGZhy{}axis:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.035}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.98}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.035}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}b\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{52b4d1401cfc858f04084e6073abe57a602881330c03576e656ebcc88855b87e}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In order to apply the trapezoid rule to the entire region \([a,b]\), we add the contributions from each subinterval:

\sphinxAtStartPar
\(\int_a^b f(x) \mathrm{d} x \simeq \frac{h}{2} f_1 + h f_2 + h f_3 + ... + h f_{N-1} + \frac{h}{2} f_N\).

\sphinxAtStartPar
Note that the “internal” points are counted twice: the end of one interval is the beginning of the next.

\sphinxAtStartPar
The trapezoid rule can be written in terms of the “weight” formula as follows:

\sphinxAtStartPar
\(\int_a^b f(x) \mathrm{d} x \simeq \sum_{i=1}^N f(x_i) w_i\), \(w_i = \left\{ \frac{h}{2}, h, ..., h, \frac{h}{2} \right\}\).

\sphinxAtStartPar
Let’s write a function that implements the trapezoid rule!


\subsubsection{Example 4.7: Construct a function that implements the trapezoid rule on an interval {[}a,b{]} using N points, and use to integrate f(x) = \textbackslash{}exp(\sphinxhyphen{}x) in the interval {[}0,1{]}. Compare to the analytic value for N=10\textasciicircum{}6 intervals.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-7-construct-a-function-that-implements-the-trapezoid-rule-on-an-interval-a-b-using-n-points-and-use-to-integrate-f-x-exp-x-in-the-interval-0-1-compare-to-the-analytic-value-for-n-10-6-intervals}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s write a higher\PYGZhy{}order function that implements the trapezoid rule:}
\PYG{k}{def} \PYG{n+nf}{trapezoid}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculates the numerical integral of a function in the interval a,b using the trapezoid rule for N points\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} calculate the width:}
    \PYG{n}{h} \PYG{o}{=} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} apply the trapezoid rule: }
    \PYG{c+c1}{\PYGZsh{} the contributions from the first and last points: }
    \PYG{n}{integral} \PYG{o}{=} \PYG{n}{h}\PYG{o}{*}\PYG{p}{(}\PYG{n}{func}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{+} \PYG{n}{func}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2} 
    \PYG{c+c1}{\PYGZsh{} the contributions from the remaining points: }
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{integral} \PYG{o}{=} \PYG{n}{integral} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n}{func}\PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{i} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{integral}


\PYG{c+c1}{\PYGZsh{} test the function for exp(\PYGZhy{}t) in [0,1]:}
\PYG{c+c1}{\PYGZsh{} first define the function we wish to integrate: }
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mf}{1E6} \PYG{c+c1}{\PYGZsh{} the number of points}
\PYG{n}{trap\PYGZus{}int} \PYG{o}{=} \PYG{n}{trapezoid}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Integral of exp(\PYGZhy{}t) in [0,1] via the trapezoid rule=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{trap\PYGZus{}int}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the analytic integral is simply 1 \PYGZhy{} exp(\PYGZhy{}1):}
\PYG{n}{analytic\PYGZus{}int} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Analytic integral=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{analytic\PYGZus{}int}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compare by calculating the fractional error:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fractional error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{n}{trap\PYGZus{}int}\PYG{o}{\PYGZhy{}}\PYG{n}{analytic\PYGZus{}int}\PYG{p}{)}\PYG{o}{/}\PYG{n}{analytic\PYGZus{}int} \PYG{p}{)} \PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Integral of exp(\PYGZhy{}t) in [0,1] via the trapezoid rule= 0.632120558828617
Analytic integral= 0.6321205588285577
Fractional error= 9.378892789826624e\PYGZhy{}14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Simpson’s Rule}
\label{\detokenize{Chapters/Chapter4/Chapter4:simpson-s-rule}}
\sphinxAtStartPar
Simpson’s rule approximates the integrand, \(f(x)\), by a parabola for each interval:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{ticker} \PYG{k}{as} \PYG{n+nn}{ticker} \PYG{c+c1}{\PYGZsh{} }

\PYG{c+c1}{\PYGZsh{} define a function to plot the Simpson rule parabolas:}
\PYG{k}{def} \PYG{n+nf}{SimpsonParabola}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{xinterval}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{xx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{xinterval}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xinterval}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} calculate the coefficients of the quadratic:}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{xinterval}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{xinterval}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{fa} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
    \PYG{n}{fb} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{fm} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{p}{)}
    \PYG{n}{alpha} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{fa} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{fb} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{fm}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{beta} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{*}\PYG{n}{fa} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{fb} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{fm} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{fa} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{fb} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{fm}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{gamma} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{fb} \PYG{o}{+} \PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{fa} \PYG{o}{+} \PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{fb} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{fm} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{fa}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{alpha} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beta} \PYG{o}{*} \PYG{n}{xx} \PYG{o}{+} \PYG{n}{gamma}
    
\PYG{c+c1}{\PYGZsh{} the \PYGZdq{}lambda\PYGZdq{} method allows you to define a function on a single line:}
\PYG{n}{integrand} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{y}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.2}\PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define the x array and calculate over it the function to display }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{integrand}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. }

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}f(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Simpson}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s Rule}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} put the ticks closer together:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}major\PYGZus{}locator}\PYG{p}{(}\PYG{n}{ticker}\PYG{o}{.}\PYG{n}{MultipleLocator}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the axis limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.520}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays, add a custom label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} draw vertical lines to denote the limits of the intervals:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{74}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{74}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the Simpson rule parabolas:}
\PYG{n}{xxp}\PYG{p}{,} \PYG{n}{yyp} \PYG{o}{=} \PYG{n}{SimpsonParabola}\PYG{p}{(}\PYG{n}{integrand}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xxp}\PYG{p}{,} \PYG{n}{yyp}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{xxp}\PYG{p}{,} \PYG{n}{yyp} \PYG{o}{=} \PYG{n}{SimpsonParabola}\PYG{p}{(}\PYG{n}{integrand}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{99}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xxp}\PYG{p}{,} \PYG{n}{yyp}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brown}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} fill the area under the curve:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{fill\PYGZus{}between}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,}\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} hide x and y axes label marks}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{xaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{labelbottom}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{labelleft}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} put text at the right points on the x\PYGZhy{}axis:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.035}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.98}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.035}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}b\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{367b09a3da8c90cde081629cf6a530ab9bdbe3f03408c4511b036198e70eafa3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
i.e.: \(f(x) \simeq \alpha x^2 + \beta x + \gamma\)

\sphinxAtStartPar
The intervals are equally spaced (red and grey dashes separate them). The area under the parabola for each interval is:

\sphinxAtStartPar
\(\int_{x_i}^{x_i + h} (\alpha x^2 + \beta x + \gamma)\mathrm{d} x = \left. \frac{ \alpha x^3 }{3} + \frac{ \beta x^2 }{2} + \gamma x \right|_{x_i}^{x_i + h}\)

\sphinxAtStartPar
For simplicity, consider an interval from \sphinxhyphen{}1 to 1:

\sphinxAtStartPar
\(\int_{-1}^{1} (\alpha x^2 + \beta x + \gamma)\mathrm{d} x = \frac{2 \alpha}{3} + 2\gamma\)

\sphinxAtStartPar
But also notice that:

\sphinxAtStartPar
\(f(-1) = \alpha - \beta + \gamma\), \(f(0) = \gamma\) and \(f(1) = \alpha + \beta + \gamma\).

\sphinxAtStartPar
Solving these for \(\alpha\), \(\beta\) and \(\gamma\):

\sphinxAtStartPar
\(\alpha= \frac{f(1) + f(-1)}{2} - f(0)\),

\sphinxAtStartPar
\(\beta = \frac{ f(1) - f(-1) } { 2 } \),

\sphinxAtStartPar
\(\gamma = f(0)\).

\sphinxAtStartPar
We can substitute for \(\alpha\) and \(\gamma\) to express the integral as the weighted sum over the values of the function at these three points:

\sphinxAtStartPar
\(\int_{-1}^{1} (\alpha x^2 + \beta x + \gamma)\mathrm{d} x = \frac{f(-1)}{3} +  \frac{4f(0)}{3} + \frac{ f(1)}{3}\).

\sphinxAtStartPar
Three values of the function are needed in each interval!

\sphinxAtStartPar
However, if we combine two intervals, we only need to evaluate the function at the two endpoints and in the middle:

\sphinxAtStartPar
\(\int_{x_i-h}^{x_i + h } f(x) \mathrm{d} x = \int_{x_i-h}^{x_i} f(x) \mathrm{d} x + \int_{x_i}^{x_i + h } f(x) \mathrm{d} x \simeq \frac{h}{3} f_{i-1} + \frac{ 4 h } {3} f_i + \frac{h}{3} f_{i+1}\).

\sphinxAtStartPar
Therefore, Simpson’s rule requires integration to be over pairs of intervals (i.e. separated by the grey lines in the figure above).

\sphinxAtStartPar
This implies that the total number of intervals must be even, and the total number of points must be odd!

\sphinxAtStartPar
In order to apply Simpson’s rule to the entire interval, we add up the contributions from each \sphinxstyleemphasis{pair of subintervals}, counting all all but the first and last endpoints twice, i.e.:

\sphinxAtStartPar
\(\int_{a}^{b} f(x) \mathrm{d} x \simeq \frac{h}{3} f_1 + \frac{4h}{3} f_2 + \frac{2h}{3} f_3 + \frac{4h}{3} f_4 + ... + \frac{4h}{3} f_{N-1} + \frac{h}{3} f_N\).

\sphinxAtStartPar
In terms of the standard integration rule with weights:

\sphinxAtStartPar
\(\int_a^b f(x) \mathrm{d} x \simeq \sum_{i=1}^N f(x_i) w_i\), \(w_i = \left\{ \frac{h}{3}, \frac{4h}{3}, \frac{2h}{3}, \frac{4h}{3}, ..., \frac{4h}{3}, \frac{h}{3} \right\}\).

\sphinxAtStartPar
The sum of the weights themselves provides a useful check on your implementation:

\sphinxAtStartPar
\(\sum_{i=1}^N w_i = (N-1)h\).

\sphinxAtStartPar
And remember that the number of points \(N\) must be odd for Simpson’s rule!


\subsubsection{Example 4.8: Construct a function that implements Simpson’s rule on an interval {[}a,b{]} using N points (N is odd!), and use to integrate f(x) = \textbackslash{}exp(\sphinxhyphen{}x) in the interval {[}0,1{]}.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-8-construct-a-function-that-implements-simpson-s-rule-on-an-interval-a-b-using-n-points-n-is-odd-and-use-to-integrate-f-x-exp-x-in-the-interval-0-1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Check that your sum of weights agrees with \(\sum_{i=1}^N w_i = (N-1)h\).

\item {} 
\sphinxAtStartPar
Compare to the analytic value for \(N=2001\) points.

\item {} 
\sphinxAtStartPar
Also compare to the result obtained in Example 4.7 using the trapezoid rule and \(N=10^6\) points.

\end{itemize}

\sphinxAtStartPar
You should find that Simpson’s rule with \(N=2001\) points performs better than the trapezoid rule with \(N=10^6\) points!


\subsection{Gaussian Quadrature}
\label{\detokenize{Chapters/Chapter4/Chapter4:gaussian-quadrature}}
\sphinxAtStartPar
In a similar manner as we did before, let’s rewrite the basic integration formula as follows:

\sphinxAtStartPar
\(\int_{-1}^1 f(x) \mathrm{d} x \simeq \sum_{i=1}^N f(x_i) w_i\).

\sphinxAtStartPar
Gaussian quadrature consists of \(N\) points and weights that are chosen to make the integration \sphinxstyleemphasis{exact} if \(f(x)\) is a \((2N-1)\)\sphinxhyphen{}degree polynomial!

\sphinxAtStartPar
In contrast to the equally\sphinxhyphen{}spaced rules (trapezoid/Simpson’s) that we have already seen, there is never an integration point at the extremes of intervals. The values of the points and weights change as the number of points \(N\) changes, and the points are \sphinxstyleemphasis{not equally spaced}.

\sphinxAtStartPar
For ordinary (also known as Gauss\sphinxhyphen{}Legendre) Gaussian integration, the points, \(x_i\) turn out to be the \(N\) zeros of the degree \(N\) Legendre polynomial \(P_N(x)\) on \([-1,1]\). The weights are:

\sphinxAtStartPar
\(w_i = \frac{ - 2 } { (N+1) P_N'(x_i) P_{N+1} (x_i) }\)

\sphinxAtStartPar
where \(P_N'(x)\) is the derivative of the Legendre polynomial. {[}See the course textbook for more details{]}.

\sphinxAtStartPar
Note that for integrals on a finite interval, the following change of variables is used to reduce the \([a,b]\) interval to the standard interval:

\sphinxAtStartPar
\(\int_{a}^b f(x) \mathrm{d} x = \frac{b-a}{2} \int_{-1}^1 f\left( \frac{(b-a)x + a + b}{2} \right) \mathrm{d}x\).

\sphinxAtStartPar
Let’s use Python special functions to calculate the first few Gauss\sphinxhyphen{}Legendre “nodes” and weights.


\subsubsection{Example 4.9: Use special functions to get the Gauss\sphinxhyphen{}Legendre points and weights for N=2 to N=8 points.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-9-use-special-functions-to-get-the-gauss-legendre-points-and-weights-for-n-2-to-n-8-points}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{scipy}

\PYG{c+c1}{\PYGZsh{} set the number of points}
\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{c+c1}{\PYGZsh{} we can access special functions using scipy.special.}
\PYG{c+c1}{\PYGZsh{} The roots of Legendre polynomials can be accessed via:}
\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{special}\PYG{o}{.}\PYG{n}{roots\PYGZus{}legendre}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the first array is the array of points and the second is the array pf weights:}
\PYG{n}{xi}\PYG{p}{,} \PYG{n}{wi} \PYG{o}{=} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{special}\PYG{o}{.}\PYG{n}{roots\PYGZus{}legendre}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} print them separately for N=2:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N=2 Gaussian quadrature, evaluated at:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xi}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with weights}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{wi}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now let\PYGZsq{}s also print N=2 to N=8:}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{xi}\PYG{p}{,} \PYG{n}{wi} \PYG{o}{=} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{special}\PYG{o}{.}\PYG{n}{roots\PYGZus{}legendre}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gaussian quadrature, evaluated at:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xi}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with weights}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{wi}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
N=2 Gaussian quadrature, evaluated at: [\PYGZhy{}0.57735027  0.57735027]
with weights [1. 1.]
n= 3 Gaussian quadrature, evaluated at: [\PYGZhy{}0.77459667  0.          0.77459667]
with weights [0.55555556 0.88888889 0.55555556] 

n= 4 Gaussian quadrature, evaluated at: [\PYGZhy{}0.86113631 \PYGZhy{}0.33998104  0.33998104  0.86113631]
with weights [0.34785485 0.65214515 0.65214515 0.34785485] 

n= 5 Gaussian quadrature, evaluated at: [\PYGZhy{}0.90617985 \PYGZhy{}0.53846931  0.          0.53846931  0.90617985]
with weights [0.23692689 0.47862867 0.56888889 0.47862867 0.23692689] 

n= 6 Gaussian quadrature, evaluated at: [\PYGZhy{}0.93246951 \PYGZhy{}0.66120939 \PYGZhy{}0.23861919  0.23861919  0.66120939  0.93246951]
with weights [0.17132449 0.36076157 0.46791393 0.46791393 0.36076157 0.17132449] 

n= 7 Gaussian quadrature, evaluated at: [\PYGZhy{}0.94910791 \PYGZhy{}0.74153119 \PYGZhy{}0.40584515  0.          0.40584515  0.74153119
  0.94910791]
with weights [0.12948497 0.27970539 0.38183005 0.41795918 0.38183005 0.27970539
 0.12948497] 

n= 8 Gaussian quadrature, evaluated at: [\PYGZhy{}0.96028986 \PYGZhy{}0.79666648 \PYGZhy{}0.52553241 \PYGZhy{}0.18343464  0.18343464  0.52553241
  0.79666648  0.96028986]
with weights [0.10122854 0.22238103 0.31370665 0.36268378 0.36268378 0.31370665
 0.22238103 0.10122854] 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let’s now use this to evaluate an integral!


\subsubsection{Example 4.10: Construct a function that implements N\sphinxhyphen{}th order Gaussian quadrature in the interval {[}a,b{]}, and use to integrate f(x) = \textbackslash{}exp(\sphinxhyphen{}x) in the interval {[}0,1{]} for N=8.}
\label{\detokenize{Chapters/Chapter4/Chapter4:example-4-10-construct-a-function-that-implements-n-th-order-gaussian-quadrature-in-the-interval-a-b-and-use-to-integrate-f-x-exp-x-in-the-interval-0-1-for-n-8}}
\sphinxAtStartPar
Compare to the results obtained through the trapezoid rule with \(N=10^6\) points, and Simpson’s rule with \(N=2001\) points.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{scipy} \PYG{c+c1}{\PYGZsh{} we need scipy for the N\PYGZhy{}th order Legendre polynomials. }

\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s write a higher\PYGZhy{}order function that implements N\PYGZhy{}th order Gaussian quadrature:}
\PYG{k}{def} \PYG{n+nf}{gauss}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculates the numerical integral of a function in the interval a,b using N\PYGZhy{}th order Gaussian quadrature\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} N\PYGZhy{}th order Gaussian quadrature }
    \PYG{c+c1}{\PYGZsh{} get the weights and points from the scipy special function:}
    \PYG{n}{xi}\PYG{p}{,} \PYG{n}{wi} \PYG{o}{=} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{special}\PYG{o}{.}\PYG{n}{roots\PYGZus{}legendre}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} now use the general formula to get the integral:}
    \PYG{n}{integral} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{n}{wj} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{wi}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} calculate the x value using the xi array:}
        \PYG{n}{xj} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{xi}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{n}{b} \PYG{o}{+} \PYG{n}{a}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} transform the xi[j] to the function argument, xj}
        \PYG{n}{integral} \PYG{o}{=} \PYG{n}{integral} \PYG{o}{+} \PYG{n}{wj} \PYG{o}{*} \PYG{n}{func}\PYG{p}{(}\PYG{n}{xj}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{integral}

\PYG{c+c1}{\PYGZsh{} test the function for exp(\PYGZhy{}t) in [0,1]:}
\PYG{c+c1}{\PYGZsh{} first define the function we wish to integrate: }
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{8} \PYG{c+c1}{\PYGZsh{} the order of the Gaussian quadrature}
\PYG{n}{gauss\PYGZus{}int} \PYG{o}{=} \PYG{n}{gauss}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Integral of exp(\PYGZhy{}t) in [0,1] via N=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaussian quadrature}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gauss\PYGZus{}int}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the analytic integral is simply 1 \PYGZhy{} exp(\PYGZhy{}1):}
\PYG{n}{analytic\PYGZus{}int} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Analytic integral=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{analytic\PYGZus{}int}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compare by calculating the fractional error:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fractional error=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{n}{gauss\PYGZus{}int}\PYG{o}{\PYGZhy{}}\PYG{n}{analytic\PYGZus{}int}\PYG{p}{)}\PYG{o}{/}\PYG{n}{analytic\PYGZus{}int} \PYG{p}{)} \PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Integral of exp(\PYGZhy{}t) in [0,1] via N= 8 Gaussian quadrature 0.6321205588285576
Analytic integral= 0.6321205588285577
Fractional error= 1.7563469643870083e\PYGZhy{}16
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We have reached extraordinary precision (essentially machine precision) with just 8 points!

\sphinxAtStartPar
We couldn’t reach this precision with \(N=10^6\) points and the trapezoid rule, and we needed \(N=2001\) points to reach this preecision with Simpson’s rule!


\subsection{Higher Order Rules (3/8 and Milne Rules)}
\label{\detokenize{Chapters/Chapter4/Chapter4:higher-order-rules-3-8-and-milne-rules}}
\sphinxAtStartPar
There exist other interesting “equal intrerval” rules that use higher\sphinxhyphen{}order approximations, such as the “3/8” rule and the Milne rule.

\sphinxAtStartPar
In terms of the formula: \(\int_a^b f(x) \mathrm{d} x \simeq \sum_{i=1}^N f(x_i) w_i\), the weights for the 3/8 rule (third\sphinxhyphen{}degree approximation) are:

\sphinxAtStartPar
\(w_i = (1,3,3,1)\frac{3}{8} h\).

\sphinxAtStartPar
and for the Milne rule (fourth\sphinxhyphen{}degree approximation):

\sphinxAtStartPar
\(w_i = (14, 64, 24, 64, 14) \frac{h}{45}\).

\sphinxAtStartPar
A useful check in these cases as well:

\sphinxAtStartPar
\(\sum_{i=1}^N w_i = b -a\).


\subsection{Integration Error Assessment}
\label{\detokenize{Chapters/Chapter4/Chapter4:integration-error-assessment}}
\sphinxAtStartPar
Let’s now use the functions for the trapezoid rule, Simpson’s rule, and N\sphinxhyphen{}th order Gaussian integration to evaluate the behavior of the relative error in each case, for the same function as before, \(f(x) = \exp(-x)\), integrated over the interval \([0,1]\), for which we know the analytic form.

\sphinxAtStartPar
As before, we will make a plot of the \(\log_{10}\) of the relative error, versus \(\log_{10}\) of the number of points used.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy} 

\PYG{n}{Narray} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{num}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{base}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the NumPy logspace returns numbers spaced evenly on a log scale.}

\PYG{c+c1}{\PYGZsh{} test the function for exp(\PYGZhy{}t) in [0,1]:}
\PYG{c+c1}{\PYGZsh{} first define the function we wish to integrate: }
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Trapezoid rule result:}
\PYG{n}{I\PYGZus{}trapezoid} \PYG{o}{=} \PYG{p}{[}\PYG{n}{trapezoid}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)} \PYG{k}{for} \PYG{n}{N} \PYG{o+ow}{in} \PYG{n}{Narray}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Simpson\PYGZsq{}s rule result:}
\PYG{c+c1}{\PYGZsh{} reinstate after we have written the function:}
\PYG{c+c1}{\PYGZsh{}I\PYGZus{}simpson = [simpson(f,0,1,N) for N in Narray]}

\PYG{c+c1}{\PYGZsh{} Gaussian Quadrature result:}
\PYG{n}{I\PYGZus{}gaussian} \PYG{o}{=} \PYG{p}{[}\PYG{n}{gauss}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)} \PYG{k}{for} \PYG{n}{N} \PYG{o+ow}{in} \PYG{n}{Narray}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Now let\PYGZsq{}s get the relative errors:}
\PYG{n}{I\PYGZus{}analytic} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} use the analytic result}

\PYG{c+c1}{\PYGZsh{} get the relative errors:}
\PYG{c+c1}{\PYGZsh{} trapezoid:}
\PYG{n}{eps\PYGZus{}trapezoid} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{I\PYGZus{}trapezoid}\PYG{p}{,}\PYG{n}{I\PYGZus{}analytic}\PYG{p}{)}\PYG{o}{/}\PYG{n}{I\PYGZus{}analytic} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} simpson: (uncomment)}
\PYG{c+c1}{\PYGZsh{} eps\PYGZus{}simpson = np.abs( np.subtract(I\PYGZus{}simpson,I\PYGZus{}analytic)/I\PYGZus{}analytic )}

\PYG{n}{eps\PYGZus{}gaussian} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{I\PYGZus{}gaussian}\PYG{p}{,}\PYG{n}{I\PYGZus{}analytic}\PYG{p}{)}\PYG{o}{/}\PYG{n}{I\PYGZus{}analytic} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} if a zero has been found, set it to machine precision:}
\PYG{n}{eps\PYGZus{}gaussian}\PYG{p}{[}\PYG{n}{eps\PYGZus{}gaussian}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{finfo}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eps}

\PYG{c+c1}{\PYGZsh{} get the log10:}
\PYG{n}{log10\PYGZus{}eps\PYGZus{}trapezoid} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{eps\PYGZus{}trapezoid}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} log10\PYGZus{}eps\PYGZus{}simpson = np.log10(eps\PYGZus{}simpson) \PYGZsh{} UNCOMMENT!}
\PYG{n}{log10\PYGZus{}eps\PYGZus{}gaussian} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{eps\PYGZus{}gaussian}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} and of the array: }
\PYG{n}{log10\PYGZus{}N} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{Narray}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now let\PYGZsq{}s plot them! }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Now plot! Don\PYGZsq{}t forget the different labels! }
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{log\PYGZus{}}\PYG{l+s+si}{\PYGZob{}10\PYGZcb{}}\PYG{l+s+s1}{(N)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{log\PYGZus{}}\PYG{l+s+si}{\PYGZob{}10\PYGZcb{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{varepsilon)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error assessment in numerical integration of \PYGZdl{}f(x)=}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{exp(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the arrays relevant to the cosine:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{log10\PYGZus{}N}\PYG{p}{,} \PYG{n}{log10\PYGZus{}eps\PYGZus{}trapezoid}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Trapezoid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{}ax.plot(log10\PYGZus{}N, log10\PYGZus{}eps\PYGZus{}simpson, label=\PYGZsq{}Simpson\PYGZsq{}, ls=\PYGZsq{}\PYGZhy{}\PYGZsq{}, color=\PYGZsq{}green\PYGZsq{}) }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{log10\PYGZus{}N}\PYG{p}{,} \PYG{n}{log10\PYGZus{}eps\PYGZus{}gaussian}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gaussian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{b4622c13e606c44b0b1ab6d92343d2dce59eda3daa3cfdb27c06925b01050ab1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Minor Digression: Python functools and partial functions}
\label{\detokenize{Chapters/Chapter4/Chapter4:minor-digression-python-functools-and-partial-functions}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{functools}} module is for higher\sphinxhyphen{}order functions: functions that act on or return other functions. In general, any callable object can be treated as a function for the purposes of this module.

\sphinxAtStartPar
See \sphinxurl{https://docs.python.org/3/library/functools.html} for details.

\sphinxAtStartPar
Here, I wish to discuss \sphinxcode{\sphinxupquote{partial}} functions.

\sphinxAtStartPar
Suppose we have a function that takes as arguments a variable and two parameters, e.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{myfunction}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}My function\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{*} \PYG{n}{x} \PYG{o}{+} \PYG{n}{b}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Suppose we want to do something with this function, e.g. integrate it in the interval \([0,1]\) for various values of \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}. We can create a “partial” function and then use it as an argument in our higher\sphinxhyphen{}order functions (e.g. \sphinxcode{\sphinxupquote{gauss()}}) for integration:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{partial} \PYG{c+c1}{\PYGZsh{} partial functions allow us to fix a certain number of arguments of a function and generate a new function.}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{ai} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{bi} \PYG{o+ow}{in} \PYG{n}{b}\PYG{p}{:}
        \PYG{n}{partial\PYGZus{}func} \PYG{o}{=} \PYG{n}{partial}\PYG{p}{(}\PYG{n}{myfunction}\PYG{p}{,} \PYG{n}{a}\PYG{o}{=}\PYG{n}{ai}\PYG{p}{,} \PYG{n}{b}\PYG{o}{=}\PYG{n}{bi}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} this has created a new function with the parameters a and b fixed}
        \PYG{c+c1}{\PYGZsh{} now we can pass this to our integrator!}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Integral of a*x+b in [0,1], for a=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{ai}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{bi}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{gauss}\PYG{p}{(}\PYG{n}{partial\PYGZus{}func}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
        
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Integral of a*x+b in [0,1], for a= 0.1 b= 0.4 = 0.45000000000000007
Integral of a*x+b in [0,1], for a= 0.1 b= 0.5 = 0.55
Integral of a*x+b in [0,1], for a= 0.1 b= 0.6 = 0.65
Integral of a*x+b in [0,1], for a= 0.2 b= 0.4 = 0.5
Integral of a*x+b in [0,1], for a= 0.2 b= 0.5 = 0.6000000000000001
Integral of a*x+b in [0,1], for a= 0.2 b= 0.6 = 0.7000000000000001
Integral of a*x+b in [0,1], for a= 0.3 b= 0.4 = 0.55
Integral of a*x+b in [0,1], for a= 0.3 b= 0.5 = 0.6499999999999999
Integral of a*x+b in [0,1], for a= 0.3 b= 0.6 = 0.75
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope

\sphinxAtStartPar
 \sphinxstylestrong{Chapter 5: Monte Carlo Methods.} 


\chapter{Monte Carlo Methods}
\label{\detokenize{Chapters/Chapter5/Chapter5:monte-carlo-methods}}\label{\detokenize{Chapters/Chapter5/Chapter5::doc}}

\section{Introduction}
\label{\detokenize{Chapters/Chapter5/Chapter5:introduction}}
\sphinxAtStartPar
In physics we are often interested in systems with large degrees of freedom, e.g.:
\begin{itemize}
\item {} 
\sphinxAtStartPar
many atoms in a chunk of matter,

\item {} 
\sphinxAtStartPar
many electrons in an atom,

\item {} 
\sphinxAtStartPar
the infinitely\sphinxhyphen{}many values of a quantum field at all points in a region of space\sphinxhyphen{}time.

\end{itemize}

\sphinxAtStartPar
The description of such systems often involves the evaluation of integrals of very high dimension.

\sphinxAtStartPar
For example, imagine that we need to integrate atomic wave functions over the three coordinates of each of the 12 electrons in a magnesium atom. This amounts to 3x12=36 dimensions!

\sphinxAtStartPar
If we use 64 points for each integration, this requires about \(64^{36} \simeq 10^{65}\) evaluations of the integrand. If you had a very fast computer, capable of \(10^6\) evaluations per second, this would take \(10^{59}\) s, which is significantly longer than the age of the universe! (\(\sim 10^{17}\) s).

\sphinxAtStartPar
Direct quadrature is hopeless, if you still want to be alive when your integration is done!

\sphinxAtStartPar
Monte Carlo methods provide a way to efficiently evaluating integrals of high dimension.

\sphinxAtStartPar
“Monte Carlo”: arises from the random or “chance” character of the method, through the famous casino in Monaco.

\sphinxAtStartPar
\sphinxstylestrong{Basic idea}: evaluate the integrand at a representative random sample of points. Analogous to predicting the results of an election on the basis of a poll of a small number of voters.

\sphinxAtStartPar
It turns out that the Monte Carlo strategy is very appropriate for a broad class of problems in statistical and quantum mechanics.


\section{The Basic Monte Carlo Strategy}
\label{\detokenize{Chapters/Chapter5/Chapter5:the-basic-monte-carlo-strategy}}
\sphinxAtStartPar
Even though the real power of Monte Carlo methods (henceforth: MC) is in evaluating multi\sphinxhyphen{}dimensional integrals, it is easiest to illustrate the basic ideas in a one\sphinxhyphen{}dimensional situation.

\sphinxAtStartPar
Suppose we have to evaluate the integral:

\sphinxAtStartPar
\(I = \int_0^1 f(x) \mathrm{d} x\).

\sphinxAtStartPar
In Chapter 4, we discussed several quadrature formulas that used values of \(f\) at particular values of \(x\), e.g. equally\sphinxhyphen{}spaced for the trapezium and Simpson’s rule.

\sphinxAtStartPar
An alternative way of evaluating the integral is to think of it as the average of \(f\) over the interval \([0,1]\):

\sphinxAtStartPar
\(I \approx \frac{1}{N} \sum_{i=1}^N f(x_i)\).

\sphinxAtStartPar
Here, the average of \(f\) is evaluated by considering its values at \(N\) points \(x_i\), chosen at random, with equal probability anywhere within the interval \([0,1]\) (i.e. uniformly).

\sphinxAtStartPar
To estimate the uncertainty associated with this formula, \(\sigma_I\), consider \(f_i \equiv f(x_i)\) as a random variable, and invoke the central limit theorem for large \(N\). From the usual laws of statistics, we then have:

\sphinxAtStartPar
\(\sigma_I^2 \approx \frac{1}{N} \sigma_f^2 = \frac{1}{N} \left[ \frac{1}{N} \sum_{i=1}^N f_i^2 - \left( \frac{1}{N} \sum_{i=1}^N f_i \right)^2 \right]\)

\sphinxAtStartPar
where \(\sigma_f^2\) is the “variance” in \(f\), i.e. a measure of the extent to which \(f\) deviates from its average value over the region of integration.

\sphinxAtStartPar
Some important aspects of Monte Carlo integration are revealed by the above integration formula:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The uncertainty in the estimate of the integral, \(\sigma_I\), decreases as \(1/\sqrt{N}\). If more points are used, we will get a more precise answer, although the error decreases very slowly with the number of points: you need to do four times more numerical work to halve the error in your answer!

\item {} 
\sphinxAtStartPar
The trapezium rule error scales as \(1/N^2\), therefore having a much greater accuracy for a given amount of numerical work. This advantage vasnishes in the multi\sphinxhyphen{}dimensional case, as we will see shortly.

\item {} 
\sphinxAtStartPar
The precision is greater if \(\sigma_f\) is smaller: i.e. if \(f\) is as smooth as possible. One limit to consider is that when \(f\) is constant, in which case we need its value only at one point to define its average. In the other limit, consider a situation in which \(f\) is zero everywhere, except for a very narrow peak above some value of \(x\). Then, if we pick \(x_i\)s with an equal probability in \([0,1]\), it is probable that all but a few of them will lie outside the peak of \(f\), and this will lead to a poor estimate of \(I\).

\end{itemize}

\sphinxAtStartPar
The method is extended to any interval \([a,b]\), by choosing random, uniform \(x_i\)s in \([a,b]\) and:

\sphinxAtStartPar
\(I = \int_a^b f(x) \mathrm{d} x = \frac{b-a}{N} \sum_{i=1}^N f(x_i)\).

\sphinxAtStartPar
Let’s begin our numerical Monte Carlo work by evaluating the integral:

\sphinxAtStartPar
\(\int_0^1 \frac{ \mathrm{d} x } { 1 + x^2 } = \frac{\pi}{4}\).

\sphinxAtStartPar
Let’s also calculate the error using the formula for \(\sigma_I\).


\subsection{Example 5.1: Use the Monte Carlo integration method to calculate the integral \textbackslash{}int\_0\textasciicircum{}1 \textbackslash{}frac\{ \textbackslash{}mathrm\{d\} x \} \{ 1 + x\textasciicircum{}2 \} = \textbackslash{}frac\{\textbackslash{}pi\}\{4\}. Also calculate the error.}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-1-use-the-monte-carlo-integration-method-to-calculate-the-integral-int-0-1-frac-mathrm-d-x-1-x-2-frac-pi-4-also-calculate-the-error}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{c+c1}{\PYGZsh{} we need random numbers for the Monte Carlo method!}

\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s define a function that performs one\PYGZhy{}dimensional MC integration of an arbitrary for N points}
\PYG{c+c1}{\PYGZsh{} We\PYGZsq{}ll also make it capable of performing the integration in an interval a,b}
\PYG{k}{def} \PYG{n+nf}{mcint}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sumi} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{sumisq} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{xi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a}
        \PYG{n}{sumi} \PYG{o}{=} \PYG{n}{sumi} \PYG{o}{+} \PYG{n}{func}\PYG{p}{(}\PYG{n}{xi}\PYG{p}{)}
        \PYG{n}{sumisq} \PYG{o}{=} \PYG{n}{sumisq} \PYG{o}{+} \PYG{n}{func}\PYG{p}{(}\PYG{n}{xi}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{n}{I} \PYG{o}{=} \PYG{n}{sumi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{/} \PYG{n}{N}
    \PYG{n}{sumisq} \PYG{o}{=} \PYG{n}{sumisq}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{c+c1}{\PYGZsh{} sumisq *= (b\PYGZhy{}a)**2}
    \PYG{n}{sigmaI} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{N}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{N}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sumisq} \PYG{o}{\PYGZhy{}} \PYG{n}{I}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{p}{)} \PYG{p}{)}

    \PYG{k}{return} \PYG{n}{I}\PYG{p}{,} \PYG{n}{sigmaI} \PYG{c+c1}{\PYGZsh{} return the integral and its error}

\PYG{k}{def} \PYG{n+nf}{fEX51}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{Iex51}\PYG{p}{,} \PYG{n}{err\PYGZus{}ex51} \PYG{o}{=} \PYG{n}{mcint}\PYG{p}{(}\PYG{n}{fEX51}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The estimate of the integral is=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Iex51}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{err\PYGZus{}ex51}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s compare to the analytical value=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The estimate of the integral is= 0.8066530303708649 +\PYGZhy{} 0.016105612466499625
Let\PYGZsq{}s compare to the analytical value= 0.7853981633974483
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Example 5.2: For the function of example 5.1, calculate the error as a function of the number of points N, from N=10 to N=10\textasciicircum{}4. Plot the the logarithm of the error versus the log of the number of points. Does it agree with our expectations?}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-2-for-the-function-of-example-5-1-calculate-the-error-as-a-function-of-the-number-of-points-n-from-n-10-to-n-10-4-plot-the-the-logarithm-of-the-error-versus-the-log-of-the-number-of-points-does-it-agree-with-our-expectations}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The array of the number of points to integrate over:}
\PYG{n}{Narray} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{2000}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{]}

\PYG{n}{Errs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{Ni} \PYG{o+ow}{in} \PYG{n}{Narray}\PYG{p}{:}
    \PYG{n}{I}\PYG{p}{,} \PYG{n}{err} \PYG{o}{=} \PYG{n}{mcint}\PYG{p}{(}\PYG{n}{fEX51}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ni}\PYG{p}{)}
    \PYG{n}{Errs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{err}\PYG{o}{/}\PYG{n}{I}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s plot:}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single set of axes.}

\PYG{c+c1}{\PYGZsh{} get the logs:}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{Narray}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n}{Errs}\PYG{p}{)}
\PYG{n}{yexpect} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{Narray}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot: }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{yexpect}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theoretical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot using the above arrays}

\PYG{c+c1}{\PYGZsh{} labels:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{log\PYGZus{}}\PYG{l+s+si}{\PYGZob{}10\PYGZcb{}}\PYG{l+s+s1}{(N)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{log\PYGZus{}}\PYG{l+s+si}{\PYGZob{}10\PYGZcb{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{epsilon)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{10}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{7}     \PYG{n}{Errs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{err}\PYG{o}{/}\PYG{n}{I}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{9} \PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s plot:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{10} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{11} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{13} \PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single set of axes.}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}matplotlib\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Variance Reduction}
\label{\detokenize{Chapters/Chapter5/Chapter5:variance-reduction}}
\sphinxAtStartPar
The uncertainty (squared) in a MC quadrature is proportional to the variance of the integrand:

\sphinxAtStartPar
\(\sigma_I^2 \approx \frac{1}{N} \sigma_f^2\),

\sphinxAtStartPar
with the variance of the integrand:

\sphinxAtStartPar
\(\sigma_f^2 = \left[ \frac{1}{N} \sum_{i=1}^N f_i^2 - \left( \frac{1}{N} \sum_{i=1}^N f_i \right)^2 \right]\).

\sphinxAtStartPar
Therefore, if we find a way of reducing the variance of the integrand, we will improve the efficiency of the method. One method is known as “importance sampling”.

\sphinxAtStartPar
Let’s imagine multiplying and dividing the integrand by a positive weight function \(w(x)\), normalized such that:

\sphinxAtStartPar
\(\int_0^1 w(x) \mathrm{d} x = 1\).

\sphinxAtStartPar
The integral can then be written as:

\sphinxAtStartPar
\(I = \int_0^1 w(x) \frac{f (x)} { w(x) } \mathrm{d} x\).

\sphinxAtStartPar
We can then change variables from \(x\) to:

\sphinxAtStartPar
\(y(x) = \int_0^x w(x') \mathrm{d}x'\).

\sphinxAtStartPar
This implies that:

\sphinxAtStartPar
\(\frac{ \mathrm{d} y } { \mathrm{d} x } = w(x)\) and \(y(x=0)=0\), \(y(x=1)=1\).

\sphinxAtStartPar
and after the change of variables, the integral becomes:

\sphinxAtStartPar
\(I = \int_0^1 \frac{ f(x(y)) } { w(x(y)) } \mathrm{d} y\).

\sphinxAtStartPar
The MC integration proceeds as usual, i.e. averaging the values of \(f/w\) using random and uniform points \(y\) over the interval \([0,1]\):

\sphinxAtStartPar
\(I \approx \frac{1}{N} \sum_{i=1}^N \frac{ f(x(y_i)) } { w(x(y_i)) }\).

\sphinxAtStartPar
If we choose a \(w\) function that behaves approximately as \(f\), i.e. it is large where \(f\) is large and small where \(f\) is small, then the integrand \(f/w\) can be made very smooth.
This will result in a reduction in the variance of the MC estimate.

\sphinxAtStartPar
This implies of course that we are able to find an appropriate \(w\) and that we are able to invert \(y(x) = \int_0^x w(x') \mathrm{d}x'\) to find \(x(y)\).

\sphinxAtStartPar
As an example, let’s consider the same integral, \(I = \int_0^1 \frac{\mathrm{d}x}{1+x^2}\). A good choice for a weight function is:

\sphinxAtStartPar
\(w(x) = \frac{1}{3} (4 - 2 x)\).

\sphinxAtStartPar
This is positive definite, decreases monotonically and is normalized correctly: \(\int_0^1 w(x) \mathrm{d}x = 1\). It also approximates well the behavior of \(f\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Now plot! Don\PYGZsq{}t forget the different labels! }
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Function comparison}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} construct the x variable: }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make a one\PYGZhy{}dimensional plot:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}f(x) = 1/(x\PYGZca{}2 + 1)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} check if this agrees with a line with slope \PYGZhy{}1/2 (on the log\PYGZhy{}log plot):}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}w(x) = (4\PYGZhy{}2x)/3\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{22fadf4c4b870bf9226bbfa0ea708b9a646a0f361f7b929b65326be04ee6ad27}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The new integration variable is:

\sphinxAtStartPar
\(y = \int_0^x w(x') \mathrm{d} x' = \frac{1}{3} x(4-x)\).

\sphinxAtStartPar
And this can be inverted to give:

\sphinxAtStartPar
\(x = 2 - (4 - 3y)^{1/2}\).

\sphinxAtStartPar
Let’s see this change of variables in action!


\subsection{Example 5.3: Use the Monte Carlo integration method with the variance reduction to calculate the integral \textbackslash{}int\_0\textasciicircum{}1 \textbackslash{}frac\{ \textbackslash{}mathrm\{d\} x \} \{ 1 + x\textasciicircum{}2 \} over the same number of points as in Example 5.2. Make a plot comparing to the error calculated in Example 5.2.}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-3-use-the-monte-carlo-integration-method-with-the-variance-reduction-to-calculate-the-integral-int-0-1-frac-mathrm-d-x-1-x-2-over-the-same-number-of-points-as-in-example-5-2-make-a-plot-comparing-to-the-error-calculated-in-example-5-2}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Start by modifying the mcint function to accept the x(y) and w(x) functions as input}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{c+c1}{\PYGZsh{} we need random numbers for the Monte Carlo method!}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The MC integral of f(x) = 1/(1+x\PYGZca{}2) in [0,1] for N=1E4 points is= 0.784742361698107 +\PYGZhy{} 0.0015987488463171692
The MC integral with variance reduction 0.7855334063802001 +\PYGZhy{} 0.0001698120319239752
The analytic value of the integral is= 0.7853981633974483
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Multi\sphinxhyphen{}Dimensional Monte Carlo Integration}
\label{\detokenize{Chapters/Chapter5/Chapter5:multi-dimensional-monte-carlo-integration}}
\sphinxAtStartPar
The one\sphinxhyphen{}dimensional discussion above can be readily generalized to \(d\)\sphinxhyphen{}dimensional integrals of the form:

\sphinxAtStartPar
\(I = \int \mathrm{d}^d x f(\vec{x})\).

\sphinxAtStartPar
MC integration proceeds as it did in the one\sphinxhyphen{}dimensional case:

\sphinxAtStartPar
\(I \approx \frac{1}{N} \sum_{i=1}^N f(\vec{x}_i)\),

\sphinxAtStartPar
where the components of the vector \(\vec{x}_i\) are chosen independently.

\sphinxAtStartPar
Let’s use this method to calculate \(\pi\) via:

\sphinxAtStartPar
\(\pi = 4 \int_0^1 \mathrm{d} y \int_0^1 \mathrm{d} x \theta(1 - x^2 - y^2)\),

\sphinxAtStartPar
i.e. by comparing the area of a quadrant of the unit circle, to that of the unit square.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Now plot! Don\PYGZsq{}t forget the different labels! }
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Area of quadrant of cirlce vs. that of square of side 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} plot the circle}
\PYG{n}{circle1} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{Circle}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{ec}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{circle1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the aspect ratio of the axes to 1:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{3619e449ca1948cfd9897857208f9946c34ba2517bb83f7325586e57031c189d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Example 5.4: Use multi\sphinxhyphen{}dimensional Monte Carlo integration to calculate π!}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-4-use-multi-dimensional-monte-carlo-integration-to-calculate}}
\sphinxAtStartPar
We can also use variance reduction in many dimensions. For a weight function \(w(\vec{x})\) normalized so that its integral over the region is unity, the new variable is a vector \(\vec{y}\), where the \sphinxstyleemphasis{Jacobian} is:

\sphinxAtStartPar
\(\left| \frac{\partial \vec{y}}{\partial \vec{x}}\right| = w(\vec{x})\).

\sphinxAtStartPar
It’s generally very difficult to construct \(\vec{x}(\vec{y})\) explicitly. We will discuss methods to do this below.

\sphinxAtStartPar
Going back to our MC integration results, although the results were satisfactory in our examples, MC integration does not appear to be particularly efficient, especially in comparison to the other quadrature methods that we previously discussed.

\sphinxAtStartPar
However, consider evaluating a multi\sphinxhyphen{}dimensional integral, such as the one used for the calculation of \(\pi\).

\sphinxAtStartPar
Suppose that we are willing to invest a given amount of numerical work, e.g. to evaluate the integrand exactly \(N\) times, and we wish to compare the efficiencies of various quadrature methods.

\sphinxAtStartPar
For the trapezoid rule, for example, if there are a total of \(N\) points, then each dimension of a \(d\)\sphinxhyphen{}dimensional integral is broken up into \(\sim N^{1/d}\) intervals, of spacing \(h\sim N^{-1/d}\). It turns out that the total error would be:

\sphinxAtStartPar
\(\epsilon_\mathrm{trapezoid} \sim \mathcal{O}(1/N^{2/d})\).

\sphinxAtStartPar
For large \(d\), this decreases very slowly with increasing \(N\). For example, for \(d=4\), it decreases as \(\sim \mathcal{O}(1/N^{1/2})\).

\sphinxAtStartPar
On the other hand, the uncertainty of Monte Carlo quadrature always decreases as \(\sim 1/\sqrt{N}\), \sphinxstyleemphasis{independent} of the number of dimensions \(d\)!

\sphinxAtStartPar
Therefore, we would expect that the MC method is more efficient than the trapezoid method when \(d\simeq 4\).


\section{von Neumann Rejection Sampling (“Hit\sphinxhyphen{}or\sphinxhyphen{}Miss”)}
\label{\detokenize{Chapters/Chapter5/Chapter5:von-neumann-rejection-sampling-hit-or-miss}}
\sphinxAtStartPar
During our integration of \(I = \int_0^1 \frac{1}{1+x^2} \mathrm{d} x\), if we had wanted to use the weight function:

\sphinxAtStartPar
\(w(x) = \frac{6}{5} (1 - \frac{1}{2} x^2)\),

\sphinxAtStartPar
then we would have been faced with solving a cubic equation to find \(x(y)\). While this is certainly possible, choices of the weight that might follow \(f\) more generally will lead to more complicated functions that cannot be inverted analytically.

\sphinxAtStartPar
However, it is possible to do this numerically. A convenient method for generating one\sphinxhyphen{} or multi\sphinxhyphen{}dimensional random variables is the von Neumann rejection:

\sphinxAtStartPar
Suppose we are interested in generating \(x\) in \([0,1]\) with distribution \(w(x)\), and that \(w'(x)\) is a positive function such that \(w'(x) > w(x)\) over the region of integration (Note that this is not the derivative). A convenient choice (but not always useful) for \(w'\) is any constant greater than (or equal to) the maximum value of \(w\) in the region of integration.

\sphinxAtStartPar
If we generate points in two dimensions that uniformly fill the area under the curve \(w'(x)\) and then “accept” for use only those points that are under \(w(x)\), then the accepted points will be distributed according to \(w(x)\).

\sphinxAtStartPar
Practically:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Choose \(x_i\) distributed proportional to \(w'\),

\item {} 
\sphinxAtStartPar
Choose a random number \(\eta\) uniformly in \([0,1]\).

\item {} 
\sphinxAtStartPar
\(x_i\) is then accepted if \(\eta < w(x_i)/w'(x_i)\).

\item {} 
\sphinxAtStartPar
if a point is rejected, we simply go on and try another \(x_i\).

\end{itemize}

\sphinxAtStartPar
This technique is clearly efficient only if \(w'\) is close to \(w\) throughout the entire range of integration, otherwise too much time is wasted rejecting “useless” points.


\subsection{Example 5.5: Use von Neumann rejection to sample points in the interval {[}0,1{]}, distributed as w(x) = \textbackslash{}frac\{6\}\{5\} ( 1 \sphinxhyphen{} \textbackslash{}frac\{1\}\{2\} x\textasciicircum{}2). Plot a histogram of the points and verify that they are indeed distributed according to w(x). Evaluate the integral I = \textbackslash{}int\_0\textasciicircum{}1 \textbackslash{}frac\{1\}\{1+x\textasciicircum{}2\} \textbackslash{}mathrm\{d\} x and its uncertainty with these points.}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-5-use-von-neumann-rejection-to-sample-points-in-the-interval-0-1-distributed-as-w-x-frac-6-5-1-frac-1-2-x-2-plot-a-histogram-of-the-points-and-verify-that-they-are-indeed-distributed-according-to-w-x-evaluate-the-integral-i-int-0-1-frac-1-1-x-2-mathrm-d-x-and-its-uncertainty-with-these-points}}

\subsection{An Introduction to Monte Carlo Simulations}
\label{\detokenize{Chapters/Chapter5/Chapter5:an-introduction-to-monte-carlo-simulations}}
\sphinxAtStartPar
A Monte Carlo simulation contains the following ingredients:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A probability density function that characterizes the system that we wish to simulate,

\item {} 
\sphinxAtStartPar
Random numbers,

\item {} 
\sphinxAtStartPar
A sampling rule,

\item {} 
\sphinxAtStartPar
An error estimation.

\end{itemize}

\sphinxAtStartPar
The von Neumann rejection method of sampling provides a simple way to generate “simulations”, i.e. samples of “events” that are distributed according to a certain probability density function, and look “realistic”.

\sphinxAtStartPar
Let’s examine an example in one dimension!


\subsection{Example 5.5: Due to the uncertainty principle, the mass, m of an unstable particle (which can be measured through the momenta of its decay products), is distributed according to the Breit\sphinxhyphen{}Wigner distribution (in natural units):}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-5-due-to-the-uncertainty-principle-the-mass-m-of-an-unstable-particle-which-can-be-measured-through-the-momenta-of-its-decay-products-is-distributed-according-to-the-breit-wigner-distribution-in-natural-units}}
\sphinxAtStartPar
\(f(m) = \frac{k}{ (m^2 - M^2)^2 + \Gamma^2 M^2 }\),

\sphinxAtStartPar
where \(k\) is a normalization constant, \(M\) is the particle’s “nominal” mass and, \(\Gamma = 1/\tau\) is its width, defined as the inverse of its lifetime, \(\tau\).

\sphinxAtStartPar
Our goal is to generate \(N\) decays of the particle in its rest frame, distributed according to the Breit\sphinxhyphen{}Wigner distribution.

\sphinxAtStartPar
We can assume that the particle is a top quark, with nominal mass \(M = 172.7\) GeV and width \(\Gamma = 1.4\) GeV.

\sphinxAtStartPar
We can use the von Neumann rejection method. To do so, we need to find a constant which is larger than \(f(m)\) everywhere. We can start by choosing \(f_\mathrm{max}= \frac{k}{ \Gamma^2 M^2 }\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} first let\PYGZsq{}s define our distribution: }
\PYG{k}{def} \PYG{n+nf}{fBW}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{Gam}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the Breit\PYGZhy{}Wigner distribution\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} set the normalization constant to 1}
    \PYG{k}{return} \PYG{n}{k} \PYG{o}{/} \PYG{p}{(}\PYG{p}{(} \PYG{n}{m}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{Gam}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{M}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} and perform the von Neumann rejection:}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{1000} \PYG{c+c1}{\PYGZsh{} we will generate N decay \PYGZdq{}events\PYGZdq{}}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} n will be the counter of generated \PYGZdq{}events\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} set the properties of the particle:}
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mf}{172.7}
\PYG{n}{Gam} \PYG{o}{=} \PYG{l+m+mi}{14}
\PYG{c+c1}{\PYGZsh{} let\PYGZsq{}s also set a minimum and maximum mass (in GeV) }
\PYG{n}{mmax} \PYG{o}{=} \PYG{l+m+mi}{200} 
\PYG{n}{mmin} \PYG{o}{=} \PYG{l+m+mi}{150}
\PYG{c+c1}{\PYGZsh{} and save the generated masses in an array:}
\PYG{n}{masses} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{while} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{:}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{mmax}\PYG{o}{\PYGZhy{}}\PYG{n}{mmin}\PYG{p}{)} \PYG{o}{+} \PYG{n}{mmin}  
    \PYG{n}{r} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{fBW}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{Gam}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{Gam}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{n}{M}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{n}{masses}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{pass}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s plot a histogram of the masses!}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}m\PYGZdl{} [GeV]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{frequency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Breit\PYGZhy{}Wigner for a top quark}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{masses}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{fill}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{histtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{step}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{von Neumann}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{6deebd3d48e755a6d6b3816a77633d9505c00b62416b1503f4f21d37bbd66e59}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this case, we can perform a change of variables to obtain an efficiency of 100\%:

\sphinxAtStartPar
\(m^2 = M\Gamma \tan\eta + M^2\).

\sphinxAtStartPar
and with this:

\sphinxAtStartPar
\(\frac{ \mathrm{d} m^2 }{ \mathrm{d} \eta} = M\Gamma \sec^2 \eta\), which turns the Breit\sphinxhyphen{}Wigner distribution flat, e.g., under the integral:

\sphinxAtStartPar
\(I = \int_{m_\mathrm{min}}^{m_\mathrm{max}} \mathrm{d} m^2 \frac{k}{ (m^2 - M^2)^2 + \Gamma^2 M^2 }\),

\sphinxAtStartPar
which turns into:

\sphinxAtStartPar
\(I = \int_{m_\mathrm{min}}^{m_\mathrm{max}} \mathrm{d} \eta \left|\frac{ \mathrm{d} m^2 }{ \mathrm{d} \eta}\right|  \frac{k}{ (m^2 - M^2)^2 + \Gamma^2 M^2 } = \int_{\eta_\mathrm{min}}^{\eta_\mathrm{max}} \frac{k}{\Gamma M} \mathrm{d} \rho\).


\subsection{Example 5.6: Generate events distributed according to a Gaussian distribution:}
\label{\detokenize{Chapters/Chapter5/Chapter5:example-5-6-generate-events-distributed-according-to-a-gaussian-distribution}}
\sphinxAtStartPar
\(f(x) = \frac{1}{\sigma \sqrt{2 \pi}} \exp(- (x-\mu)^2 / (2\sigma^2))\)

\sphinxAtStartPar
Plot the results in a histogram.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} first let\PYGZsq{}s define our distribution: }
\PYG{k}{def} \PYG{n+nf}{Gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculate the Gaussan distribution\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{sigma}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} and perform the von Neumann rejection:}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10000} \PYG{c+c1}{\PYGZsh{} we will generate N poits}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} n will be the counter of generated \PYGZdq{}events\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} set the properties of the particle:}
\PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{c+c1}{\PYGZsh{} let\PYGZsq{}s also set a minimum and maximum mass (in GeV) }
\PYG{n}{xmin} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}
\PYG{n}{xmax} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{} and save the generated masses in an array:}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{while} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{N}\PYG{p}{:}
    \PYG{n}{xi} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{xmax}\PYG{o}{\PYGZhy{}}\PYG{n}{xmin}\PYG{p}{)} \PYG{o}{+} \PYG{n}{xmin}  
    \PYG{n}{r} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{n}{Gaussian}\PYG{p}{(}\PYG{n}{xi}\PYG{p}{,}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{o}{/} \PYG{n}{Gaussian}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{n}{x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{xi}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{pass}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{frequency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gaussian distribution with \PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mu=}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{} and \PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sigma=}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{fill}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{histtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{step}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{von Neumann}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} plot the distribution itself:}
\PYG{n}{xv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{xmin}\PYG{p}{,} \PYG{n}{xmax}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{gaussianpoints} \PYG{o}{=} \PYG{n}{Gaussian}\PYG{p}{(}\PYG{n}{xv}\PYG{p}{,}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xv}\PYG{p}{,} \PYG{n}{gaussianpoints}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gaussian analytic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{7376f37b6201228261b1908ebce88100b25067bc575ab6c3e1f7fb3eb292d8ec}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope

\sphinxAtStartPar
 \sphinxstylestrong{Chapter 6:  Matrix Computing, Trial\sphinxhyphen{}and\sphinxhyphen{}Error Searching and Data Fitting.} 


\chapter{Matrix Computing, Trial\sphinxhyphen{}and\sphinxhyphen{}Error Searching and Data Fitting}
\label{\detokenize{Chapters/Chapter6/Chapter6:matrix-computing-trial-and-error-searching-and-data-fitting}}\label{\detokenize{Chapters/Chapter6/Chapter6::doc}}

\section{Trial\sphinxhyphen{}and\sphinxhyphen{}Error Root Finding}
\label{\detokenize{Chapters/Chapter6/Chapter6:trial-and-error-root-finding}}

\subsection{Introduction}
\label{\detokenize{Chapters/Chapter6/Chapter6:introduction}}
\sphinxAtStartPar
Trial\sphinxhyphen{}and\sphinxhyphen{}error may not sound very precise, but it is in fact used to solve problems where analytic solutions do not exist, or are not practical.

\sphinxAtStartPar
In trial\sphinxhyphen{}and\sphinxhyphen{}error algorithms, decisions on what path to follow are made based on the current values of variables, and the program quits only when it thinks it has solved the problem.

\sphinxAtStartPar
Trial\sphinxhyphen{}and\sphinxhyphen{}error root finding looks for a value of \(x\) for which:

\sphinxAtStartPar
\(f(x) \simeq 0\).

\sphinxAtStartPar
To put the zero on the right\sphinxhyphen{}hand side is conventional, since any equation can be written in this form, e.g.

\sphinxAtStartPar
\( 10 \sin (x) = 3x^3 \Rightarrow 10 \sin(x) - 3x^3 = 0\).

\sphinxAtStartPar
Generally, the procedure starts with a \sphinxstyleemphasis{guessed} value for \(x\), substitutes that guess into \(f(x)\) (the “trial”), and then sees how far the left\sphinxhyphen{}hand side is from zero.

\sphinxAtStartPar
The program then changes \(x\) based on the error, and tries out a new guess in \(f(x)\).

\sphinxAtStartPar
The procedure continues until \(f(x) \simeq 0\) to some desired level of precision, or until the changes in \(x\) are insignificant, or if the search seems endless.


\subsection{Trial\sphinxhyphen{}and\sphinxhyphen{}error Roots via Bisection}
\label{\detokenize{Chapters/Chapter6/Chapter6:trial-and-error-roots-via-bisection}}
\sphinxAtStartPar
The most elementary example of trial\sphinxhyphen{}and\sphinxhyphen{}error root finding is the \sphinxstyleemphasis{bisection algorithm}. It is reliable, but slow.

\sphinxAtStartPar
If you know some interval in which \(f(x)\) changes sign, then the bisection algorithm will always converge to the root by finding progressively smaller and smaller intervals within which the zero lies.

\sphinxAtStartPar
The bisection algorithm can be described as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Start with two values of \(x\) between which we know a zero occurs. For example, you may determine these by making a graph, or by stepping through different values of \(x\) and looking for a sign change.

\item {} 
\sphinxAtStartPar
Let’s then say that \(f(x)\) changes sign from \(x_1\) to \(x_2\), e.g. if \(f(x_1) < 0\) then \(f(x_2) > 0\). The bisection algorithm chooses a new \(x\) as the bisection of the interval (i.e. the mid point!), and selects as its new interval the half in which the sign change occurs.

\item {} 
\sphinxAtStartPar
The process continues until the value of \(f(x)\) is less than a predefined level of precision, or until a predefined (large) number of subdivisions occurs.

\end{itemize}

\sphinxAtStartPar
Let’s implement the bisection algorith and use it in a concrete example!


\subsection{Example 6.1: Temperature Dependence of Magnetization.}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-1-temperature-dependence-of-magnetization}}
\sphinxAtStartPar
The magnetization of \(N\) spin\sphinxhyphen{}1/2 particles, each with magnetic moment \(\mu\) at a temperature \(T\), in an external magnetic field \(B\) is given by:

\sphinxAtStartPar
\(m(t) = \tanh\left(\frac{ m(t) }{ t } \right)\),

\sphinxAtStartPar
where \(m(t)\) is the “reduced” magnetization and \(t\) is the “reduced” temperature.

\sphinxAtStartPar
{[}For the sake of completeness: \(m(T) = M(T)/(N\mu)\), with \(M\) being the magnetization, \(t=T/T_c\), with \(T\) being the temperaturem, and \(T_c = N \mu^2 \lambda / k_B\) the Curie temperature.{]}

\sphinxAtStartPar
Our goal is to find the reduced magnetization \(m\), for various reduced temperatures: \(t=0.5, 1.0, 2.0\). We will use the bisection method to solve the \sphinxstyleemphasis{transcendetal} equation for \(m(t)\).

\sphinxAtStartPar
We should start by plotting the function that we wish to find the zero of, i.e. \(f(m) = \tanh(m/t) - m\), to get an indication of the location of the zeros. It will be clear that there are no zeros for some of the values. For those that there will be zeros, let’s find the solution to a precision of \(\mathcal{O}(10^{-10})\). Let’s also print the number of iterations necessary to achieve this.


\section{Newton\sphinxhyphen{}Raphson Searching}
\label{\detokenize{Chapters/Chapter6/Chapter6:newton-raphson-searching}}
\sphinxAtStartPar
The Newton\sphinxhyphen{}Raphson algorithm finds approximate roots of equations of the same type, \(f(x)=0\), more quickly than the bisection method.

\sphinxAtStartPar
The algorithm is the equivalent of drawing a straight line \(f(x) \simeq mx + b\), tangent to the curve at an \(x\) value for which \(f(x) \simeq 0\) and then using the intrercept of the line with the \(x\)\sphinxhyphen{}axis at \(x=-b/m\) as an improved guess for the root.

\sphinxAtStartPar
If the curve was in fact a straight line, the answer would be exact. Otherwise it is a good approximation if the guess is close enough to the root for \(f(x)\) to be nearly linear.

\sphinxAtStartPar
The process continues until some set level of precision is reached.

\sphinxAtStartPar
If a guess is in a region where \(f(x)\) is nearly linear, then the convergence is much more rapid than for the bisection algorithm.

\sphinxAtStartPar
The formulation of the Newton\sphinxhyphen{}Raphson algorithm is as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Start with a guess \(x_0\),

\item {} 
\sphinxAtStartPar
Find the tangent line to \(f(x)\) at \(x_0\) via:
\(y = f(x_0) + (x-x_0) \left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0}\).

\item {} 
\sphinxAtStartPar
This line crosses the axis at: \(f(x_0) + (x-x_0) \left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0} = 0\).

\item {} 
\sphinxAtStartPar
Solving for \(x\): \(x= x_0 - f(x_0)/\left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0}\). This will be the new guess.

\item {} 
\sphinxAtStartPar
The procedure is repeated until some level of precision is reached, or a maximum number of evaluations.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Now plot! Don\PYGZsq{}t forget the different labels! }
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}f(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label. Note that the \PYGZsq{}r\PYGZsq{} is necessary to remove the need for double slashes. You can use LaTeX! }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The Newton\PYGZhy{}Raphson Method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} construct the variable: }
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{3.5}\PYG{p}{,}\PYG{l+m+mi}{350}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} and the function:}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}f(x)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{3.0}
\PYG{n}{y0} \PYG{o}{=} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}
\PYG{n}{x1} \PYG{o}{=} \PYG{n}{x0} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x0}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x0}\PYG{p}{)}
\PYG{n}{y1} \PYG{o}{=} \PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}
\PYG{n}{x2} \PYG{o}{=} \PYG{n}{x1} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x1}\PYG{p}{)}
\PYG{n}{y2} \PYG{o}{=} \PYG{n}{x2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{y1}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{y2}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{y0}\PYG{o}{+}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}x\PYGZus{}0\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{y1}\PYG{o}{+}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}x\PYGZus{}1\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{n}{x2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{y2}\PYG{o}{+}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}x\PYGZus{}2\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{n}{y0} \PYG{o}{+} \PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x0}
\PYG{n}{y2} \PYG{o}{=} \PYG{n}{y1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{x1}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x1}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y2}\PYG{p}{,}\PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} draw horizontal line passing through zero}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{n}{xmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{xmax}\PYG{o}{=}\PYG{l+m+mf}{3.2}\PYG{p}{,}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} draw first vertical line to indicate x\PYGZus{}1:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{n}{ymin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ymax}\PYG{o}{=}\PYG{n}{y1}\PYG{p}{,}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{3.2}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the grid. }

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{c+c1}{\PYGZsh{} Now plot! Don\PYGZsq{}t forget the different labels! }

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}matplotlib\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It’s clear that the Newton\sphinxhyphen{}Raphson algorithm requires the evaluation of the derivative of the function at the guess point \(x_0\), i.e. \(\left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0}\).

\sphinxAtStartPar
In many cases you may have an analytic expression for the derivative, and it can be built into the algorithm.

\sphinxAtStartPar
However, it is simpler to use a numerical approximation to the derivative, e.g. using the forward\sphinxhyphen{}difference derivative:

\sphinxAtStartPar
\(  \frac{ \mathrm{d} f}{\mathrm{d} x} \approx \frac{ f(x+\delta x) - f(x) } { \delta x}\).

\sphinxAtStartPar
A central\sphinxhyphen{}difference derivative can also be used, but it would require additional evaluations of the function.


\section{Newton\sphinxhyphen{}Raphson with Backtracking}
\label{\detokenize{Chapters/Chapter6/Chapter6:newton-raphson-with-backtracking}}
\sphinxAtStartPar
Potential problems may arise while performing Newton\sphinxhyphen{}Raphson searching:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The search can take us to an \(x\) value where the function has a local minimum or maximum, i.e.: \(\mathrm{d}f/\mathrm{d} x = 0\). This would lead to a horizontal tangent and then the next guess would be \(x \rightarrow \infty\), which is hard to return from!

\item {} 
\sphinxAtStartPar
The search can fall into an infinite loop surrounding the zero without ever getting there.

\end{itemize}

\sphinxAtStartPar
The problem in both cases is that the initial guess is not close enough to a region where the function is approximately linear. This is why a good plot may help produce a good first guess.

\sphinxAtStartPar
When the above occur, you may need to start your initial guess (\(x_0\)) at a different point in an effort not to fall in these traps, or try \sphinxstyleemphasis{backtracking}.

\sphinxAtStartPar
\sphinxstylestrong{Backtracking}: in cases where the new guess leads to an \sphinxstyleemphasis{increase} in the magnitude of the function, i.e. \(|f(x_0 + \Delta x)|^2 > |f(x_0)|^2\), you can backtrack somewhat and try a smaller step, say \(x_0 + \Delta x / 2\). If the magnitude still increases, then backtrack some more, say by trying \(x_0 + \Delta x / 4\), and so on.

\sphinxAtStartPar
An alternative solution: start with a bisection search algorithm and switch to faster Newton\sphinxhyphen{}Raphson when you get closer to zero.


\subsection{Example 6.2: Newton\sphinxhyphen{}Raphson applied to the Temperature Dependence of Magnetization.}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-2-newton-raphson-applied-to-the-temperature-dependence-of-magnetization}}
\sphinxAtStartPar
Implement the Newton\sphinxhyphen{}Raphson search algorithm to find the root of the Transcendental equation given in Example 6.1 for \(t=0.5\) and a precision of \(\mathcal{O}(10^{-10})\). Use a central\sphinxhyphen{}difference derivative while implementing the algorithm and print the number of iterations.


\section{Matrix Computing}
\label{\detokenize{Chapters/Chapter6/Chapter6:matrix-computing}}

\subsection{Why Matrix Computing?}
\label{\detokenize{Chapters/Chapter6/Chapter6:why-matrix-computing}}
\sphinxAtStartPar
Physical systems are often modeled by systems of simultaneous equations that can be written in matrix form.

\sphinxAtStartPar
As models are made more realistic, matrices become correspondingly bigger. It is therefore important to use a good linear algebra library.

\sphinxAtStartPar
“Industrial\sphinxhyphen{}strength” subroutines for matrix computing can be found in well\sphinxhyphen{}established scientific libraries. They can be an order of magnitude or more faster than elementary methods found in linear algebra texts.

\sphinxAtStartPar
These packages are usually designed to minimize the round\sphinxhyphen{}off error and they are robust, i.e. they have a high chance of being successful for a broad class of problems.

\sphinxAtStartPar
The question is, when is a matrix large enough to require the use of a library routine? A rule of thumb is: “when you have to wait for the answer!”.

\sphinxAtStartPar
Note that GPUs (Graphics Processing Units) can perform matrix algebra very efficiently, since they can execute many commands in parallel. This requires programming in specific frameworks, but it’s good to keep in mind at this point.


\subsection{Classes of Matrix Problems}
\label{\detokenize{Chapters/Chapter6/Chapter6:classes-of-matrix-problems}}
\sphinxAtStartPar
The most basic matrix problem: a system of linear equations, e.g.:

\sphinxAtStartPar
\(\mathbf{A} \vec{x} = \vec{b}\),

\sphinxAtStartPar
where \(\mathbf{A}\) is an \(N\times N\) matrix, \(\vec{x}\) is an \sphinxstyleemphasis{unknown} vector of length \(N\), and \(\vec{b}\) is a known vector of length \(N\).

\sphinxAtStartPar
The obvious way to solve this: determine the inverse of \(\mathbf{A}\), \(\mathbf{A}^{-1}\), and multiply both sides of the equation by it to obtain \(\vec{x}\):

\sphinxAtStartPar
\( \vec{x} = \mathbf{A}^{-1} \vec{b}\).

\sphinxAtStartPar
Calculating the inverse of a matrix is a standard in a matrix subroutine library.

\sphinxAtStartPar
A more efficient way to solve the linear equation is by Gaussian elimination or lower\sphinxhyphen{}upper (LU) decomposition. Both of these yield \(\vec{x}\) without \(\mathbf{A}^{-1}\). (However, sometimes you may want the inverse of a matrix.)

\sphinxAtStartPar
Another form of matrix problems that is frequently encountered is:

\sphinxAtStartPar
\(\mathbf{A} \vec{x} = \lambda \vec{x}\),

\sphinxAtStartPar
with an unknown vector \(\vec{x}\) and an unknown parameter \(\lambda\). This is an \sphinxstyleemphasis{eigenvalue problem}. Solutions only exist for certain (if any) values of \(\lambda\). To find a solution, we can use the identity matrix, \(\mathbf{I}\), to rewrite the equation as follows:

\sphinxAtStartPar
\([\mathbf{A} - \lambda \mathbf{I}]\vec{x} = 0\).

\sphinxAtStartPar
which yields a non\sphinxhyphen{}trivial solution only if the determinant of \([\mathbf{A} - \lambda \mathbf{I}]\) is zero, i.e.:

\sphinxAtStartPar
\(\det[\mathbf{A} - \lambda \mathbf{I}] = 0\).

\sphinxAtStartPar
This is known as the “secular equation”. The values of \(\lambda\) that satisfy this equation are the eigenvalues of the eigenvalue equation.

\sphinxAtStartPar
The traditional way to solve the eigenvalue problem for both eigenvalues and eigenvectors is by \sphinxstyleemphasis{diagonalization} via a transformation matrix \(\mathbf{U}\):

\sphinxAtStartPar
\(\mathbf{U} \mathbf{A} (\mathbf{U}^{-1} \mathbf{U})\vec{x} = \lambda \mathbf{U} \vec{x}\),

\sphinxAtStartPar
\((\mathbf{U} \mathbf{A} \mathbf{U}^{-1}) \mathbf{U}\vec{x} = \lambda \mathbf{U} \vec{x}\),

\sphinxAtStartPar
where \(\mathbf{U} \mathbf{A} \mathbf{U}^{-1} \equiv \mathbf{D}\) is a diagonal matrix:

\sphinxAtStartPar
\( \mathbf{D} = \mathbf{U} \mathbf{A} \mathbf{U}^{-1} = \left(\begin{array}{ccccc} 
\lambda_1' & 0 & 0 & ... & 0\\
0 & \lambda_2' & 0 & ... & 0\\
0 & 0 & \lambda_3' & ... & 0\\
0 & 0 & 0 & ... & \lambda_N'
\end{array}\right)\),

\sphinxAtStartPar
whose diagonal entries are the eigenvalues, corresponding to eigenvectors:

\sphinxAtStartPar
\(\vec{x}_i = \mathbf{U}^{-1} \hat{\vec{e}}_i\),

\sphinxAtStartPar
i.e. the eigenvectors are the columns of the matrix \(\mathbf{U}^{-1}\).


\subsection{Math Recap: Matrix Multiplication, Inverses and Determinants}
\label{\detokenize{Chapters/Chapter6/Chapter6:math-recap-matrix-multiplication-inverses-and-determinants}}
\sphinxAtStartPar
Matrix Multiplication:

\sphinxAtStartPar
To multiply two matrices \(\mathbf{A}\) and \(\mathbf{B}\):

\sphinxAtStartPar
\( \mathbf{A} =  \left(\begin{array}{ccc} 
a_{00} & a_{01} & a_{02} \\
a_{10} & a_{11} & a_{12} \\
a_{20} & a_{21} & a_{22}
\end{array}\right)\),

\sphinxAtStartPar
\( \mathbf{B} =  \left(\begin{array}{ccc} 
b_{00} & b_{01} & b_{02} \\
b_{10} & b_{11} & b_{12} \\
b_{20} & b_{21} & b_{22}
\end{array}\right)\),

\sphinxAtStartPar
then:

\sphinxAtStartPar
\(\mathbf{A}\mathbf{B} = \left(\begin{array}{ccc} 
a_{00} b_{00} + a_{01}b_{10} + a_{02} b_{20} & a_{00} b_{01} + a_{01}b_{11} + a_{02} b_{21} & a_{00} b_{02} + a_{01}b_{12} + a_{02} b_{22} \\
a_{10} b_{00} + a_{11}b_{10} + a_{12} b_{20} & a_{10} b_{01} + a_{11}b_{11} + a_{12} b_{21} & a_{10} b_{02} + a_{11}b_{12} + a_{12} b_{22} \\
a_{20} b_{00} + a_{21}b_{10} + a_{22} b_{20} & a_{20} b_{01} + a_{21}b_{11} + a_{22} b_{21} & a_{20} b_{02} + a_{21}b_{12} + a_{22} b_{22} \\
\end{array}\right)\),

\sphinxAtStartPar
{[}See \sphinxurl{https://www.geogebra.org/m/ETHXK756} for an animation!{]}

\sphinxAtStartPar
Matrix Determinants:

\sphinxAtStartPar
The determinant of a matrix \( \mathbf{A} =  \left(\begin{array}{ccc} 
a_{00} & a_{01} & a_{02} \\
a_{10} & a_{11} & a_{12} \\
a_{20} & a_{21} & a_{22}
\end{array}\right)\),

\sphinxAtStartPar
is given by:

\sphinxAtStartPar
\(\det[A] = a_{00} (a_{11} a_{22} - a_{21} a_{12}) - a_{01} ( a_{01} a_{22} - a_{20} a_{12} ) - a_{02} ( a_{10} a_{21} - a_{20} a_{11} )\)

\sphinxAtStartPar
Matrix Inversion (Cramer’s rule):

\sphinxAtStartPar
To invert the matrix \(\mathbf{A}\) as defined above we first need the determinant and the matrix of cofactors:

\sphinxAtStartPar
\(\mathbf{C} = \left(\begin{array}{ccc} 
a_{11} a_{22} - a_{21} a_{12} & a_{20} a_{12} - a_{10} a_{22} & a_{10} a_{21} - a_{20} a_{11} \\
a_{21} a_{02} - a_{01} a_{22} & a_{00} a_{22} - a_{20} a_{02} & a_{20} a_{01} - a_{00} a_{21} \\
a_{01} a_{12} - a_{11} a_{02} & a_{20} a_{02} - a_{00} a_{22} & a_{00} a_{11} - a_{10} a_{01}
\end{array}\right)\),

\sphinxAtStartPar
and then the inverse is given by:

\sphinxAtStartPar
\(\mathbf{A}^{-1} = \frac{1}{\det[A]} \mathbf{C}^T\), where the superscript \(T\) denotes a transposition, i.e. an exchange of rows and columns.


\subsection{Example 6.3: In this problem we will find the inverse of a 3x3 matrix \sphinxstyleemphasis{analytically} and show via direct matrix multiplication that it indeed gives back the identity matrix.}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-3-in-this-problem-we-will-find-the-inverse-of-a-3x3-matrix-analytically-and-show-via-direct-matrix-multiplication-that-it-indeed-gives-back-the-identity-matrix}}
\sphinxAtStartPar
(a) Find the determinant of the matrix:

\sphinxAtStartPar
\( \mathbf{A} =  \left(\begin{array}{ccc} 
+4 & -2 & +1 \\
+3 & +6 & -4 \\
+2 & +1 & +8
\end{array}\right)\).

\sphinxAtStartPar
(b) Find the inverse of \(\mathbf{A}\).

\sphinxAtStartPar
(c) Check that the inverse indeed satisfies \(\mathbf{A}^{-1} \mathbf{A} = \mathbf{I}\).


\subsection{Math Recap: Solving Eigenvalue Problems}
\label{\detokenize{Chapters/Chapter6/Chapter6:math-recap-solving-eigenvalue-problems}}
\sphinxAtStartPar
To find the eigenvalues of a matrix we first subtract \(\lambda\) from its diagonal, take the determinant and set it to zero. We then solve the resulting characteristic equation.

\sphinxAtStartPar
E.g. for a 2x2 matrix,

\sphinxAtStartPar
\( \mathbf{A} =  \left(\begin{array}{cc} 
a_{00} & a_{01} \\
a_{10} & a_{11} \\
\end{array}\right)\),

\sphinxAtStartPar
the characteristic equation is:

\sphinxAtStartPar
\(\det\left(\begin{array}{cc} 
a_{00} - \lambda & a_{01} \\
a_{10} & a_{11} - \lambda \\
\end{array}\right) = 0 \)

\sphinxAtStartPar
or:

\sphinxAtStartPar
\((a_{00} - \lambda) (a_{11} - \lambda) - a_{01} a_{10} = 0\)

\sphinxAtStartPar
To find the eigenvectors, i.e. the vectors that satisfy:

\sphinxAtStartPar
\(\mathbf{A} \vec{x}_i = \lambda_i \vec{x}_i\), where \(\lambda_i\) is the \(i\)\sphinxhyphen{}th eigenvalue, we can write:

\sphinxAtStartPar
\(\vec{x}_i = \left(\begin{array}{c} 
x_i \\
y_i \\
\end{array}\right) \)

\sphinxAtStartPar
and then operate with \(\mathbf{A} - \lambda_i \mathbf{I}\)

\sphinxAtStartPar
\(\mathbf{A} -  \lambda_i \mathbf{I} = \left(\begin{array}{cc} 
a_{00} - \lambda_i & a_{01} \\
a_{10} & a_{11} - \lambda_i \\
\end{array}\right) \):

\sphinxAtStartPar
\(\left(\begin{array}{cc} 
a_{00} - \lambda_i & a_{01} \\
a_{10} & a_{11} - \lambda_i \\
\end{array}\right) \left(\begin{array}{c} 
x_i  \\
y_i  \\
\end{array}\right)  = \left(\begin{array}{c} 
0  \\
0  \\
\end{array}\right) \), to get:

\sphinxAtStartPar
\((a_{00} - \lambda_i) x_i + a_{01} y_i = 0\)

\sphinxAtStartPar
and:

\sphinxAtStartPar
\(a_{10} x_i + (a_{11} - \lambda_i) y_i = 0\),

\sphinxAtStartPar
allowing us to find relations between \(x_i\) and \(y_i\), i.e. the components of the \(i\)\sphinxhyphen{}th eigenvector. The eigenvectors can then be normalized to unity.

\sphinxAtStartPar
Let’s find the eigenvectors and eigenvalues in a concrete example.


\subsection{Example 6.4: Find the eigenvalues and eigenvectors of the matrix:}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-4-find-the-eigenvalues-and-eigenvectors-of-the-matrix}}
\sphinxAtStartPar
\(\mathbf{A} = \left(\begin{array}{cc} 
\alpha & \beta \\
-\beta & \alpha \\
\end{array}\right)\)


\subsection{Example 6.5: Given that \textbackslash{}lambda\_1 = 5 is an eigenvalue, find the remaining eigenvalues of the matrix:}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-5-given-that-lambda-1-5-is-an-eigenvalue-find-the-remaining-eigenvalues-of-the-matrix}}
\sphinxAtStartPar
\( \mathbf{A} =  \left(\begin{array}{ccc} 
-2 & +2 & -3 \\
+2 & +1 & -6 \\
-1 & -2 & 0
\end{array}\right)\)

\sphinxAtStartPar
We will tackle these, and other problems, with Python numerical packages shortly!


\section{Practical Matrix Computing}
\label{\detokenize{Chapters/Chapter6/Chapter6:practical-matrix-computing}}
\sphinxAtStartPar
Many scientific programming bugs arise from improper use of arrays.

\sphinxAtStartPar
These may be a result of the extensive use of matrices, or to the complexity of keeping track of indices and dimensions. Here are some rules of thumb to observe!
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Computers are finite}: Be careful with matrix memory usage! E.g. if you are storing data in a 4\sphinxhyphen{}dimensional array, with each index having a physical dimension of 100, e.g. \sphinxcode{\sphinxupquote{A{[}100{]}{[}100{]}{[}100{]}{[}100{]}}}, then this array will take up \((100)^4\) 64\sphinxhyphen{}byte words \(\simeq 1\) GB of memory! Note that modern computers typically have 8\sphinxhyphen{}64 GB of memory (RAM).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Processing time}: Matrix operations such as inversion require on the order of \(N^3\) steps for a square matrix of dimension \(N\) (number of rows \(\times\) number of columns). E.g. doubling the dimensions of a matrix results in an eightfold increase in the processing time.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Matrix Storage}: We think of matrices as multi\sphinxhyphen{}dimensional blocks of stored numbers, but the computer stores them as linear strings. For instance, a matrix \sphinxcode{\sphinxupquote{a{[}3,3{]}}} in Python is stored in a row\sphinxhyphen{}major order:

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a00 a01 a02 a10 a11 a12 a20 a21 a22}}

\sphinxAtStartPar
while in Fortran it is stored in a column\sphinxhyphen{}major order:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a01 a10 a20 a01 a11 a21 a02 a12 a22}}

\sphinxAtStartPar
It is important to keep this in mind in order to write proper code which permits the mixing of Python and Fortran programs!
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Tests} Always test a library routine on a small problem whose answer you already know. Then you will know if you are using the routine correctly.

\end{itemize}


\section{Matrices in Python: Python Lists, NumPy Arrays}
\label{\detokenize{Chapters/Chapter6/Chapter6:matrices-in-python-python-lists-numpy-arrays}}

\subsection{Python Lists}
\label{\detokenize{Chapters/Chapter6/Chapter6:python-lists}}
\sphinxAtStartPar
Lists contain sequences of objects that are \sphinxstyleemphasis{mutable} (i.e. changeable) .

\sphinxAtStartPar
Python also has a builtin type called a \sphinxstyleemphasis{tuple}. Its elements are \sphinxstyleemphasis{not} mutable. (See Chapter 1).

\sphinxAtStartPar
Most programming languages require you to specify the size of an array before you can start storing objects in it. On the other hand, Python lists are dynamic, i.e. their sizes are adjusted as needed.

\sphinxAtStartPar
Compound lists can be created in Python by having the individual elements themselves as lists.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Lists are mutable:}
\PYG{n}{VectorA} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{VectorA}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{c+c1}{\PYGZsh{} we are changing the last element from 3 \PYGZhy{}\PYGZgt{} 4}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{VectorA}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 2, 4]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} On the other hand, tuples are not:}
\PYG{n}{TupleB} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{TupleB}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{3}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} On the other hand, tuples are not:}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{n}{TupleB} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{n}{TupleB}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{n+ne}{TypeError}: \PYGZsq{}tuple\PYGZsq{} object does not support item assignment
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{NumPy Arrays}
\label{\detokenize{Chapters/Chapter6/Chapter6:numpy-arrays}}
\sphinxAtStartPar
Python lists are rather limited. Instead it is recommended to use NumPy arrays for actual mathematical manipulations involving matrices.

\sphinxAtStartPar
NumPy Arrays:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Can hold up to 32 dimensions!

\item {} 
\sphinxAtStartPar
But each element must be of the same type, i.e. the array has to be “uniform”.

\item {} 
\sphinxAtStartPar
Elements are not resticted to be floats or integers, but can be any ojbect, as long as the elements are of the same type.

\item {} 
\sphinxAtStartPar
The data types can be compound.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s construct NumPy arrays}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} a NumPy array:}
\PYG{n}{NumpyVectorA} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{NumpyVectorA}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} a compound NumPy array: }
\PYG{n}{NumpyVectorB} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{NumpyVectorB}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A= [1 2 3]
B= [[\PYGZsq{}a\PYGZsq{} \PYGZsq{}1\PYGZsq{}]
 [\PYGZsq{}b\PYGZsq{} \PYGZsq{}2\PYGZsq{}]
 [\PYGZsq{}c\PYGZsq{} \PYGZsq{}3\PYGZsq{}]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Multiply a matrix by a number multiplies each element by that number:}
\PYG{c+c1}{\PYGZsh{} e.g.:}
\PYG{n}{NumpyVectorA2} \PYG{o}{=} \PYG{n}{NumpyVectorA} \PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A*2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{NumpyVectorA2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A*2= [2 4 6]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} .shape tells you the shape of an array}
\PYG{c+c1}{\PYGZsh{} e.g.:}
\PYG{n}{NumpyMatrixC} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The shape of NumpyMatrixC is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{NumpyMatrixC}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} or:}
\PYG{n}{NumpyMatrixD} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The shape of NumpyMatrixD is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{NumpyMatrixD}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} and .ndim tells you the number of dimensions:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The number of dimensions for NumpyMatrixD is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{NumpyMatrixD}\PYG{o}{.}\PYG{n}{ndim}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add a dimension:}
\PYG{n}{NumpyMatrixE} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{NumpyMatrixD}\PYG{p}{,} \PYG{n}{NumpyMatrixD}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The number of dimensions for NumpyMatrixE is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{NumpyMatrixE}\PYG{o}{.}\PYG{n}{ndim}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The shape of NumpyMatrixC is (3, 2)
The shape of NumpyMatrixD is (3, 3)
The number of dimensions for NumpyMatrixD is 2
The number of dimensions for NumpyMatrixE is 3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} you can get the transpose by the .T operation: }
\PYG{c+c1}{\PYGZsh{} e.g.:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NumpyMatrixD=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{NumpyMatrixD}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NumpyMatrixD transposed=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{NumpyMatrixD}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
NumpyMatrixD= [[1 2 7]
 [3 4 8]
 [5 6 9]]
NumpyMatrixD transposed= [[1 3 5]
 [2 4 6]
 [7 8 9]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To obtain a matrix product from two arrays, you should use the dot function. The * operator between two arrays is used for an element\sphinxhyphen{}by\sphinxhyphen{}element product.

\sphinxAtStartPar
E.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Element\PYGZhy{}wise multiplication: }
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{NumpyMatrixD} \PYG{o}{*} \PYG{n}{NumpyMatrixD}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[ 1  4 49]
 [ 9 16 64]
 [25 36 81]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Matrix Multiplication:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{NumpyMatrixD}\PYG{p}{,}\PYG{n}{NumpyMatrixD}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[ 42  52  86]
 [ 55  70 125]
 [ 68  88 164]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A major power in NumPy comes from its \sphinxstyleemphasis{broadcasting} operation, an operation in which values are assigned to multiple elements via a single assignment statement.

\sphinxAtStartPar
Broadcasting permits Python to \sphinxstyleemphasis{vectorize} array operations, which means that the same operation can be performed on different array elements in parallel (or nearly so).

\sphinxAtStartPar
Broadcasting also speeds up processing because array operations occur in C instead of Python, and with a minimum of array copies being made.

\sphinxAtStartPar
You’ve already been using broadcasting, e.g. when you did the following:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} broadcasting via NumPy is done here }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{NumPy’s linalg Package}
\label{\detokenize{Chapters/Chapter6/Chapter6:numpy-s-linalg-package}}
\sphinxAtStartPar
NumPy’s linalg package treates 2D arrays (1D arrays of 1D arrays) as mathematical matrices, and provides an interface to the powerful LAPACK linear algebra library.

\sphinxAtStartPar
There is much to be gained in speed and reliability from using these libraries, rather than writing your own matrix routines.

\sphinxAtStartPar
As a first example, let’s look at the standard matrix equation:

\sphinxAtStartPar
\(\mathbf{A} \vec{x} = \vec{b}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{c+c1}{\PYGZsh{} import the linear algebra package }

\PYG{c+c1}{\PYGZsh{} define the array A:}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{55}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]} \PYG{p}{]}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define the vector b:}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} now solve using linalg\PYGZsq{}s solve:}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A= [[  1   2   3]
 [ 22  32  42]
 [ 55  66 100]]
b= [1 2 3]
x= [\PYGZhy{}1.4057971  \PYGZhy{}0.1884058   0.92753623]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can print the residual of the operation \(\mathbf{A} \vec{x} - \vec{b}\) to check how far we are from zero!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ax\PYGZhy{}b=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Ax\PYGZhy{}b= [ 0.00000000e+00 \PYGZhy{}2.66453526e\PYGZhy{}15 \PYGZhy{}5.32907052e\PYGZhy{}15]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Very close to zero indeed!

\sphinxAtStartPar
We have solved entire set of linear equations (by elimination) with just a single command, performed a matrix multiplication with the single command \sphinxcode{\sphinxupquote{dot}}, did a matrix subtraction, and are left with a residual equal to machine precision!

\sphinxAtStartPar
Although there are more efficient numerical approaches, a direct way to solve the equation is to calculate the inverse of \(\mathbf{A}\), and then multiply both sides of the equation by the inverse, yielding

\sphinxAtStartPar
\(\vec{x} = \mathbf{A}^{-1} \vec{b}\).

\sphinxAtStartPar
Let’s follow this approach as well!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{c+c1}{\PYGZsh{} import the linear algebra package }

\PYG{c+c1}{\PYGZsh{} define the array A:}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{55}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]} \PYG{p}{]}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define the vector b:}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the inverse using the linear algebra package:}
\PYG{n}{invA} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{invA}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} test the inverse:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A.A\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{invA}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} solve the equation:}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{invA}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A= [[  1   2   3]
 [ 22  32  42]
 [ 55  66 100]]
b= [1 2 3]
A\PYGZca{}\PYGZob{}\PYGZhy{}1\PYGZcb{}= [[\PYGZhy{}1.55072464  0.00724638  0.04347826]
 [\PYGZhy{}0.39855072  0.23550725 \PYGZhy{}0.08695652]
 [ 1.11594203 \PYGZhy{}0.15942029  0.04347826]]
A.A\PYGZca{}\PYGZob{}\PYGZhy{}1\PYGZcb{}= [[1.00000000e+00 2.77555756e\PYGZhy{}17 6.93889390e\PYGZhy{}18]
 [7.54951657e\PYGZhy{}15 1.00000000e+00 3.74700271e\PYGZhy{}16]
 [1.86517468e\PYGZhy{}14 5.55111512e\PYGZhy{}16 1.00000000e+00]]
x= [\PYGZhy{}1.4057971  \PYGZhy{}0.1884058   0.92753623]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Same as via the direct method, as expected!

\sphinxAtStartPar
The second type of matrix equation we wish to solve is the eigenvalue equation:

\sphinxAtStartPar
\(\mathbf{I} \vec{\omega} = \lambda \vec{\omega}\),

\sphinxAtStartPar
where in this case, e.g. \(\mathbf{I}\) is the inertia matrix (or tensor) and \(\omega\) is an unknown eigenvector, \(\lambda\) is the unknown eigenvalue.

\sphinxAtStartPar
Then, e.g.:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{linalg}

\PYG{c+c1}{\PYGZsh{} the moment of inertia tensor:}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{I}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the eigenvectors and eigenvalues:}
\PYG{n}{evalues}\PYG{p}{,} \PYG{n}{evectors} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eigenvalues=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{evalues}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eigenvectors=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{evectors}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I= [[ 0.66666667 \PYGZhy{}0.25      ]
 [ 0.25        0.66666667]]
Eigenvalues= [0.66666667+0.25j 0.66666667\PYGZhy{}0.25j]
Eigenvectors= [[0.70710678+0.j         0.70710678\PYGZhy{}0.j        ]
 [0.        \PYGZhy{}0.70710678j 0.        +0.70710678j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Example 6.6: Solve Examples 6.3 to 6.5 numerically!}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-6-solve-examples-6-3-to-6-5-numerically}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{linalg}

\PYG{c+c1}{\PYGZsh{} Example 6.3:}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{+}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{detA} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{detA=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{detA}\PYG{p}{)}
\PYG{n}{invA} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{invA}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A.A\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{invA}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
detA= 262.99999999999983
A\PYGZca{}\PYGZob{}\PYGZhy{}1\PYGZcb{}= [[ 0.19771863  0.06463878  0.00760456]
 [\PYGZhy{}0.121673    0.11406844  0.07224335]
 [\PYGZhy{}0.03422053 \PYGZhy{}0.03041825  0.11406844]]
A.A\PYGZca{}\PYGZob{}\PYGZhy{}1\PYGZcb{}= [[ 1.00000000e+00  1.38777878e\PYGZhy{}17  0.00000000e+00]
 [\PYGZhy{}5.55111512e\PYGZhy{}17  1.00000000e+00  0.00000000e+00]
 [ 5.55111512e\PYGZhy{}17  0.00000000e+00  1.00000000e+00]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Example 6.4: Pick numbers alpha = 1, beta = 2:}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{linalg}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the eigenvectors and eigenvalues:}
\PYG{n}{evalues}\PYG{p}{,} \PYG{n}{evectors} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eigenvalues=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{evalues}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eigenvectors=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{evectors}\PYG{o}{.}\PYG{n}{T}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{evectors}\PYG{o}{.}\PYG{n}{T}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Eigenvalues= [1.+2.j 1.\PYGZhy{}2.j]
Eigenvectors= [0.        \PYGZhy{}0.70710678j 0.70710678+0.j        ] [0.        +0.70710678j 0.70710678\PYGZhy{}0.j        ]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Example 6.5}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} to access elements, e.g. 0,0:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{evalues}\PYG{p}{,} \PYG{n}{evectors} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eigenvalues=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{evalues}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eigenvectors=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{evectors}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}2
Eigenvalues= [\PYGZhy{}3.  5. \PYGZhy{}3.]
Eigenvectors= [[\PYGZhy{}0.95257934  0.40824829  0.05155221]
 [ 0.27216553  0.81649658  0.82292764]
 [\PYGZhy{}0.13608276 \PYGZhy{}0.40824829  0.5658025 ]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{N\sphinxhyphen{}Dimensional Newton\sphinxhyphen{}Raphson}
\label{\detokenize{Chapters/Chapter6/Chapter6:n-dimensional-newton-raphson}}
\sphinxAtStartPar
Using what we have learned thus far about matrix computing, we can solve, numerically, any system of \(N\) coupled \sphinxstyleemphasis{linear} equations, e.g. by directly asking NumPy’s linalg package to solve:

\sphinxAtStartPar
\(\mathbf{A} \vec{x} = \vec{b}\).

\sphinxAtStartPar
What about a system of \(N\) \sphinxstyleemphasis{nonlinear} equations?

\sphinxAtStartPar
This can also be solved numerically, by combining matrix computing with our methods for searching for roots to equations, such as the Newton\sphinxhyphen{}Raphson method.

\sphinxAtStartPar
Let’s discuss the general technique for achieving this, and then apply it to a concrete example in statics.

\sphinxAtStartPar
Let’s suppose that our system of \(N\) equations can be written in terms of \(N\) unknowns, \(x_i\), \(i=1,2,...,N\).

\sphinxAtStartPar
We can write all of these unknowns in a single column vector:

\sphinxAtStartPar
\(\vec{x} = \left(\begin{array}{ccc} 
x_{1}  \\
x_{2}  \\
\cdots \\
x_{N} 
\end{array}\right)\)

\sphinxAtStartPar
and then the \(N\) equations can be written as functions of \(\vec{x}\) as:

\sphinxAtStartPar
\(f_i(x_1, x_2, ..., x_N) = 0\)

\sphinxAtStartPar
or:

\sphinxAtStartPar
\(f_i(\vec{x}) = 0\), \(i=1,...,N\).

\sphinxAtStartPar
The solutions to these \(N\) equations are a set of \(N\) values of the \(x_i\) that make the \(f_i\)’s vanish simultaneously.

\sphinxAtStartPar
Our search algorithm will guess a set of \(N\) solutions, expand the nonlinear equations \(f_i\) into linear form, solves the resulting \sphinxstyleemphasis{linear} equations, and continues to improve the guesses, based on how close the previous one was to making all the \(f_i(\vec{x}) = 0\).

\sphinxAtStartPar
Explicitly, let the approximate solutions at any stage be called \(x_i\)’s. To calculate the new set of \(x_i\)’s, \(x_i' = x_i + \Delta x_i\), for which:

\sphinxAtStartPar
\(f_i(x_1 + \Delta x_1, x_2 + \Delta x_2, ..., x_N + \Delta x_N) \approx 0\), \(i=1,...,N\).

\sphinxAtStartPar
or, by Taylor series expansion:

\sphinxAtStartPar
\(f_i(x_1, ..., x_N) + \sum_{j=1}^N \frac{ \partial f_i }{ \partial x_j } \Delta x_j \approx 0\)

\sphinxAtStartPar
we now have a solveble set of \(N\) \sphinxstyleemphasis{linear} equations, in the \(N\) unknown “modifications” to our current solution, \(\Delta x_i\), which we can express as a single matrix equation.

\sphinxAtStartPar
\(f_1 + \frac{ \partial f_1 }{ \partial x_1 } \Delta x_1 + \frac{ \partial f_1 }{ \partial x_2 } \Delta x_2 + ... + \frac{ \partial f_1 }{ \partial x_N } \Delta x_N = 0\)

\sphinxAtStartPar
\(f_2 + \frac{ \partial f_2 }{ \partial x_1 } \Delta x_1 + \frac{ \partial f_2 }{ \partial x_2 } \Delta x_2 + ... + \frac{ \partial f_2 }{ \partial x_N } \Delta x_N = 0\)

\sphinxAtStartPar
\(...\)

\sphinxAtStartPar
\(f_N + \frac{ \partial f_N }{ \partial x_1 } \Delta x_1 + \frac{ \partial f_N }{ \partial x_2 } \Delta x_2 + ... + \frac{ \partial f_N }{ \partial x_N } \Delta x_N = 0\)

\sphinxAtStartPar
or in matrix form:

\sphinxAtStartPar
\(\left(\begin{array}{c} 
f_{1}  \\
f_{2}  \\
\ddots \\
f_{N} 
\end{array}\right) + \left(\begin{array}{cccc} 
\frac{ \partial f_1 }{ \partial x_1 } & \frac{ \partial f_1 }{ \partial x_2 } & ... &  \frac{ \partial f_1 }{ \partial x_N }\\
\frac{ \partial f_2 }{ \partial x_1 } & \frac{ \partial f_2 }{ \partial x_2 } & ... & \frac{ \partial f_2 }{ \partial x_N } \\
\ddots & \ddots &  \ddots & \ddots \\
\frac{ \partial f_N }{ \partial x_1 } & \frac{ \partial f_N }{ \partial x_2 } & ... & \frac{ \partial f_N }{ \partial x_N }
\end{array}\right)\left(\begin{array}{c} 
\Delta x_{1}  \\
\Delta x_{2}  \\
\ddots \\
\Delta x_{N} 
\end{array}\right) = 0\)

\sphinxAtStartPar
The derivatives and the \(f_i\)’s are all evaluated at \sphinxstyleemphasis{known} values of the previous guesses, \(x_i\), so that only the vector of the modifications, \(\Delta x_i\), is unknown.

\sphinxAtStartPar
We may write the above equation in matrix notation as:

\sphinxAtStartPar
\(\vec{f} + \mathbf{J} \Delta \vec{x} = 0\)

\sphinxAtStartPar
where:

\sphinxAtStartPar
\(\vec{f} = \left(\begin{array}{c} 
f_{1}  \\
f_{2}  \\
\ddots \\
f_{N} 
\end{array}\right)\), \(\Delta \vec{x} = \left(\begin{array}{c} 
\Delta x_{1}  \\
\Delta x_{2}  \\
\ddots \\
\Delta x_{N} 
\end{array}\right)\), \(\mathbf{J} = \left(\begin{array}{cccc} 
\frac{ \partial f_1 }{ \partial x_1 } & \frac{ \partial f_1 }{ \partial x_2 } & ... &  \frac{ \partial f_1 }{ \partial x_N }\\
\frac{ \partial f_2 }{ \partial x_1 } & \frac{ \partial f_2 }{ \partial x_2 } & ... & \frac{ \partial f_2 }{ \partial x_N } \\
\ddots & \ddots &  \ddots & \ddots \\
\frac{ \partial f_N }{ \partial x_1 } & \frac{ \partial f_N }{ \partial x_2 } & ... & \frac{ \partial f_N }{ \partial x_N }
\end{array}\right)\),

\sphinxAtStartPar
and where \(\mathbf{J}\) is known as the Jacobian matrix.

\sphinxAtStartPar
Then:

\sphinxAtStartPar
\(\mathbf{J} \Delta \vec{x} = -\vec{f}\).

\sphinxAtStartPar
The above is equivalent to the one\sphinxhyphen{}dimensional Newton\sphinxhyphen{}Raphson formula: \(\Delta x = -(1/f') f\).

\sphinxAtStartPar
Comparing this to the standard matrix form of a system of \(N\) linear equations with \(N\) unknows:

\sphinxAtStartPar
\(\mathbf{A} \vec{x} = \vec{b}\),

\sphinxAtStartPar
we can identify \(\mathbf{A} \rightarrow \mathbf{J}\), \(\vec{x} \rightarrow \Delta \vec{x}\) and \(\vec{b} \rightarrow -\vec{f}\).

\sphinxAtStartPar
This can be solved using the techniques of linear algebra, i.e. in our case, using NumPy’s \sphinxcode{\sphinxupquote{linalg}} module.

\sphinxAtStartPar
Note that the solution of such problems requires either analytical or numerical calculation of the \(N^2\) partial derivatives \(\partial f_i / \partial x_j\), the elements of the Jacobian matrix, \(\mathbf{J}\). It is usually more straightforward to program a numerical approximation for the derivatives, e.g. a forward\sphinxhyphen{}difference approximation:

\sphinxAtStartPar
\(\frac{ \partial f_i }{ \partial x_j } \simeq \frac{ f_i(x_j + \delta x_j) - f_i(x_j) } { \delta x_j}\),

\sphinxAtStartPar
where we vary each \(x_j\) independently and \(\delta x_j\) are some arbitrary changes you input.

\sphinxAtStartPar
As for the case of the one\sphinxhyphen{}dimensional Newton\sphinxhyphen{}Raphson method, this search can fail if the initial guess is not close enough to the zero of all the \(f_i\)’s so that they can be approximated by a linear function. The backtracking technique may be applied here as well, in the present case, progressively decreasing the corrections \(\Delta x_i\), until \(|f|^2 = |f_1|^2 + |f_2|^2 + ... + |f_N|^2\) decreases.


\section{More Matrix Examples}
\label{\detokenize{Chapters/Chapter6/Chapter6:more-matrix-examples}}
\sphinxAtStartPar
Before we proceed to Exercise 6.2, let’s tackle two more matrix problems.


\subsection{Example 6.6: Your model of some physical system results in N=100 coupled linear equations with N unknowns:}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-6-your-model-of-some-physical-system-results-in-n-100-coupled-linear-equations-with-n-unknowns}}
\sphinxAtStartPar
\(a_{00} y_0 + a_{01} y_1 + ... + a_{0(N-1)} y_{N-1} = b_0\)

\sphinxAtStartPar
\(a_{10} y_0 + a_{11} y_1 + ... + a_{1(N-1)} y_{N-1} = b_1\)

\sphinxAtStartPar
\(...\)

\sphinxAtStartPar
\(a_{(N-1)0} y_0 + a_{(N-1)1} y_1 + ... + a_{(N-1)(N-1)} y_{N-1} = b_{N-1}\)

\sphinxAtStartPar
In this example, take the matrix \(\mathbf{a}\) to be the Hilbert matrix (see \sphinxurl{https://en.wikipedia.org/wiki/Hilbert\_matrix}) and \(\mathbf{b}\) its first column:

\sphinxAtStartPar
\(\mathbf{a} = \left(\begin{array}{c} 
1 & \frac{1}{2} & \frac{1}{3} & \frac{1}{4} & ... & \frac{1}{100}  \\
\frac{1}{2} & \frac{1}{3} & \frac{1}{4} & \frac{1}{5} & ... & \frac{1}{101} \\
\ddots & \ddots & \ddots & \ddots &  \ddots & \ddots \\
\frac{1}{100} & \frac{1}{101} & \frac{1}{102} & ... & ... & \frac{1}{199}
\end{array}\right)\)

\sphinxAtStartPar
or \(a_{ij} = \frac{1}{i+j +1}\).

\sphinxAtStartPar
and \(\vec{b} = \left(\begin{array}{c}
1 \\
\frac{1}{2}\\
\frac{1}{3}\\
\ddots\\
\frac{1}{100}\end{array}\right)
\)

\sphinxAtStartPar
Solve the matrix equation, \(\mathbf{a} \vec{y} = \vec{b}\) numerically, and compare to the analytic solution:
\(\vec{y} = \left(\begin{array}{c}
1 \\
0\\
\ddots\\
0\\
\end{array}\right)
\)


\subsection{Example 6.7: Dirac Gamma Matrices}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-7-dirac-gamma-matrices}}
\sphinxAtStartPar
The Dirac equation extends quantum mechanics to include relativity and spin\sphinxhyphen{}1/2 particles (fermions). The extension of the Hamiltonian operator for an electron (a fermion), requires it to contain matrices, and those matrices are expressed in terms of \(4 \times 4\) \(\mathbf{\gamma}\) matrices, that can be represented in terms of the familiar \(2 \times 2\) Pauli matrices \(\mathbf{\sigma}_i\):

\sphinxAtStartPar
\(\mathbf{\gamma}_i = \left(\begin{array}{c}
0 & \mathbf{\sigma}_i \\
-\mathbf{\sigma}_i & 0\\
\end{array}\right)
\), \(i=1,2,3\),

\sphinxAtStartPar
where:

\sphinxAtStartPar
\(\mathbf{\sigma}_1 = \left(\begin{array}{c}
0 & 1 \\
1 & 0\\
\end{array}\right)
\), \(\mathbf{\sigma}_2 = \left(\begin{array}{c}
0 & -i \\
i & 0\\
\end{array}\right)
\), \(\mathbf{\sigma}_3 = \left(\begin{array}{c}
1 & 0 \\
0 & -1\\
\end{array}\right)\).

\sphinxAtStartPar
Confirm the following properties of the \(\mathbf{\gamma}\) matrices:

\sphinxAtStartPar
\(\mathbf{\gamma}_2^\dagger = \mathbf{\gamma}_2^{-1}  = - \mathbf{\gamma}_{2}\),

\sphinxAtStartPar
and

\sphinxAtStartPar
\(\mathbf{\gamma}_1 \mathbf{\gamma}_2 = -i \left(\begin{array}{c}
\mathbf{\sigma}_3 & 0\\
0 & \mathbf{\sigma}_3\\
\end{array}\right)\)


\subsection{Example 6.8: 2\sphinxhyphen{}Dimensional Newton\sphinxhyphen{}Raphson Warmup}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-8-2-dimensional-newton-raphson-warmup}}
\sphinxAtStartPar
As a warmup towards solving Exercise 6.2, implement a 2\sphinxhyphen{}Dimensional Newton\sphinxhyphen{}Raphson method:

\sphinxAtStartPar
\(\vec{f} + \mathbf{J} \Delta \vec{x} = 0\)

\sphinxAtStartPar
where:

\sphinxAtStartPar
\(\vec{f} = \left(\begin{array}{c} 
f_{1}  \\
f_{2}  \\
\end{array}\right)\), \(\Delta \vec{x} = \left(\begin{array}{c} 
\Delta x_{1}  \\
\Delta x_{2}  \\
\end{array}\right)\), \(\mathbf{J} = \left(\begin{array}{cccc} 
\frac{ \partial f_1 }{ \partial x_1 } & \frac{ \partial f_1 }{ \partial x_2 }\\
\frac{ \partial f_2 }{ \partial x_1 } & \frac{ \partial f_2 }{ \partial x_2 } 
\end{array}\right)\),

\sphinxAtStartPar
and solve via:

\sphinxAtStartPar
\(\mathbf{J} \Delta \vec{x} = -\vec{f}\).

\sphinxAtStartPar
using the \sphinxcode{\sphinxupquote{linalg}} package.

\sphinxAtStartPar
You will need to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Create a function that calculates the partial derivatives that enter the Jacobian, \(\frac{ \partial f_i }{ \partial x_j }\). You may use the central\sphinxhyphen{}difference derivative.

\item {} 
\sphinxAtStartPar
Create a function that calculates the actual Jacobian matrix, calling the aforementioned function.

\item {} 
\sphinxAtStartPar
Create a function that returns the vector of functions \(\vec{f}\).

\item {} 
\sphinxAtStartPar
Use \(\mathbf{J}\) and \(-\vec{f}\) to solve the system iteratively for \(\Delta \vec{x}\), adding it to \(\vec{x}\), until a solution is reached, i.e. \(|f_i| \sim 0\) within the required precision.

\end{itemize}

\sphinxAtStartPar
(a) Check your Jacobian with the \sphinxstyleemphasis{linear} system:

\sphinxAtStartPar
\(2 x + y - 13 = 0\)

\sphinxAtStartPar
\(x + y - 9 = 0\)

\sphinxAtStartPar
(b) Use your code for the 2\sphinxhyphen{}D Newton Raphson to solve the linear system above.

\sphinxAtStartPar
(c) Use your code to solve the nonlinear system:

\sphinxAtStartPar
\(x^2 + y - 21 = 0\)

\sphinxAtStartPar
\(x + y^2 - 29 = 0\)

\sphinxAtStartPar
Verify that your solutions correspond to the expected ones (\( x = 4, y = 5\)).

\sphinxAtStartPar
(d) Use your code to solve the system:

\sphinxAtStartPar
\(xe^y = 1\)

\sphinxAtStartPar
\(-x^2 + y = 1\)


\section{Data Fitting}
\label{\detokenize{Chapters/Chapter6/Chapter6:data-fitting}}

\subsection{Introduction to Data Fitting}
\label{\detokenize{Chapters/Chapter6/Chapter6:introduction-to-data-fitting}}
\sphinxAtStartPar
Data fitting is an art that should be studied by all scientists.

\sphinxAtStartPar
This section gives an introduction to the subject, examining how to interpolate data, and how to perform least\sphinxhyphen{}squares fits to data.

\sphinxAtStartPar
A problem that we wish to tackle: Given a table of measured values, e.g. cross sections for the resonant scattering of neutrons from a nucleus at certain energies, we wish to determine the values for the cross sections at energy values lying between those in the table.

\sphinxAtStartPar
e.g.:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Energy (MeV)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Cross Section (mb)
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
10.6
\\
\sphinxhline
\sphinxAtStartPar
25
&
\sphinxAtStartPar
16.0
\\
\sphinxhline
\sphinxAtStartPar
50
&
\sphinxAtStartPar
45.0
\\
\sphinxhline
\sphinxAtStartPar
75
&
\sphinxAtStartPar
83.5
\\
\sphinxhline
\sphinxAtStartPar
100
&
\sphinxAtStartPar
52.8
\\
\sphinxhline
\sphinxAtStartPar
125
&
\sphinxAtStartPar
19.9
\\
\sphinxhline
\sphinxAtStartPar
150
&
\sphinxAtStartPar
10.8
\\
\sphinxhline
\sphinxAtStartPar
175
&
\sphinxAtStartPar
8.25
\\
\sphinxhline
\sphinxAtStartPar
200
&
\sphinxAtStartPar
4.7
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
This problem can be solved in different ways:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Interpolation}: The simplest is to numerically interpolate between the values of the experimental data. This is direct and easy, but does not account for there being experimental noise (i.e. errors) in the data.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Least\sphinxhyphen{}squares fitting}: A more appropriate solution is to find the best fit of a theoretical function to the data: start with what we believe to be the “correct” theoretical description of the data, e.g.:

\end{itemize}

\sphinxAtStartPar
\( f(E) = \frac{ f_r } { (E-E_r)^2 + \Gamma^2/4 }\),

\sphinxAtStartPar
where \(f_r\), \(E_r\) and \(\Gamma\) are unknown parameters, and then adjust the parameters to obtain the best fit, in the statistical sense. This best fit may not pass through all (or any!) points.

\sphinxAtStartPar
Both interpolation and least\sphinxhyphen{}squares fitting are powerful tools that let you treat tables of numbers as if they were analytic functions, and sometimes let you deduce statistically meaningful constraints from measurements.


\subsection{Lagrange Interpolation}
\label{\detokenize{Chapters/Chapter6/Chapter6:lagrange-interpolation}}
\sphinxAtStartPar
Consider a table of data that we wish to interpolate. We call the independent variables \(x\) and its tabulated values \(x_i\), (\(i=1,2,...\)). We assume that the dependent variable is represented by a function \(g(x)\), with tabulated values \(g_i = g(x_i)\).

\sphinxAtStartPar
In Lagrange interpolation, we assume that \(g(x)\) can be approximated as an \((n-1)\)\sphinxhyphen{}degree polynomial in each interval \(i\):

\sphinxAtStartPar
\(g_i(x) \simeq a_0 + a_1 x + a_2 x^2 + ... + a_{n-1} x^{n-1}\) for \(x\simeq x_i\).

\sphinxAtStartPar
This fit is \sphinxstyleemphasis{local}: we do not assume that one single function can fit all the data in the table, but instead use a different polynomial (i.e. different set of \(a_i\)’s) for each interval.

\sphinxAtStartPar
If care is taken, the set of polynomials obtained this way will be used in further calculations, without introducing too much unwanted noise or discontinuities.

\sphinxAtStartPar
The classic interpolation formula was created by Lagrange. In this method, the formula for each interval is written as the sum of polynomials:

\sphinxAtStartPar
\(g(x) \simeq g_1 \lambda_1 (x) + g_2 \lambda_2 (x) + ... + g_n \lambda_n(x)\),

\sphinxAtStartPar
where the \(g_i\) are the measured values of the dependent variable (e.g. the cross section) and the \(\lambda_i\)’s can be calculated via:

\sphinxAtStartPar
\(\lambda_i (x) = \prod_{j=1, j\neq i}^n \frac{ x - x_j } { x_i - x_j}\),

\sphinxAtStartPar
or explicitly:

\sphinxAtStartPar
\(\lambda_i (x) = \frac{ x - x_1 } { x_i - x_1} \frac{ x - x_2 } { x_i - x_2} ... \frac{ x - x_n } { x_i - x_n}\).

\sphinxAtStartPar
E.g. with three points, you would get a second\sphinxhyphen{}degree polynomial.

\sphinxAtStartPar
E.g. Assume that we are given the pts and function values:

\sphinxAtStartPar
\(x_i=(0,1,2,4)\) and \(g_i = (-12, -12, -24, -60)\).

\sphinxAtStartPar
With four points, the Lagrange formula determines a third\sphinxhyphen{}order polynomial that reproduces each of the tabulated values.

\sphinxAtStartPar
\(g(x) = \frac{ (x-1) (x-2) (x-4) } { (0-1) (0-2) (0-4) } (-12) + \frac{ (x-0) (x-2) (x-4) } { (1-0)(1-2)(1-4) } (-12) + \frac{ (x-0) (x-1) (x-4) }{ (2-0) (2-1) (2-4) } (-24)\)
\(+ \frac{ (x-0)(x-1)(x-2)} { (4-0) (4-1)(4-2) } (-60)\).

\sphinxAtStartPar
\(\Rightarrow g(x) = x^3 - 9x^2 + 8x - 12\)

\sphinxAtStartPar
Then:

\sphinxAtStartPar
\(g(4) = 4^3 - 9 (4^2) + 32 - 12 = -60\),
\(g(0.5) = -10.125\).

\sphinxAtStartPar
If the data contain little noise, the polynomial can be used with some confidence within the range of the data, but with some risk beyond the range of the data.

\sphinxAtStartPar
Note that Lagrange interpolation has no restriction that the points \(x_i\) be evenly spaced.

\sphinxAtStartPar
Usually the Lagrange method is applied only to a small region of the table, with a small value of \(n\), despite the fact that the formula works perfect well for fitting a high\sphinxhyphen{}degree polynomial to the entire table.

\sphinxAtStartPar
The difference between the value of the polynomial and the actual function can be shown to be large if high derivatives exist in \(g(x)\), which would be the case if the data is noisy.

\sphinxAtStartPar
Let’s apply Lagrange interpolation to the neutron scattering data!


\subsection{Example 6.9: Lagrange Interpolation}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-9-lagrange-interpolation}}
\sphinxAtStartPar
Apply \(n\)\sphinxhyphen{}point Lagrange interpolation to the data given in the table above, varying the number of points \(n\). Plot both the data points and the resulting fits.

\sphinxAtStartPar
Which number of points “looks” the best?


\subsection{Cubic Spline Interpolation}
\label{\detokenize{Chapters/Chapter6/Chapter6:cubic-spline-interpolation}}
\sphinxAtStartPar
Through our example of trying to interpolate the resonant cross section with Lagrange interpolation, we saw that fitting parabolas (i.e. 3\sphinxhyphen{}point interpolation), within subintervals in the table, may avoid the erroneous and possibly catastrophic deviations of a high\sphinxhyphen{}order formula (e.g. 9\sphinxhyphen{}point interpolation).

\sphinxAtStartPar
We also saw that a two\sphinxhyphen{}point interpolation with straight lines may not lead you far astray, but it is rarely pleasing to the eye, or precise.

\sphinxAtStartPar
A sophisticated variation of an \(n=4\) interpolation, known as \sphinxstyleemphasis{cubic splines}, often leads to surprisingly eye\sphinxhyphen{}pleasing fits.

\sphinxAtStartPar
In this approach, cubic polynomials are fit to the function in each interval, with the additonal constraint that the first and second derivatives be continuous from one interval to the next. The continuity of the slope and curvature is what makes the spline interpolation fit particularly eye\sphinxhyphen{}pleasing.

\sphinxAtStartPar
The series of cubic polynomials obtained by spline\sphinxhyphen{}fitting a table of data can be integrated and differentiated, and is guaranteed to have well\sphinxhyphen{}behaved derivative. The existence of meaningful derivatives is an important consideration: e.g. if the function is a potential,  you can take the derivative to obtain the force.

\sphinxAtStartPar
The complexity of simultaneously matching polynomials and their derivatives over all the interpolation points leads to many simultaneous linear equations to be solved. This makes splines unattractive for calculations by hand, yet easy for computers, and popular in both calculations and computer drawing programs.


\subsection{Example 6.10: Cubic Spline Interpolation with scipy}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-10-cubic-spline-interpolation-with-scipy}}
\sphinxAtStartPar
Let’s use SciPy’s interpolation packages to interpolate the resonant cross section.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{interpolate}

\PYG{c+c1}{\PYGZsh{} the data: }
\PYG{n}{xdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{75}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{125}\PYG{p}{,} \PYG{l+m+mi}{150}\PYG{p}{,} \PYG{l+m+mi}{175}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{10.6}\PYG{p}{,} \PYG{l+m+mf}{16.0}\PYG{p}{,} \PYG{l+m+mf}{45.0}\PYG{p}{,} \PYG{l+m+mf}{83.5}\PYG{p}{,} \PYG{l+m+mf}{52.8}\PYG{p}{,} \PYG{l+m+mf}{19.9}\PYG{p}{,} \PYG{l+m+mf}{10.8}\PYG{p}{,} \PYG{l+m+mf}{8.25}\PYG{p}{,} \PYG{l+m+mf}{4.7}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the x coordinates where we want to perform the interpolation:}
\PYG{n}{xinterp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Cubic Spline Interpolation:}
\PYG{n}{cs} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{CubicSpline}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} this creates a function \PYGZdq{}cs\PYGZdq{}, that we can use at specific points to create the interpolated y\PYGZhy{}coordinates }
\PYG{n}{yinterp} \PYG{o}{=} \PYG{n}{cs}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} and now let\PYGZsq{}s plot: }
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}E\PYGZdl{} (MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{frac}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sigma\PYGZcb{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{E\PYGZcb{}\PYGZdl{} (mB/MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Spline Interpolation (scipy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} plot the interpolations}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{yinterp}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Splines}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{fb3f9601891a566e14434d3a1a7f4295d36fd127660a8e4fd3afa409d4c5a354}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} You can also access the derivatives!}

\PYG{c+c1}{\PYGZsh{} and now let\PYGZsq{}s plot: }
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}E\PYGZdl{} (MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{derivatives}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Spline Interpolation (scipy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} Plot the derivatives: }
\PYG{c+c1}{\PYGZsh{} cs(xinterp, nu=1) calculates the first derivative, etc.}
 \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{cs}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,}\PYG{n}{nu}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2nd derivative}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{cs}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,}\PYG{n}{nu}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3rd derivative}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{e37172b445e0562a6423a2ec3af98104de2360a4de447ee7d7acf20b3fac2b58}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Other SciPy Interpolators}
\label{\detokenize{Chapters/Chapter6/Chapter6:other-scipy-interpolators}}
\sphinxAtStartPar
There are many other 1\sphinxhyphen{}D interpolating methods in SciPy’s interpolate module:

\sphinxAtStartPar
Cubic splines are by construction twice continuously differentiable. This may lead to the spline function oscillating and “overshooting” in between the data points. In these situations, an alternative is to use the so\sphinxhyphen{}called monotone cubic interpolants: these are constructed to be only once continuously differentiable, and attempt to preserve the local shape implied by the data. \sphinxcode{\sphinxupquote{scipy.interpolate}} provides two objects of this kind: PchipInterpolator and Akima1DInterpolator:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ak} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{Akima1DInterpolator}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Akima 1D interpolator}
\PYG{n}{pc} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{PchipInterpolator}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Pchip interpolator}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} and now let\PYGZsq{}s plot: }
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}E\PYGZdl{} (MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{frac}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sigma\PYGZcb{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{E\PYGZcb{}\PYGZdl{} (mB/MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Spline Interpolation (scipy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} plot the interpolations}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{yinterp}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Splines}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{ak}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Akima1D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pchip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{c40b9b623fdb2576f48923f29b05aa5d89a402c2129c115bbf0db6d3065a07aa}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
B\sphinxhyphen{}splines form an alternative (if formally equivalent) representation of piecewise polynomials. This basis is generally more computationally stable than the power basis and is useful for a variety of applications which include interpolation, regression and curve representation. Details are given in the SciPy piecewise polynomials section (\sphinxurl{https://docs.scipy.org/doc/scipy/tutorial/interpolate/splines\_and\_polynomials.html\#tutorial-interpolate-ppoly}), and here we illustrate their usage:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} B\PYGZhy{}spline interpolator}
\PYG{n}{bspl} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{make\PYGZus{}interp\PYGZus{}spline}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} and now let\PYGZsq{}s plot: }
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}E\PYGZdl{} (MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{frac}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sigma\PYGZcb{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mathrm}\PYG{l+s+si}{\PYGZob{}d\PYGZcb{}}\PYG{l+s+s1}{E\PYGZcb{}\PYGZdl{} (mB/MeV)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Spline Interpolation (scipy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} plot the interpolations}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{yinterp}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cubic Splines}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{ak}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Akima1D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{green}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pchip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{bspl}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{}Splines}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper right}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{402ca4c2844c94a9a2d316af0684d33dfe628d74b38c0f7c234bad9eb040c054}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
By default, the result of \sphinxcode{\sphinxupquote{make\_interp\_spline(x, y)}} is equivalent to \sphinxcode{\sphinxupquote{CubicSpline(x, y)}}. The difference is that the former allows several optional capabilities, e.g. it can construct splines of various degrees (via the optional argument \sphinxcode{\sphinxupquote{k}}).


\subsection{Example 6.11: Global Temperature: Load data with Pandas and Interpolate with SciPy}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-11-global-temperature-load-data-with-pandas-and-interpolate-with-scipy}}
\sphinxAtStartPar
Taken from: \sphinxurl{https://climate.nasa.gov/vital-signs/global-temperature/}

\sphinxAtStartPar
This graph (data from: “No\_Smoothing” column of \sphinxurl{https://data.giss.nasa.gov/gistemp/graphs/graph\_data/Global\_Mean\_Estimates\_based\_on\_Land\_and\_Ocean\_Data/graph.txt}) shows the change in global surface temperature compared to the long\sphinxhyphen{}term average from 1951 to 1980. Earth’s average surface temperature in 2023 was the warmest on record since recordkeeping began in 1880 (source: NASA/GISS).

\sphinxAtStartPar
Let’s load the data using Python’s \sphinxcode{\sphinxupquote{pandas}} and interpolate them. We can use (very cautiously in this case – this is not a model!) what the temperature \sphinxstyleemphasis{could} be in 2050.

\sphinxAtStartPar
Note that the cubic splines will simply pass through all the points: we don’t want that. Here we will see an example of interpolation with “smoothing”.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd} \PYG{c+c1}{\PYGZsh{} pandas is a useful and widely\PYGZhy{}used tool for data analysis}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{interpolate}

\PYG{c+c1}{\PYGZsh{} load the data:}
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{graph.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} \PYGZsq{}\PYGZbs{}t\PYGZsq{} represents tabs}
\PYG{c+c1}{\PYGZsh{} change the names to the expected ones}
\PYG{n}{df}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Temp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} print to see how it looks like}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} we can access the columns as df[\PYGZdq{}Year\PYGZdq{}] and df[\PYGZdq{}Temp\PYGZdq{}]}
\PYG{c+c1}{\PYGZsh{} let\PYGZsq{}s interpolate using various methods:}
\PYG{n}{xinterp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1880}\PYG{p}{,}\PYG{l+m+mi}{2050}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} interpolators:}
\PYG{n}{bspl} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{make\PYGZus{}interp\PYGZus{}spline}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Temp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} This will pass through all the points. We\PYGZsq{}d rather use something that generates smoothing:}
\PYG{n}{spl} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{splrep}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Temp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} s determines the degree of smoothing}

\PYG{c+c1}{\PYGZsh{} get the data points:}
\PYG{n}{yinterp} \PYG{o}{=} \PYG{n}{bspl}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{)} 
\PYG{n}{ysmooth} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{splev}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{spl}\PYG{p}{,} \PYG{n}{der}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     Year  Temp
0    1881 \PYGZhy{}0.08
1    1882 \PYGZhy{}0.10
2    1883 \PYGZhy{}0.16
3    1884 \PYGZhy{}0.27
4    1885 \PYGZhy{}0.33
..    ...   ...
138  2019  0.98
139  2020  1.01
140  2021  0.84
141  2022  0.89
142  2023  1.17

[143 rows x 2 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Let\PYGZsq{}s plot them!}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Year}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Temperature Anomaly vs. Average from 1951\PYGZhy{}1980 (C\PYGZdl{}\PYGZca{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{circ\PYGZdl{})}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label }
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Temperature Anomaly Interpolation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} let\PYGZsq{}s plot the pandas data:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Year}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Temp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} and the interpolations:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{yinterp}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{}Splines}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{ysmooth}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Splines with smoothing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} set limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct the legend:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add a legend}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{519b802676e921161293509772a29c8e9451023a9992a9a9436d51fd5d84c43c}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Extrapolated temperature anomaly in 2050:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ysmooth}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Extrapolated temperature anomaly in 2050: 1.8363666133560805
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As we will see later in this chapter, data with so much noise is better addressed by least\sphinxhyphen{}squares fitting with a theoretical prediction rather than an interpolator.


\subsection{2\sphinxhyphen{}D Interpolation}
\label{\detokenize{Chapters/Chapter6/Chapter6:d-interpolation}}
\sphinxAtStartPar
You can also interpolate in multiple dimensions. Let’s look at an example in 2D, i.e. two independent variables and one dependent variable that we wish to interpolate.

\sphinxAtStartPar
E.g. we have the data:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} the data:}
\PYG{n}{xdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{zdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} interpolating points:}
\PYG{n}{xinterp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{yinterp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{ydata}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{ydata}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} bivariate B\PYGZhy{}spline representation of a surface.}
\PYG{n}{tck} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{bisplrep}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{zdata}\PYG{p}{,} \PYG{n}{kx}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ky}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} evaluate the interpolator: }
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{bisplev}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{yinterp}\PYG{p}{,} \PYG{n}{tck}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now PLOT!}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} if we want a 3D plot}

\PYG{c+c1}{\PYGZsh{} necessary for 2\PYGZhy{}D plot:}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{xinterp}\PYG{p}{,} \PYG{n}{yinterp}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{Z}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{*}\PYG{n}{X}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

\PYG{c+c1}{\PYGZsh{} plot the data:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{,} \PYG{n}{zdata}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{48}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot a wireframe of the interpolator:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot\PYGZus{}wireframe}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{n}{rstride}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{cstride}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}mpl\PYGZus{}toolkits.mplot3d.art3d.Line3DCollection at 0x12f17bc80\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{2854b5224e20bc21ed5ebf1a67e25a5b94d10b8ad268dd83fa6107ef8c39616e}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Least\sphinxhyphen{}Squares Fitting}
\label{\detokenize{Chapters/Chapter6/Chapter6:least-squares-fitting}}
\sphinxAtStartPar
Within the context of data fitting, it is important to emphasize three points:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
If the data being fit contains errors, the “best\sphinxhyphen{}fit”, in a statistical sense, should not pass through all the data points.

\item {} 
\sphinxAtStartPar
If the theory is not an appropriate one for the data, then its best fit to the data may not be a good fit at all. This is how we know that the theory is not right.

\item {} 
\sphinxAtStartPar
Only for the simplest case of a \sphinxstyleemphasis{linear} least\sphinxhyphen{}squares fit can we write down a closed\sphinxhyphen{}form solution to evaluate and obtain the fit. More realistic problems are usually solved by trial\sphinxhyphen{}and\sphinxhyphen{}error search procedures.

\end{enumerate}

\sphinxAtStartPar
Imagine that you measured \(N_D\) data values of the dependent variable \(y\) as a function of the independent variable \(x\):

\sphinxAtStartPar
\((x_i, y_i \pm \sigma_i)\);  \(i=1,...,N_D\),

\sphinxAtStartPar
where \(\pm \sigma_i\) is the experimental uncertainty in the \(i\)\sphinxhyphen{}th value of \(y\).

\sphinxAtStartPar
For simplicity we will assume that errors occur in the dependent variable (\(y\)), altghough this is hardly ever true.

\sphinxAtStartPar
\sphinxstylestrong{Our goal}: to determine how well a mathematical function \(y=g(x)\) (i.e. the theory or model) can describe the data.

\sphinxAtStartPar
Additionally: if the theory contains some parameters or constants, our goal can be viewed as determining the best values for these.

\sphinxAtStartPar
Therefore, we assume that the theory function \(g(x)\), contains in addition to the functional dependence on \(x\), an additional dependence on \(N_P\) parameters: \({a_1, ..., a_{N_P}}\). These are \sphinxstyleemphasis{not} variables, but rather parts of the theoretical model.

\sphinxAtStartPar
With these parameters, we can write the function as:

\sphinxAtStartPar
\(g(x) = g(x; \{a_1, a_2, ... , a_{N_P}\}) = g(x;\{a_m\})\), \(m=1,...,N_P\),

\sphinxAtStartPar
where \(\{a_m\}\) is the set of parameters (\(m=1,...,N_P\)) and \(x\) is the independent variable.

\sphinxAtStartPar
Statistics tells us that we can use the so\sphinxhyphen{}called “chi\sphinxhyphen{}square” variable as a gauge of how well a theoretical function \(g\) reproduces the data:

\sphinxAtStartPar
\( \chi^2 = \sum_{i=1}^{N_D} \left[ \frac{ y_i - g(x_i;\{a_m\}) } { \sigma_i } \right]^2\),

\sphinxAtStartPar
where the sum \(i\) is taken over the \(N_D\) experimental data points \((x_i, y_i \pm \sigma_i)\).

\sphinxAtStartPar
Smaller values of \(\chi^2\) imply better fits, with \(\chi^2 = 0\) occurring if the theoretical curve went through the center of every data point (which never happens in practice!).

\sphinxAtStartPar
The \(1/\sigma_i^2\) weighting results in measurements with larger errors contributing less to \(\chi^2\).

\sphinxAtStartPar
\sphinxstyleemphasis{Least\sphinxhyphen{}squares fitting} involves adjusting the parameters \(\{a_m\}\) (\(m=1,...,N_P\)) until a \sphinxstyleemphasis{minimum} \(\chi^2\) is found.

\sphinxAtStartPar
This is the best fit possible, and the best way to determine the parameters in a theory.

\sphinxAtStartPar
Therefore, the \(N_P\) parameters \(\{a_m\}\) that make the \(\chi^2\) an extremum are found by solving the \(N_P\) equations:

\sphinxAtStartPar
\(\frac{ \partial \chi^2 }{ \partial a_m } = 0\); \(m=1,...,N_P\),

\sphinxAtStartPar
which imply that:

\sphinxAtStartPar
\(\sum_{i=1}^{N_D} \frac{ [y_i - g(x_i;\{a_n\})] } { \sigma_i^2 }\frac{ \partial g(x_i;\{a_n\}) }{ \partial a_m } = 0\); \(n,m=1,...,N_P\).

\sphinxAtStartPar
Often \(g(x;\{a_m\})\) has a sufficiently complicated dependence on the values of the \(\{a_m\}\) parameters to produce \(N_P\) \sphinxstyleemphasis{simultaneous nonlinear} equations for the \(\{a_m\}\) values.

\sphinxAtStartPar
But we already know how to solve these! (Trial\sphinxhyphen{}and\sphinxhyphen{}error searching through the \(N_p\)\sphinxhyphen{}dimensional parameter space).

\sphinxAtStartPar
To be safe, when such a search is completed, you need to check that the minimum of \(\chi^2\) is a global one and not a local one. One way to do this is to repeat the search for a whole grid of starting values, and if different minima are found, to pick the one with the lowest \(\chi^2\).

\sphinxAtStartPar
When the deviations from theory are a result of random errors described by Gaussian distributions, there are some useful rules of thumb to remember:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You know your fit is good if the value of \(\chi^2\) calculated is approximately equal to the number of degrees of freedom, i.e. \(\chi^2 \simeq N_D - N_P\), the difference between the number of data points and the number of parameters in your theory function.

\item {} 
\sphinxAtStartPar
If \(\chi^2 \ll N_D - N_P\), it does not mean you have a great theory or a really precise measurement; instead, you probably have \sphinxstyleemphasis{too many parameters} or have assigned errors (\(\sigma_i\)) that are too large (i.e. you \sphinxstyleemphasis{overestimated} the errors).

\item {} 
\sphinxAtStartPar
if \(\chi^2 \gg N_D - N_P\), the theory may not be good, or you may have significantly \sphinxstyleemphasis{underestimated} your errors, or you may have errors that are not random.

\end{itemize}


\subsection{Linear Regression}
\label{\detokenize{Chapters/Chapter6/Chapter6:linear-regression}}
\sphinxAtStartPar
The \(N_P\) simultaneous equations can be simplified considerably if the functions \(g(x;\{a_m\})\) depend \sphinxstyleemphasis{linearly} on the parameter values \(a_m\), e.g.:

\sphinxAtStartPar
\(g(x; a_1, a_2) = a_1 + a_2 x\).

\sphinxAtStartPar
In this case, known as “linear regression”, there are two parameters: the slope \(a_2\) and the \(y\)\sphinxhyphen{}intercept \(a_1\).

\sphinxAtStartPar
Notice that, while there are only two parameters to determine, there still may be an arbitrary number of \(N_D\) data points to fit.

\sphinxAtStartPar
\sphinxstyleemphasis{Remember}: A unique solution \sphinxstyleemphasis{is not possible} unless the number of data points is greater than the number of parameters: \(N_D \geq N_P\).

\sphinxAtStartPar
For the linear case, there are only two derivatives to consider:

\sphinxAtStartPar
\(\frac{ \partial g } { \partial a_1 } = 1\), \(\frac{ \partial g } { \partial a_2 } = x\).

\sphinxAtStartPar
After substitution, the \(\chi^2\) minimization equations can be solved:

\sphinxAtStartPar
\(a_1 = \frac{ S_{xx} S_y - S_x S_{xy} }{\Delta}\), \(a_2 = \frac{S S_{xy} - S_x S_y}{\Delta}\), where:

\sphinxAtStartPar
\(S = \sum_{i=1}^{N_D} \frac{1}{\sigma_i^2}\),

\sphinxAtStartPar
\(S_x = \sum_{i=1}^{N_D} \frac{x_i}{\sigma_i^2}\),

\sphinxAtStartPar
\(S_y = \sum_{i=1}^{N_D} \frac{y_i}{\sigma_i^2}\),

\sphinxAtStartPar
\(S_{xx} = \sum_{i=1}^{N_D} \frac{x_i^2}{\sigma_i^2}\),

\sphinxAtStartPar
\(S_{xy} = \sum_{i=1}^{N_D} \frac{x_i y_i}{\sigma_i^2}\),

\sphinxAtStartPar
\(\Delta = S S_{xx} - S_x^2\).

\sphinxAtStartPar
You can also get an expression for the variance (the square of the uncertainty) in the deduced parameters:

\sphinxAtStartPar
\(\sigma_{a_1}^2 = \frac{ S_{xx}}{\Delta}\), \(\sigma_{a_2} = \frac{S}{\Delta}\).

\sphinxAtStartPar
This is a measure of the uncertainties in the values of the fitted parameters, arising from the uncertainties \(\sigma_i\) in the measured \(y_i\) values.

\sphinxAtStartPar
A measure of the dependence of the parameters on each other is given by the \sphinxstyleemphasis{correlation coefficient}:

\sphinxAtStartPar
\(\rho(a_1, a_2) = \frac{ \mathrm{cov}(a_1, a_2) }{ \sigma_{a_1} \sigma_{a_2} }\), where:

\sphinxAtStartPar
\(\mathrm{cov}(a_1, a_2) = \frac{ - S_x } { \Delta }\) is the covariance between \(a_1\) and \(a_2\).

\sphinxAtStartPar
The above analytic solutions  for the parametrs are of the form found in statistics textbooks, but are not optimal for numerical calculations: subtractive cancelation can make the answers unstable. As previously discussed, a rearrangement of the equations can decrease this kind of error.

\sphinxAtStartPar
An improved set of expressions is given by:

\sphinxAtStartPar
\(a_1 = \bar{y} - a_2 \bar{x}\), \(a_2 = \frac{ S_{xy} } { S_{xx} }\), \(\bar{x} = \frac{1}{N} \sum_{i=1}^{N_D} x_i\), \(\bar{y} = \frac{1}{N} \sum_{i=1}^{N_D} y_i\), \(S_{xy} = \sum_{i=1}^{N_D} \frac{(x_i - \bar{x}) (y_i - \bar{y})}{\sigma_i^2}\), \(S_{xx} = \sum_{i=1}^{N_D} \frac{(x_i - \bar{x})^2}{\sigma_i^2}\)


\subsection{Example 6.12: Hubble’s Law}
\label{\detokenize{Chapters/Chapter6/Chapter6:example-6-12-hubble-s-law}}
\sphinxAtStartPar
In 1929, Edwin Hubble examined the data related the radial velocity \(v\) of 24 extra\sphinxhyphen{}galactic nebulae, to their distance \(r\) from our galaxy. He fit them with a straight line:

\sphinxAtStartPar
\( v = Hr\), where \(H\) is now known as the Hubble constant.

\sphinxAtStartPar
His measurements are given in the file \sphinxcode{\sphinxupquote{hubble.txt}}, where the first column represents the distance \(r\) in Mpc (pc=parsec, defined as the distance at which 1 astronomical unit, the mean Earth\sphinxhyphen{}sun distance, subtends an angle of one arcsecond, i.e. 1/3600 of a degree), and the second column is the velocity \(v\) in km/s.

\sphinxAtStartPar
We will assume that the errors on \(v\) are \(\sigma =1~\mathrm{km/s}\), but we will re\sphinxhyphen{}evaluate this assumption later on.

\sphinxAtStartPar
a) Load the file using \sphinxcode{\sphinxupquote{pandas}} and plot the data using \sphinxcode{\sphinxupquote{matplotlib}}.

\sphinxAtStartPar
b) Compute the least\sphinxhyphen{}squares straight\sphinxhyphen{}line fit to the data in the form:

\sphinxAtStartPar
\(v(r) = a + Hr\),

\sphinxAtStartPar
including the errors on the parameters, \(\sigma_a\) and \(\sigma_H\).

\sphinxAtStartPar
c) Plot your best fit along with the data.

\sphinxAtStartPar
d) Determine the \(\chi^2\) of the fit. Given its value, what would a better estimate of the average error on the measurements be?


\subsection{Quadratic Fits}
\label{\detokenize{Chapters/Chapter6/Chapter6:quadratic-fits}}
\sphinxAtStartPar
As long as the function being fitted depends \sphinxstyleemphasis{linearly} on the unknown parameters \(a_i\), the condition of minimum \(\chi^2\) leads to a set of simultaneous \sphinxstyleemphasis{linear} equations for the \(a_m\)’s that can be solved by hand or on a computer using matrix techniques. This is true if the function being fitted is a polynomial of any degree.

\sphinxAtStartPar
E.g. suppose we want to fit the quadratic polynomial:

\sphinxAtStartPar
\(g(x) = a_1 + a_2 x + a_3 x^2\),

\sphinxAtStartPar
to the experimental measurements \((x_i, y_i \pm \sigma_i)\), \(i=1,...,N_D\).

\sphinxAtStartPar
Here, \(g(x)\) is linear in all the parameters \(a_m\), and we still only need to solve linear simultaneous equations, even though \(x\) is raised to the second power.

\sphinxAtStartPar
\sphinxstyleemphasis{In contrast}, if we were trying to fit a function of the form \(g(x) = (a_1 + a_2 x) e^{-a_3 x}\) to the data, then we would need to solve nonlinear simultaneous equations (see next subsection).

\sphinxAtStartPar
The best fit of a quadratic to the data is obtained by applying the minimum \(\chi^2\) condition for \(N_P = 3\) parameters and \(N_D\) data points.

\sphinxAtStartPar
\(\frac{ \partial \chi^2 } { \partial a_m }\), \(m=1,2,3\) leads to three simultaneous linear equations for \(a_1\), \(a_2\) and \(a_3\):

\sphinxAtStartPar
\(\sum_{i=1}^{N_D} \frac{ [y_i - g(x_i;\{a_m\})] } { \sigma_i^2 }\frac{ \partial g(x_i;\{a_m\}) }{ \partial a_n } = 0\); \(m,n=1,2,3\), with:

\sphinxAtStartPar
\(\frac{ \partial g } { \partial a_1 } = 1\), \(\frac{ \partial g } { \partial a_2 } = x\), \(\frac{ \partial g } { \partial a_3 } = x^2\).

\sphinxAtStartPar
The \(a_m\) dependence only arises from the term in the square brackets in the sums. Since that term only has a linear dependence on the \(a_m\)’s, all the equations are linear in them.

\sphinxAtStartPar
The equations can be written as:

\sphinxAtStartPar
\(S a_1 + S_x a_2 + S_{xx} a_3 = S_y\),

\sphinxAtStartPar
\(S_x a_1 + S_{xx} a_2 + S_{xxx} a_3 = S_{xy}\),

\sphinxAtStartPar
\(S_{xx} a_1 + S_{xxx} a_2 + S_{xxxx} a_3 = S_{xxy}\).

\sphinxAtStartPar
with \(S = \sum_{i=1}^{N_D} \frac{1}{\sigma_i^2}\), \(S_x = \sum_{i=1}^{N_D} \frac{x_i}{\sigma_i^2}\), \(S_y = \sum_{i=1}^{N_D} \frac{y_i}{\sigma_i^2}\), \(S_{xx} = \sum_{i=1}^{N_D} \frac{x_i^2}{\sigma_i^2}\), \(S_{xy} = \sum_{i=1}^{N_D} \frac{x_i y_i}{\sigma_i^2}\), and so on.

\sphinxAtStartPar
If we now define the vector of unknowns:

\sphinxAtStartPar
\(\vec{a} = \left(\begin{array}{c} 
a_{1}  \\
a_{2}  \\
a_{3} 
\end{array}\right)\),

\sphinxAtStartPar
the matrix:

\sphinxAtStartPar
\(\mathbf{A} = \left(\begin{array}{c} 
S & S_x & S_{xx}  \\
S_x & S_{xx} & S_{xxx}  \\
S_{xx} & S_{xxx} & S_{xxxx}  
\end{array}\right)\),

\sphinxAtStartPar
and:

\sphinxAtStartPar
\(\vec{b} = \left(\begin{array}{c} 
S_y  \\
S_{xy}  \\
S_{xxy} 
\end{array}\right)\),

\sphinxAtStartPar
then to get the coefficients \(a_1, a_2, a_3\), we need to solve the matrix equation:

\sphinxAtStartPar
\(\mathbf{A} \vec{a} = \vec{b}\), for \(\vec{a}\), using the techniques that we have previously discussed in this chapter.


\subsection{Nonlinear Fitting}
\label{\detokenize{Chapters/Chapter6/Chapter6:nonlinear-fitting}}
\sphinxAtStartPar
Earlier in this section we saw the Breit\sphinxhyphen{}Wigner resonance formula:

\sphinxAtStartPar
\(f(E) = \frac{ f_r } { (E-E_r)^2 + \Gamma^2 / 4 }\).

\sphinxAtStartPar
If we have a set of data that we wish to describe with such a formula, we would need to determine what values for the parameters \(E_r\), \(f_r\) and \(\Gamma\) provide the best fit to the data.

\sphinxAtStartPar
Since \(f\) is a nonlinear function of the parameters, the equations that result from minimizing \(\chi^2\) are \sphinxstyleemphasis{nonlinear} as well!

\sphinxAtStartPar
But we already saw how to use the Newton\sphinxhyphen{}Raphson algorithm to search for solutions of simultaneous nonlinear equations. The method involved an expansion of the equations about the previous “guess” point, to obtain a set of linear equations, and then solving the linear equations with matrix libraries.

\sphinxAtStartPar
In what follows, we will use the same combination of fitting, trial\sphinxhyphen{}and\sphinxhyphen{}error searching and matrix algebra, to conduct a nonlinear least\sphinxhyphen{}squares fit to the data.

\sphinxAtStartPar
To get the best fit, we need to find values of the \(N_P\) parameters \(a_m\) in the theory \(g(x; \{a_m\})\) that minimize:

\sphinxAtStartPar
\(\chi^2 = \sum_{i=1}^{N_D} \left( \frac{ y_i - g(x_i) }{\sigma_i}\right)^2\).

\sphinxAtStartPar
This leads to the \(N_P\) equations:

\sphinxAtStartPar
\(\sum_{i=1}^{N_D} \frac{ [y_i - g(x_i; \{a_n\})] } { \sigma_i^2 } \frac{ \partial g(x_i; \{a_n\}) }{ \partial a_m }  = 0\), \(m=1,...,N_P\).

\sphinxAtStartPar
For the sake of simplicity, let’s rewrite the theory function using the redefinitions:

\sphinxAtStartPar
\(f_r \rightarrow a_1\), \(E_r \rightarrow a_2\), \(\Gamma^2/4 \rightarrow a_3\), \(E\rightarrow x\) such that:

\sphinxAtStartPar
\(g(x; a_1, a_2, a_3) = \frac{ a_1 } { (x-a_2)^2 + a_3 }\).

\sphinxAtStartPar
The derivatives required are then:

\sphinxAtStartPar
\(\frac{ \partial g } { \partial a_1 } = \frac{ 1 } { (x-a_2)^2 + a_3 }\), \(\frac{ \partial g } { \partial a_2 } = \frac{ -2 a_1 (x - a_2) }{[ (x-a_2)^2 + a_3]^2}\), \(\frac{ \partial g } { \partial a_3 } =  \frac{ -a_1 } { [ (x-a_2)^2 + a_3]^2}\).

\sphinxAtStartPar
Substituting into the best\sphinxhyphen{}fit condition yields three simultaneous nonlinear equations in \(a_1, a_2, a_3\) that we need to solve in order to fit the \(N_D\) data points.

\sphinxAtStartPar
If all the errors are equal, we then have the following equations in the form that we require for the Newton\sphinxhyphen{}Raphson method, i.e. \(f_i(a_1, a_2, ..., a_N) = 0\), \(i=1,...,N\):

\sphinxAtStartPar
\(f_1(a_1, a_2, a_3) = \sum_{i=1}^9 \frac{ y_i - g(x_i; a_1, a_2, a_3) } { (x_i - a_2)^2 + a_3 } = 0\),

\sphinxAtStartPar
\(f_2(a_1, a_2, a_3) = \sum_{i=1}^9 \frac{ [y_i - g(x_i; a_1, a_2, a_3)] (x_i - a_2) } { [(x_i - a_2)^2 + a_3]^2 } = 0\),

\sphinxAtStartPar
\(f_3(a_1, a_2, a_3) = \sum_{i=1}^9 \frac{ y_i - g(x_i; a_1, a_2, a_3) } { [(x_i - a_2)^2 + a_3]^2 } = 0\)

\sphinxstepscope


\chapter{Ordinary Differential Equations}
\label{\detokenize{Chapters/Chapter7/Chapter7:ordinary-differential-equations}}\label{\detokenize{Chapters/Chapter7/Chapter7::doc}}

\section{Introduction}
\label{\detokenize{Chapters/Chapter7/Chapter7:introduction}}
\sphinxAtStartPar
Many of the laws of physics are formulated in terms of differential equations.

\sphinxAtStartPar
Part of the power of computational tools is that it is easy to solve almost every differential equation. E.g. one can go beyond the small displacement in the description of oscillations, and explore interesting nonlinear phenomena.

\sphinxAtStartPar
Let’s begin with a recap of some mathematical preliminaries that pertain to differential equations, and then move on, in this chapter, to to discuss algorithms for solving the ordinary differential equations.


\section{Mathematical Preliminaries}
\label{\detokenize{Chapters/Chapter7/Chapter7:mathematical-preliminaries}}
\sphinxAtStartPar
\sphinxstylestrong{ORDER}: The order of a differential equation refers to the degree of the derivative.

\sphinxAtStartPar
e.g. the most general form for a \sphinxstyleemphasis{first\sphinxhyphen{}order} differential equation is:

\sphinxAtStartPar
\( \frac{ \mathrm{d} y } { \mathrm{d} x } = f(x,y)\).

\sphinxAtStartPar
e.g. even if \(f(x,y)\) is a nasty function of \(x\) and \(y\):

\sphinxAtStartPar
\( \frac{ \mathrm{d} y } { \mathrm{d} x } = x^2 y + x^{17} + y^{13}\),

\sphinxAtStartPar
the equation is still \sphinxstyleemphasis{first order}.

\sphinxAtStartPar
A general form of a \sphinxstyleemphasis{second\sphinxhyphen{}order} differential equation is:

\sphinxAtStartPar
\( \frac{ \mathrm{d}^2 y } { \mathrm{d} x^2 } + \lambda \frac{ \mathrm{d} y } { \mathrm{d} x }  = f(x, \frac{ \mathrm{d} y } { \mathrm{d} x }, y)\).

\sphinxAtStartPar
The RHS may involve any power of the first derivative as well.

\sphinxAtStartPar
In the above, \(x\) is known as the \sphinxstyleemphasis{independent} variable and \(y\) is the \sphinxstyleemphasis{dependent} variable.

\sphinxAtStartPar
\sphinxstylestrong{ORDINARY VS. PARTIAL}

\sphinxAtStartPar
\sphinxstyleemphasis{Ordinary} diffrential equations contain \sphinxstyleemphasis{just one independent} variable, e.g. \(x\) in our discussion.

\sphinxAtStartPar
In contrast, \sphinxstyleemphasis{partial} differential equations contain \sphinxstyleemphasis{several independent variables}.

\sphinxAtStartPar
E.g. the Schrödinger equation in three dimensions:

\sphinxAtStartPar
\( i \hbar \frac{ \partial \Psi(\vec{x},t) } {\partial t} = -\frac{ \hbar^2 } { 2 m } \left[ \frac{ \partial^2 \Psi} { \partial x^2 } + \frac{ \partial^2 \Psi} { \partial y^2 } + \frac{ \partial^2 \Psi} { \partial z^2 } \right] + V(\vec{x}) \Psi(\vec{x},t)\),

\sphinxAtStartPar
is a partial differential equation with four independent variables \(\vec{x} = (x,y,z)\) and \(t\), and one dependent variable \(\Psi(\vec{x},t)\).

\sphinxAtStartPar
\sphinxstylestrong{LINEAR VS. NONLINEAR}

\sphinxAtStartPar
Part of the strength of computational methods is that we are no longer limited to solving linear equations.

\sphinxAtStartPar
A \sphinxstyleemphasis{linear} equation is one in which only the first power of \(y\) or of \(\mathrm{d}^n y / \mathrm{d}x^n\) appears, e.g.:

\sphinxAtStartPar
\( \frac{ \mathrm{d} y } { \mathrm{d} x } = g(x) y(x)\) is \sphinxstyleemphasis{linear},

\sphinxAtStartPar
\( \frac{ \mathrm{d} y } { \mathrm{d} x } = \lambda y(x) - \lambda^2 y^2(x)\) is \sphinxstyleemphasis{nonlinear}.

\sphinxAtStartPar
\sphinxstyleemphasis{WARNING}: An important property of linear equations is no longer valid for nonlinear equations: the principle of superposition, that lets us add solutions together to form new ones: e.g. if \(A(x)\) is a solution and \(B(x)\) is a solution to a linear differential equation, then their sum:

\sphinxAtStartPar
\(y(x) = a A(x) + b B(x)\), is also a solution, for arbritrary values of the constants \(a\) and \(b\). This would no longer be true for a nonlinear equation!

\sphinxAtStartPar
\sphinxstylestrong{Initial and boundary conditions}

\sphinxAtStartPar
The general solution of a first\sphinxhyphen{}order differential equation always contains one arbitrary constant. The general solution of a second\sphinxhyphen{}order differential equation contains two, and so on.

\sphinxAtStartPar
For any specific problem, these constants are fixed by the initial conditions. E.g. for a first\sphinxhyphen{}order equation for \(y(x)\), the sole initial condition necessary is \(y(x=x_0)\), i.e. the value of \(y\) at some value of \(x\).

\sphinxAtStartPar
For a second\sphinxhyphen{}order equation, two initial conditions are required. These may e.g. be the position and velocity at some time when solving a problem involving Newton’s second law of motion:

\sphinxAtStartPar
\( \frac{ \mathrm{d}^2 y } { \mathrm{d} t^2 } = \frac{1}{m} F(y,t)\).

\sphinxAtStartPar
In addition to the initial conditions, it is possible to further restrict the solutions of differential equations, e.g. through \sphinxstyleemphasis{boundary conditions} that constrain one solution to have fixed values at the boundaries of the solution space.


\section{Dynamic form for ODEs}
\label{\detokenize{Chapters/Chapter7/Chapter7:dynamic-form-for-odes}}
\sphinxAtStartPar
The most general form of an ODE is a \sphinxstyleemphasis{set} of \(M\) \sphinxstyleemphasis{coupled first\sphinxhyphen{}order} differential equations:

\sphinxAtStartPar
\( \frac{ \mathrm{d} \vec{y} } { \mathrm{d} x } = \vec{f}(x,\vec{y})\),

\sphinxAtStartPar
where \(x\) is the independent variable and \(\vec{y}\) is a vector of \(M\) dependent variables. The vector of functions \(\vec{f}\) is an \(M\)\sphinxhyphen{}component vector as well.

\sphinxAtStartPar
Differential equations of higher order can be written in this first\sphinxhyphen{}order coupled form, by introducing auxiliary functions.

\sphinxAtStartPar
Consider, for example, the one\sphinxhyphen{}dimensional motion (in the \(z\) direction), of a particle of mass \(m\) under a force \sphinxstyleemphasis{field} F(z), described by the second\sphinxhyphen{}order differential equation (Newton’s second law):

\sphinxAtStartPar
\( m\frac{ \mathrm{d}^2 z } { \mathrm{d} t^2 } = F(z)\).

\sphinxAtStartPar
If we define the momentum as: \(p(t) = m \frac{ \mathrm{d} z } { \mathrm{d} t }\),

\sphinxAtStartPar
then Newton’s law becomes two coupled first\sphinxhyphen{}order equations (known as Hamilton’s equations):

\sphinxAtStartPar
\(\frac{ \mathrm{d} p } { \mathrm{d} t } = F(z)\),

\sphinxAtStartPar
\(\frac{ \mathrm{d} z } { \mathrm{d} t } = \frac{p}{m}\),

\sphinxAtStartPar
which are of the desired general form.

\sphinxAtStartPar
It is therefore sufficient to consider in detail only methods for first\sphinxhyphen{}order ODEs!

\sphinxAtStartPar
Since the matrix structure of coupled differential equations is of this natural form, we can focus on the case where there is only one independent variable, which can be generalized readily.

\sphinxAtStartPar
Thus, we will begin by consider the methods for solving:

\sphinxAtStartPar
\(\frac{ \mathrm{d} y } { \mathrm{d} x } = f(x,y)\), for a single dependent variable \(y(x)\).

\sphinxAtStartPar
In this chapter, we will discuss methods for solving ODEs, with emphasis on the initial value problem, i.e.:

\sphinxAtStartPar
Find \(y(x)\) given the value of \(y\) at some initial point, say \(y(x=0) = y_0\).

\sphinxAtStartPar
This is the kind of problem that occurs, e.g. when we are given the initial position and momentum of a particle and we wish to find its subsequent motion.

\sphinxAtStartPar
Later on, we will discuss the equally important boundary value and eigenvalue problems.


\section{ODE Algorithms}
\label{\detokenize{Chapters/Chapter7/Chapter7:ode-algorithms}}

\subsection{Euler’s Method}
\label{\detokenize{Chapters/Chapter7/Chapter7:euler-s-method}}
\sphinxAtStartPar
We are interested in the solution of \(\frac{ \mathrm{d} y } { \mathrm{d} x } = f(x,y)\), with the initial condition \(y(x=0) = y_0\).

\sphinxAtStartPar
More specifically, we are usually interested in the value of \(y\) at particular value of \(x\), say \(x=1\).

\sphinxAtStartPar
The general strategy is to divide the interval \([0,1]\) into a large number, \(N\), of equally\sphinxhyphen{}spaced subintervals of length \(h=1/N\) and then to develop a recursion formula relating \(y_n\) to \(\{y_{n-1}, y_{n-2},...\}\), where \(y_n\) is our approximation to \(y(x_n = nh)\). Such a recursion formula would then allow a step\sphinxhyphen{}by\sphinxhyphen{}step integration of the differential equation from \(x=0\) to \(x=1\).

\sphinxAtStartPar
One of the simplest algorithms is known as Euler’s method, in which we consider the differential equation at the point \(x_n\), and replace the derivative on the LHS by its forward\sphinxhyphen{}difference approximation:

\sphinxAtStartPar
\(\frac{ y_{n+1} - y_n } { h } + \mathcal{O}(h) = f(x_n , y_n)\),

\sphinxAtStartPar
so that, if we solve for \(y_{n+1}\), we obtain a recursion relation expressing \(y_{n+1}\) in terms of the “previous” value, \(y_n\):

\sphinxAtStartPar
\(y_{n+1} = y_n + h f(x_n, y_n) + \mathcal{O}(h^2)\).

\sphinxAtStartPar
The formula has a “local” error (i.e. the error made in taking a single step from \(y_n \rightarrow y_{n+1}\)) that is \(\mathcal{O}(h^2)\). The “global” error made in finding \(y(1)\), after taking \(N\) such steps in integrating from \(x=0\) to \(x=1\) is then \(N \mathcal{O}(h^2) \sim \frac{1}{h} \mathcal{O}(h^2) \sim \mathcal{O}(h)\).

\sphinxAtStartPar
Evidently, this error decreases only linearly with decreasing step size, so that if we halve \(h\) (and perform twice as many steps), we halve the error of the final answer.

\sphinxAtStartPar
Let’s apply this method to a simple problem.


\subsection{Example 7.1: An Application of Euler’s Method}
\label{\detokenize{Chapters/Chapter7/Chapter7:example-7-1-an-application-of-euler-s-method}}
\sphinxAtStartPar
Apply Euler’s method to solve:

\sphinxAtStartPar
\(\frac{ \mathrm{d} y } { \mathrm{d} x } = -xy\) with initial condition \(y(0) = 1\) from \(x=0\) to \(x=3\).

\sphinxAtStartPar
Use various step sizes: \(h=0.500, 0.200, 0.100, 0.050, 0.020, 0.010, 0.005, 0.002, 0.001\) and calculate the error relative to the analytical solution \(y(x) = \exp{-x^2/2}\) at the points \(x=1\) and \(x=3\). Does it scale as you expect with \(h\)?

\sphinxAtStartPar
Plot the \(y(x)\) for a few step sizes, e.g. \(h=0.500, 0.050, 0.001\), as well as the analytical function.


\subsection{Example 7.2: Evaluation of the Integration Algorithm}
\label{\detokenize{Chapters/Chapter7/Chapter7:example-7-2-evaluation-of-the-integration-algorithm}}
\sphinxAtStartPar
A simple and often stringent test of an accurate numerical integration is to use the final value of \(y\) obtained as the initial condition to integrate backward from the final value of \(x\) to the starting point. The extent to which the resulting value of \(y\) differs from the original initial condition is then a measure of the inaccuracy.

\sphinxAtStartPar
Apply this test to Example 7.1.

\sphinxAtStartPar
Although Euler’s method seems to work quite well, it is generally unsatisfactory due to its lower\sphinxhyphen{}order accuracy.

\sphinxAtStartPar
The algorithm is not recommended for general use, but it is commonly used to start off more precise algorithms.


\section{Runge\sphinxhyphen{}Kutta Methods}
\label{\detokenize{Chapters/Chapter7/Chapter7:runge-kutta-methods}}
\sphinxAtStartPar
There is a lot of freedom in writing down algorithms for integrating differential equations. There exists a large number of them, each having their own pecularities and advantages.

\sphinxAtStartPar
One very convenient and widely used class of methods are the Runge\sphinxhyphen{}Kutta algorithms, which come in varying orders of accuracy.

\sphinxAtStartPar
Here, we derive the second\sphinxhyphen{}order version (\sphinxcode{\sphinxupquote{rk2}}) to give the spirit of the approach and then state the equations for the fourth\sphinxhyphen{}order method.

\sphinxAtStartPar
We begin by writing down the formal integral of our differential equation:

\sphinxAtStartPar
\(\frac{ \mathrm{d} y } { \mathrm{d} x } = f(x,y)\),

\sphinxAtStartPar
as:

\sphinxAtStartPar
\(y(x) = \int f(x,y) \mathrm{d} x\),

\sphinxAtStartPar
integrating one step leads to (exactly):

\sphinxAtStartPar
\(y_{n+1} = y_n + \int_{x_n}^{x_{n+1}} f(x,y) \mathrm{d} x\).

\sphinxAtStartPar
We then expand \(f(x,y)\) in a Taylor series about the midpoint of the integration interval:

\sphinxAtStartPar
\(f(x,y) \simeq f(x_{n+1/2}, y_{n+1/2}) + (x-x_{n+1/2}) \left.\frac{ \mathrm{d} f } { \mathrm{d} x } \right|_{x_{n+1/2}} + \mathcal{O}(h^2)\).

\sphinxAtStartPar
Substituting into the expression for \(y_{n+1}\), the linear term integrates to zero because it is equally positive and negative in the interval \([x_n, x_{n+1}]\):

\sphinxAtStartPar
\(\int_{x_n}^{x_{n+1}} (x-x_{n+1/2}) \left.\frac{ \mathrm{d} f } { \mathrm{d} x } \right|_{x_{n+1/2}} \mathrm{d}x = \left.\frac{ \mathrm{d} f } { \mathrm{d} x } \right|_{x_{n+1/2}}  \int_{x_n}^{x_{n+1}} (x-x_{n+1/2}) \mathrm{d}x = 0\).

\sphinxAtStartPar
Then:

\sphinxAtStartPar
\(y_{n+1} = y_n + \left[ f(x_{n+1/2}, y_{n+1/2}) + \mathcal{O}(h^2) \right]\int_{x_n}^{x_{n+1}} \mathrm{d} x \),

\sphinxAtStartPar
which leads to:

\sphinxAtStartPar
\(y_{n+1} = y_n + h f(x_{n+1/2}, y_{n+1/2}) + \mathcal{O}(h^3)\),

\sphinxAtStartPar
where the error arises from the quadratic term in the Taylor series.

\sphinxAtStartPar
Although it seems as if we need to know the value of \(y_{n+1/2}\), appearing in \(f\) in the right\sphinxhyphen{}hand side of this equation for it to be of any use, this is not quite true:

\sphinxAtStartPar
Since the error is already \(\mathcal{O}(h^3)\), an approximation to \(y_{n+1/2}\) whose error is \(\mathcal{O}(h^2)\) is good enough. This is provided by the simple Euler’s method:

\sphinxAtStartPar
\(y_{n+1/2} = y_n + \frac{h}{2} f(x_n, y_n) + \mathcal{O}(h^2)\),

\sphinxAtStartPar
and thus, if we define \(k_1 = h f(x_n, y_n)\), we can write:

\sphinxAtStartPar
\(y_{n+1} = y_n + h f ( x_n + \frac{h}{2}, y_n + \frac{1}{2} k_1 ) + \mathcal{O}(h^3)\).

\sphinxAtStartPar
This is the second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta algorithm. It requires the evaluation of \(f\) twice for each step.

\sphinxAtStartPar
A fourth\sphinxhyphen{}order algorithm, which requires \(f\) to be evaluated four times for each integration step and has a local accuracy of \(\mathcal{O}(h^5)\) has been found by experience to give the best balance between accuracy and computational effort. It can be written as follows, with the \(k_i\)s as intermediate variables:

\sphinxAtStartPar
\(k_1 = h f(x_n, y_n)\),

\sphinxAtStartPar
\(k_2 = h f(x_n + \frac{1}{2} h, y_n  + \frac{1}{2} k_1)\),

\sphinxAtStartPar
\(k_3 = h f(x_n + \frac{1}{2} h, y_n + \frac{1}{2} k_2)\),

\sphinxAtStartPar
\(k_4 = h f(x_n + h, y_n + k_3)\),

\sphinxAtStartPar
\(y_{n+1} = y_n + \frac{1}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) + \mathcal{O}(h^5)\).


\subsection{Example 7.3: Try out the second\sphinxhyphen{} and fourth\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta methods on the problem defined in Example 7.1.}
\label{\detokenize{Chapters/Chapter7/Chapter7:example-7-3-try-out-the-second-and-fourth-order-runge-kutta-methods-on-the-problem-defined-in-example-7-1}}
\sphinxAtStartPar
Compare the accuracy of the methods.


\subsection{Application: Nonlinear Oscillators}
\label{\detokenize{Chapters/Chapter7/Chapter7:application-nonlinear-oscillators}}
\sphinxAtStartPar
With several algorithms for solving ODEs in our possession, we can now examine the behavior of oscillators beyond the harmonic approximation.

\sphinxAtStartPar
Newton’s second law provides the equation of motion for an oscillator, which could be, e.g. a mass attached to a spring moving in one dimension, \(x\):

\sphinxAtStartPar
\(F_k(x) + F_\mathrm{ext}(x,t) = m \frac{ \mathrm{d}^2 x}{\mathrm{d}t^2}\),

\sphinxAtStartPar
where \(F_k(x)\) is the restoring force, e.g. exerted by a spring, and \(F_\mathrm{ext}(x,t)\) is an external (driving) force, that may also depend on time.

\sphinxAtStartPar
Let’s examine two models that can describe the departure from linearity, with no external forces being applied (\(F_\mathrm{ext} = 0\)).

\sphinxAtStartPar
For the first model, let’s introduce a potential that is a harmonic oscillator for small displacements \(x\), but also contains a perturbation that introduces a nonlinear term to the force for large values of \(x\):

\sphinxAtStartPar
\(V_k(x) \simeq \frac{1}{2} kx^2 (1 - \frac{2}{3} \alpha x)\).

\sphinxAtStartPar
Taking he derivative, we can derive \(F_k(x)\):

\sphinxAtStartPar
\(F_k(x) = - \frac{ \mathrm{d} V_k}{\mathrm{d}x} = -kx ( 1 - \alpha x)\),

\sphinxAtStartPar
and the ODE that we need to consider has the form:

\sphinxAtStartPar
\(m \frac{ \mathrm{d}^2 x}{\mathrm{d}t^2} = -kx (1 - \alpha x)\).

\sphinxAtStartPar
For \(\alpha x \ll 1\), we recover simple harmonic motion, but as \(x \rightarrow 1/\alpha\), the \sphinxstyleemphasis{anharmonic} effects would be large.

\sphinxAtStartPar
As long as \(x < 1/\alpha\), there will be a restoring force, and the motion will be periodic. In general, there will be an asymmetry in the motion to the right and left of the equilibrium position.

\sphinxAtStartPar
As a second model for nonlinear oscillators, we will consider that the spring’s potential function is proportional to some arbitrary \sphinxstyleemphasis{even} power \(p\) of the displacement from equilibrium:

\sphinxAtStartPar
\(V(x) = \frac{1}{p} kx^p\), (\(p\) even),

\sphinxAtStartPar
such that the force is a restoring force:

\sphinxAtStartPar
\(F_k(x) =  - \frac{ \mathrm{d} V}{\mathrm{d}x} = - k x^{p-1}\).

\sphinxAtStartPar
For \(p=2\), we recover the harmonic oscillator. As \(p\) increases, the potential becomes more and more like a square well, where the mass almost moves freely inbetween “collisions” with the wall at \(x\simeq \pm 1\). Regardless of the value of \(p\), the motion will be periodic, but will only be harmonic for \(p=2\).

\sphinxAtStartPar
Newton’s law gives the second\sphinxhyphen{}order ODE that we need to solve:

\sphinxAtStartPar
\(m \frac{ \mathrm{d}^2 x}{\mathrm{d}t^2} = - k x^{p-1}\).

\sphinxAtStartPar
Following our discussion on the numerical solution of ODEs, we can reduce the second\sphinxhyphen{}order ODE into two  coupled first\sphinxhyphen{}order equations via an auxiliary variable, in this case the momentum \(p\):

\sphinxAtStartPar
\( \frac{ \mathrm{d}x}{\mathrm{d}t} = \frac{p}{m}\),

\sphinxAtStartPar
\( \frac{ \mathrm{d}p}{\mathrm{d}t} = F_k(x)\).

\sphinxAtStartPar
Let’s begin by examining simple harmonic motion, that we already know a lot about, before we consider the nonlinear cases.


\subsection{Example 7.4: Oscillator warmup: Simple Harmonic Motion}
\label{\detokenize{Chapters/Chapter7/Chapter7:example-7-4-oscillator-warmup-simple-harmonic-motion}}
\sphinxAtStartPar
(a) Generalize the single\sphinxhyphen{}variable methods that we have derived to the two\sphinxhyphen{}variable case relevant for oscillatory motion.

\sphinxAtStartPar
(b) Integrate the equations of motion for single harmonic motion, i.e. with \(F_k(x) = -kx\), for values of \(k=4\pi^2\) and \(m=1\) and verify that the period \(T\) is what you expect from your Physics I course (recall: \(T=2\pi \sqrt{m/k}\)). You may choose the initial conditions (e.g. \(p=0\) and \(x=x_0\) at \(t=t_0\), where \(x_0\) would be the amplitude).

\sphinxAtStartPar
We are now in a position to investigate nonlinear oscillations. Let’s consider our two models in Exercise 7.1.

\sphinxstepscope


\chapter{An Introduction to Nonlinear Dynamics and Chaos}
\label{\detokenize{Chapters/Chapter8/Chapter8:an-introduction-to-nonlinear-dynamics-and-chaos}}\label{\detokenize{Chapters/Chapter8/Chapter8::doc}}

\section{Introduction}
\label{\detokenize{Chapters/Chapter8/Chapter8:introduction}}
\sphinxAtStartPar
We have already had a glimpse at nonlinear systems, e.g. in the case of the pendulum without the small\sphinxhyphen{}angle approximation. The aim of this chapter is to provide a brief foray into some of the formal aspects of the analysis of dynamical nonlinear systems, while introducing concepts such as flows in phase space, fixed points, linearization, and chaotic systems.

\sphinxAtStartPar
All of these concepts are part of the subject of dynamics, i.e. the study of systems that evolve in time.

\sphinxAtStartPar
We will use the computational knowledge we have gained thus far to obtain a quantitative understanding of some simple systems.


\section{The Importance of being Nonlinear}
\label{\detokenize{Chapters/Chapter8/Chapter8:the-importance-of-being-nonlinear}}
\sphinxAtStartPar
There are two types of dynamical systems: differential equations and iterated maps (or difference equations). Here we will study differential equations, since we already have the machinery developed to solve them, even in their nonlinear form.

\sphinxAtStartPar
Why are nonlinear problems harder to solve than linear ones?

\sphinxAtStartPar
The answer lies in the fact that linear systems can be broken down into parts. Each part can be solved sparately and finally recombined to get an answer. This allows for fantastic simplification of complex problems, and underlies methods such as normal modes, Laplace transforms, superposition arguments, and Fourier analysis.

\sphinxAtStartPar
A linear system is precisely equal to the sum of its parts!

\sphinxAtStartPar
But many things in nature don’t act this way, e.g. whenever parts of a system interfere, or cooperate, or compete, there are nonlinear interactions going on.

\sphinxAtStartPar
Most of everyday life is nonlinear and the principle of superposition fails spectacularly!

\sphinxAtStartPar
Within the realm of physics, nonlinearity is vital to the operation of a laser, the formation of turbulence in a fluid, and the superconductivity of Josephson junctions.


\section{Flows on the Line}
\label{\detokenize{Chapters/Chapter8/Chapter8:flows-on-the-line}}

\subsection{Fixed Points and Stability}
\label{\detokenize{Chapters/Chapter8/Chapter8:fixed-points-and-stability}}
\sphinxAtStartPar
Let’s start by examining a one\sphinxhyphen{}dimensional, or first\sphinxhyphen{}order system, described by a differential equation of the form:

\sphinxAtStartPar
\(\dot{x} = f(x)\),

\sphinxAtStartPar
where, as usual, \(\dot{~} \equiv \mathrm{d}/\mathrm{d}t\).

\sphinxAtStartPar
Pictures are often more helpful than formulas when analyzing a nonlinear system.

\sphinxAtStartPar
Consider \(\dot{x} = \sin x\). The general solution is:

\sphinxAtStartPar
\(t = - \ln | \csc x + \cot x | + C\).

\sphinxAtStartPar
If the initial condition is \(x=x_0\) at \(t=0\), then:

\sphinxAtStartPar
\(t = \ln \left| \frac{ \csc x_0 + \cot x_0 }{\csc x + \cot x} \right|\).

\sphinxAtStartPar
The result is exact, but it is a headache to interpret!

\sphinxAtStartPar
In contrast, a graphical analysis is clear and simple.

\sphinxAtStartPar
Think of \(t\) as time, \(x\) as the position of an imaginary particle moving along the real line (i.e. left or right), and \(\dot{x}\) the velocity of the particle.

\sphinxAtStartPar
\(\dot{x} = f(x)\) represents a \sphinxstyleemphasis{vector field} along the line. The differential equation dictates the velocity \(\dot{x}\) at each \(x\).

\sphinxAtStartPar
To sketch the vector field, it is convenient to plot \(\dot{x}\) versus \(x\), then draw arrows on the \(x\)\sphinxhyphen{}axis to indicate the corresponding velocity vector \(\dot{x}\) at each \(x\).

\sphinxAtStartPar
Arrows would point to the right when \(\dot{x} > 0\) and to the left when \(\dot{x} < 0\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} }
\PYG{n}{xdot} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} 

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dot}\PYG{l+s+si}{\PYGZob{}x\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A vector field on the line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{1.1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{xdot}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mf}{1.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticklabels}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZhy{}3}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}5}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZhy{}2}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZhy{}3}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZhy{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZhy{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}3}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}2}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}5}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}3}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfpu} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{]}
\PYG{n}{yfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfpu}\PYG{p}{,} \PYG{n}{yfpu}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vector origin location }
\PYG{n}{X} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{]} 
\PYG{n}{Y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} 
  
\PYG{c+c1}{\PYGZsh{} Directional vectors }
\PYG{n}{U} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{]}   
\PYG{n}{V} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}   
\PYG{c+c1}{\PYGZsh{} Creating plot }
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.08}\PYG{p}{)} 

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} }

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}matplotlib\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A more physical way to think of the vector field: imagine that a fluid is flowing steadily along the \(x\)\sphinxhyphen{}axis with a velocity that varies from place to place, according to \(\dot{x} = \sin x\). The flow is to the right when \(\dot{x} > 0\) and to the left when \(\dot{x} < 0\).

\sphinxAtStartPar
At points where \(\dot{x} =0\), there is no flow! These are the \sphinxstyleemphasis{fixed points}.

\sphinxAtStartPar
From the graph, we can see that there are two kinds of fixed points: solid dots represent \sphinxstyleemphasis{stable fixed points}, often called attractors or sinks, because the flow is toward them. Open circles represent unstable fixed points, also called repellers or sources.

\sphinxAtStartPar
Armed with this picture, we can easily understand the solutions of the differential equation \(\dot{x} = \sin x\) qualitatively:

\sphinxAtStartPar
We start an imaginary particle at \(x_0\) and watch how it is carried along by the flow. E.g. a particle starting at \(x_0 = \pi/4\) moves to the right faster and faster until it crosses \(\pi/2\), where \(\sin x\) reaches its maximum, and eventually approaches the stable fixed point \(x=\pi\) from the left:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{o}{+}\PYG{l+m+mf}{0.00000001}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.000001}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)} 
\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{tan}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{tan}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Evolution of \PYGZdl{}x\PYGZus{}0=}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/4\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis ticks, labels, and aspect}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticklabels}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi/4\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{y}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{ls}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{14cb28c77ad971920d1341e353354e2534b7825f467f299d4ff69d942cde6bb4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A picture cannot tell us certain quantitative things, but can still give us a good understanding of the physical situation. We can then use numerical methods to understand the solutions quantitatively.

\sphinxAtStartPar
The ideas can be extended to any one\sphinxhyphen{}dimensional system of the form \(\dot{x} = f(x)\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} }
\PYG{n}{xdot} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dot}\PYG{l+s+si}{\PYGZob{}x\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A vector field on the line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{xdot}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5396}\PYG{p}{]}
\PYG{n}{yfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfpu}\PYG{p}{,} \PYG{n}{yfpu}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.32941}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vector origin location }
\PYG{n}{X} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5396}\PYG{p}{,} \PYG{l+m+mf}{1.539}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.32941}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.8}\PYG{p}{]} 
\PYG{n}{Y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} 
  
\PYG{c+c1}{\PYGZsh{} Directional vectors }
\PYG{n}{U} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.32941}\PYG{o}{+}\PYG{l+m+mf}{0.9}\PYG{p}{]}   
\PYG{n}{V} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{]}   
\PYG{c+c1}{\PYGZsh{} Creating plot }
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.035}\PYG{p}{)} 

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{dbeb4e7d1342e6a56fdf644c279fffa9027f321cb75b2c20802d7a747ff85c04}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} }
\PYG{n}{xdot} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dot}\PYG{l+s+si}{\PYGZob{}x\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A vector field on the line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{xdot}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a sine curve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5396}\PYG{p}{]}
\PYG{n}{yfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfpu}\PYG{p}{,} \PYG{n}{yfpu}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.32941}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vector origin location }
\PYG{n}{X} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5396}\PYG{p}{,} \PYG{l+m+mf}{1.539}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.32941}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.8}\PYG{p}{]} 
\PYG{n}{Y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} 
  
\PYG{c+c1}{\PYGZsh{} Directional vectors }
\PYG{n}{U} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.32941}\PYG{o}{+}\PYG{l+m+mf}{0.9}\PYG{p}{]}   
\PYG{n}{V} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{]}   
\PYG{c+c1}{\PYGZsh{} Creating plot }
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.035}\PYG{p}{)} 

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{dbeb4e7d1342e6a56fdf644c279fffa9027f321cb75b2c20802d7a747ff85c04}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This imaginary fluid is called the \sphinxstyleemphasis{phase fluid}, and the real line is the \sphinxstyleemphasis{phase space}.

\sphinxAtStartPar
To find a solution to \(\dot{x} = f(x)\) starting from an arbitrary initial condition \(x_0\), we place an imaginary particle (a \sphinxstyleemphasis{phase point}) at \(x_0\) and watch how it is carried along by the flow. As time goes on, the phase point moves along the \(x\)\sphinxhyphen{}axis according to some function \(x(t)\). This function is called the \sphinxstyleemphasis{trajectory} based at \(x_0\), and it represents the solution to the differential equation starting from \(x_0\). A picture like the one above, which shows qualitatively all the trajectories of the system, is called a \sphinxstyleemphasis{phase portrait}.

\sphinxAtStartPar
The appearance of the phase portrait is controlled by the fixed points \(x^*\), defined by \(f(x^*)=0\). These are stagnation points of the flow. Solid dots are stable fixed points (the local flow is towards them), and open dots are unstable fixed points (the flow is away from them).

\sphinxAtStartPar
In terms of the differential equation, the fixed points represent equilibrium solutions. An equlibrium is defined to be stable if all sufficiently small disturbances away from it damp out in time. Conversely, unstable equilibria, which disturbances grow in time, are represented by unstable fixed points.


\subsection{Example 8.1: Find all the fixed points for \textbackslash{}dot\{x\} = x\textasciicircum{}2 \sphinxhyphen{}1, and classify their stability.}
\label{\detokenize{Chapters/Chapter8/Chapter8:example-8-1-find-all-the-fixed-points-for-dot-x-x-2-1-and-classify-their-stability}}
\sphinxAtStartPar
We note here that the definition of stable equilibrium is based on \sphinxstyleemphasis{small} disturbances: large disturbances may fail to decay. To emphasize this aspect of stability, we may characterize a fixed point as \sphinxstyleemphasis{locally stable} and not globally stable.


\section{Linear Stability Analysis}
\label{\detokenize{Chapters/Chapter8/Chapter8:linear-stability-analysis}}
\sphinxAtStartPar
We would like to have a more quantitative measure of stability, such as the rate of decay to a stable fixed point. To achieve this, we \sphinxstyleemphasis{linearize} about a fixed point.

\sphinxAtStartPar
Let \(x^*\) be a fixed point and consider a small perturbation \(\eta(t)\) away from \(x^*\): \(x(t) = x^* + \eta(t)\). Evidently, since \(x^*\) is a constant:

\sphinxAtStartPar
\(\dot{\eta} = \dot{x}\), and so: \(\dot{\eta} = f(x) = f(x^* + \eta)\).

\sphinxAtStartPar
If we now Taylor\sphinxhyphen{}expand the right\sphinxhyphen{}hand side:

\sphinxAtStartPar
\(\dot{\eta} = f(x^*) + \eta f'(x^*) + \mathcal{O}(\eta^2)\),

\sphinxAtStartPar
where \(' \equiv \mathrm{d}/\mathrm{d}x\).

\sphinxAtStartPar
Since \(f(x^*) = 0\) for the fixed point \(x^*\), and neglecting the terms \(\mathcal{O}(\eta^2)\), we have:

\sphinxAtStartPar
\(\dot{\eta} \approx \eta f'(x^*)\).

\sphinxAtStartPar
This is a linear equation in \(\eta\), known as the \sphinxstyleemphasis{linearization} about \(x^*\). It shows that the perturbation grows exponentially if \(f'(x^*) > 0\), and decays if \(f'(x^*) < 0\), since:

\sphinxAtStartPar
\(\eta(t) \approx \eta(0) \exp( f'(x^*) t)\).

\sphinxAtStartPar
Therefore, the slope, \(f'(x^*)\) at the fixed point determines its stability.

\sphinxAtStartPar
The value \(|1/f'(x^*)|\) is a characteristic time scale, and determines the time required for \(x(t)\) to vary significantly in the neighborhood of \(x^*\).


\subsection{Example 8.2: Use linearization to determine the stability of the fixed points for \textbackslash{}dot\{x\} = \textbackslash{}sin x.}
\label{\detokenize{Chapters/Chapter8/Chapter8:example-8-2-use-linearization-to-determine-the-stability-of-the-fixed-points-for-dot-x-sin-x}}

\section{Two\sphinxhyphen{}Dimensional Systems}
\label{\detokenize{Chapters/Chapter8/Chapter8:two-dimensional-systems}}
\sphinxAtStartPar
Let’s now consider the simplest class of a higher\sphinxhyphen{}dimensional system, one in two dimensions (2D). We will start with \sphinxstyleemphasis{linear} systems, which are interesting in their own right, but play an important role in the classification of fixed points of nonlinear systems.


\subsection{2D Linear Systems}
\label{\detokenize{Chapters/Chapter8/Chapter8:d-linear-systems}}
\sphinxAtStartPar
A 2D linear system is defined by:

\sphinxAtStartPar
\(\dot{x} = a x + b y\),

\sphinxAtStartPar
\(\dot{y} = c x + d y\).

\sphinxAtStartPar
This can be written compactly in matrix form as:

\sphinxAtStartPar
\(\mathbf{\dot{x}} = A \mathbf{x}\),

\sphinxAtStartPar
where \(\mathbf{x} = \left(\matrix{x\\y}\right)\), and \(A = \left(\matrix{a & b\\ c & d}\right)\).

\sphinxAtStartPar
In this case, \(\mathbf{\dot{x}} = \mathbf{0}\) when \(\mathbf{x} = \mathbf{0}\), and therefore \(\mathbf{x}^* = \mathbf{0}\) for any choice of \(A\).

\sphinxAtStartPar
The solutions of \(\mathbf{\dot{x}} = A \mathbf{x}\) can be visualized as trajectories moving on the \((x,y)\) plane, in this context called the \sphinxstyleemphasis{phase plane}.


\subsection{Example 8.3: Analysis of the Simple Harmonic Oscillator.}
\label{\detokenize{Chapters/Chapter8/Chapter8:example-8-3-analysis-of-the-simple-harmonic-oscillator}}
\sphinxAtStartPar
Vibrations of a mass hanging from a linear spring are governed by the linear differential equation:

\sphinxAtStartPar
\(m \ddot{x} + kx = 0\), where \(m\) is the mass, \(k\) is the spring constant, and \(x\) is the displacement of the mass from equilibrium.

\sphinxAtStartPar
Give a phase plane analysis of this simple harmonic oscillator.


\subsection{Classification of Linear Systems}
\label{\detokenize{Chapters/Chapter8/Chapter8:classification-of-linear-systems}}
\sphinxAtStartPar
Let’s discuss a more general approach of the classification of linear systems, by examining an example system:

\sphinxAtStartPar
\(\mathbf{\dot{x}} = A \mathbf{x}\),

\sphinxAtStartPar
where: \(A = \left(\matrix{a & 0\\ 0 & -1}\right)\).

\sphinxAtStartPar
Multiplying out:

\sphinxAtStartPar
\(\dot{x} = ax\),

\sphinxAtStartPar
\(\dot{y} = -y\).

\sphinxAtStartPar
Therefore, the equations are \sphinxstyleemphasis{uncoupled}: there’s no \(x\) in the \(y\)\sphinxhyphen{}equation and vice versa. In this simple case, the equation may be solved separately:

\sphinxAtStartPar
\(x(t) = x_0 e^{at}\),

\sphinxAtStartPar
\(y(t) = y_0 e^{-t}\).

\sphinxAtStartPar
The phase portraits are shown below for different values of the parameter \(a\). In each case, \(y(t)\) decays exponentially. When \(a<0\), \(x(t)\) also decays exponentially, and so all trajectories approach the origin as \(t\rightarrow \infty\). However, the direction of approach depends on the size of \(a\) compared to \sphinxhyphen{}1.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} the parameter a:}
\PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} the initial condition combinations: }
\PYG{n}{x0} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}



\PYG{c+c1}{\PYGZsh{}t = np.concatenate((np.linspace(\PYGZhy{}2, \PYGZhy{}0.1,100),np.geomspace(\PYGZhy{}0.1, 1E\PYGZhy{}6, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.geomspace(1E\PYGZhy{}6, 0.1, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.linspace(\PYGZhy{}2, 2,100)))}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{xz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{xz} \PYG{o+ow}{in} \PYG{n}{x0}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{yz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{yz} \PYG{o+ow}{in} \PYG{n}{y0}\PYG{p}{]}



\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a\PYGZlt{}\PYGZhy{}1\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a1} \PYG{o}{=} \PYG{l+m+mi}{80}
    \PYG{n}{fac} \PYG{o}{=} \PYG{l+m+mf}{0.06}
    \PYG{n}{fac2} \PYG{o}{=} \PYG{l+m+mf}{0.045}
    \PYG{n}{wa} \PYG{o}{=} \PYG{l+m+mf}{0.04}
    \PYG{c+c1}{\PYGZsh{}print(x[i][a1], y[i][a1])}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{fac}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{x0}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(} \PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{x0}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y0}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{fac2}\PYG{o}{*}\PYG{n}{y0}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(} \PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{x0}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{y0}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{wa}\PYG{p}{)} 


\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{c+c1}{\PYGZsh{}xfpu = [1]}
\PYG{c+c1}{\PYGZsh{}yfpu = [0]}
\PYG{c+c1}{\PYGZsh{}plt.scatter(xfpu, yfpu, s=80, facecolors=\PYGZsq{}none\PYGZsq{}, edgecolors=\PYGZsq{}r\PYGZsq{}, zorder=11)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{0.08}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}ax.axhline(y=0, color=\PYGZsq{}k\PYGZsq{}, alpha=0.5)}
\PYG{c+c1}{\PYGZsh{}ax.axvline(x=0, color=\PYGZsq{}k\PYGZsq{})}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{e7bccabcd7e9ae3be8e70aef6a71c9f52b226508851c8581cc37e7d6d1157798}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
For \(a<-1\), \(x(t)\) decays more rapidly than \(y(t)\). The trajectories approach the origin tangent to the slower direction. \(\mathbf{x}^* = \mathbf{0}\) is a \sphinxstyleemphasis{stable node}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} the parameter a:}
\PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} the initial condition combinations: }
\PYG{n}{x0} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{xz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{xz} \PYG{o+ow}{in} \PYG{n}{x0}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{yz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{yz} \PYG{o+ow}{in} \PYG{n}{y0}\PYG{p}{]}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a=\PYGZhy{}1\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a1} \PYG{o}{=} \PYG{l+m+mi}{85}
    \PYG{n}{fac} \PYG{o}{=} \PYG{l+m+mi}{5}
    \PYG{n}{wa} \PYG{o}{=} \PYG{l+m+mf}{0.005}
    \PYG{c+c1}{\PYGZsh{}print(x[i][a1], y[i][a1])}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{fac}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{wa}\PYG{p}{)} 


\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{c+c1}{\PYGZsh{}xfpu = [1]}
\PYG{c+c1}{\PYGZsh{}yfpu = [0]}
\PYG{c+c1}{\PYGZsh{}plt.scatter(xfpu, yfpu, s=80, facecolors=\PYGZsq{}none\PYGZsq{}, edgecolors=\PYGZsq{}r\PYGZsq{}, zorder=11)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}ax.axhline(y=0, color=\PYGZsq{}k\PYGZsq{}, alpha=0.5)}
\PYG{c+c1}{\PYGZsh{}ax.axvline(x=0, color=\PYGZsq{}k\PYGZsq{})}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{32a98c1d4afc202ee6cc4d05c6371db10b7c82c2729488799ef8d7d3bfb358e6}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When \(a=-1\), all trajectories are straight lines through the origin. This occurs because the decay rates in the two directions are precisely equal. In this case \(\mathbf{x}^*\) is called a symmetrical node or a \sphinxstyleemphasis{star}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} the parameter a:}
\PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.8}

\PYG{c+c1}{\PYGZsh{} the initial condition combinations: }
\PYG{n}{x0} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{]}



\PYG{c+c1}{\PYGZsh{}t = np.concatenate((np.linspace(\PYGZhy{}2, \PYGZhy{}0.1,100),np.geomspace(\PYGZhy{}0.1, 1E\PYGZhy{}6, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.geomspace(1E\PYGZhy{}6, 0.1, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.linspace(\PYGZhy{}2, 2,100)))}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{xz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{xz} \PYG{o+ow}{in} \PYG{n}{x0}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{yz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{yz} \PYG{o+ow}{in} \PYG{n}{y0}\PYG{p}{]}



\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZhy{}1\PYGZlt{}a\PYGZlt{}0\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a1} \PYG{o}{=} \PYG{l+m+mi}{92}
    \PYG{n}{fac} \PYG{o}{=} \PYG{l+m+mi}{4}
    \PYG{n}{fac2} \PYG{o}{=} \PYG{l+m+mf}{1.5}
    \PYG{n}{wa} \PYG{o}{=} \PYG{l+m+mf}{0.02}
    \PYG{c+c1}{\PYGZsh{}print(x[i][a1], y[i][a1])}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{fac}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fac2}\PYG{o}{*}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{wa}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{c+c1}{\PYGZsh{}xfpu = [1]}
\PYG{c+c1}{\PYGZsh{}yfpu = [0]}
\PYG{c+c1}{\PYGZsh{}plt.scatter(xfpu, yfpu, s=80, facecolors=\PYGZsq{}none\PYGZsq{}, edgecolors=\PYGZsq{}r\PYGZsq{}, zorder=11)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{0.08}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}ax.axhline(y=0, color=\PYGZsq{}k\PYGZsq{}, alpha=0.5)}
\PYG{c+c1}{\PYGZsh{}ax.axvline(x=0, color=\PYGZsq{}k\PYGZsq{})}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{604d86dcd43d6400c7987a3b23a25f75d30fbcbb9ad269f323824d40de9543e8}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When \(-1 < a < 0\), we again have a stable node, but now the trajectories approach \(\mathbf{x}^*\) along the \(x\)\sphinxhyphen{}direction, which is the more slowly decaying direction.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} the parameter a:}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{} the initial condition combinations: }
\PYG{n}{x0} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}t = np.concatenate((np.linspace(\PYGZhy{}2, \PYGZhy{}0.1,100),np.geomspace(\PYGZhy{}0.1, 1E\PYGZhy{}6, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.geomspace(1E\PYGZhy{}6, 0.1, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.linspace(\PYGZhy{}2, 2,100)))}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{logspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{xz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{xz} \PYG{o+ow}{in} \PYG{n}{x0}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{yz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{yz} \PYG{o+ow}{in} \PYG{n}{y0}\PYG{p}{]}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a=0\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a1} \PYG{o}{=} \PYG{l+m+mi}{87}
    \PYG{n}{fac} \PYG{o}{=} \PYG{l+m+mi}{4}
    \PYG{n}{fac2} \PYG{o}{=} \PYG{l+m+mf}{1.5}
    \PYG{n}{wa} \PYG{o}{=} \PYG{l+m+mf}{0.02}
    \PYG{c+c1}{\PYGZsh{}print(x[i][a1], y[i][a1])}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{fac2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{wa}\PYG{p}{)} 

\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{c+c1}{\PYGZsh{}xfpu = [1]}
\PYG{c+c1}{\PYGZsh{}yfpu = [0]}
\PYG{c+c1}{\PYGZsh{}plt.scatter(xfpu, yfpu, s=80, facecolors=\PYGZsq{}none\PYGZsq{}, edgecolors=\PYGZsq{}r\PYGZsq{}, zorder=11)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfps} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{yfps} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfps}\PYG{p}{,} \PYG{n}{yfps}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}ax.axvline(x=0, color=\PYGZsq{}k\PYGZsq{})}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{9e136ec66df6d6f2ca9f4f65a3ff04fa2d35bcaa582571ab502f5897e116798d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Something dramatic happens when \(a=0\): there’s an \sphinxstyleemphasis{entire line} of fixed points along the \(x\)\sphinxhyphen{}axis. All trajectories approach these fixed points along vertical lines.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} import matplotlib, a conventional module name is plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} the parameter a:}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.5}

\PYG{c+c1}{\PYGZsh{} the initial condition combinations: }
\PYG{n}{x0} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}t = np.concatenate((np.linspace(\PYGZhy{}2, \PYGZhy{}0.1,100),np.geomspace(\PYGZhy{}0.1, 1E\PYGZhy{}6, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.geomspace(1E\PYGZhy{}6, 0.1, 1000)))}
\PYG{c+c1}{\PYGZsh{}t = np.concatenate((t,np.linspace(\PYGZhy{}2, 2,100)))}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{xz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{xz} \PYG{o+ow}{in} \PYG{n}{x0}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{yz}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{yz} \PYG{o+ow}{in} \PYG{n}{y0}\PYG{p}{]}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}a\PYGZgt{}0\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{,}\PYG{l+m+mf}{5.0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} make one\PYGZhy{}dimensional plots using the above arrays, add a custom label, linestyles and colors:}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a1} \PYG{o}{=} \PYG{l+m+mi}{50}
    \PYG{n}{fac} \PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{n}{wa} \PYG{o}{=} \PYG{l+m+mf}{0.10}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{fac}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fac}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{wa}\PYG{p}{)} 


\PYG{c+c1}{\PYGZsh{} change the axis labels to correspond to [0, pi/2, pi, 1.5 * pi, 2*pi, 2.5*pi, 3*pi]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{n}{xfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{yfpu} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{xfpu}\PYG{p}{,} \PYG{n}{yfpu}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the fixed points: }
\PYG{c+c1}{\PYGZsh{}xfps = [0]}
\PYG{c+c1}{\PYGZsh{}yfps = [0]}
\PYG{c+c1}{\PYGZsh{}plt.scatter(xfps, yfps, s=80, facecolors=\PYGZsq{}r\PYGZsq{}, edgecolors=\PYGZsq{}r\PYGZsq{}, zorder=11)}

\PYG{c+c1}{\PYGZsh{} the axes:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}ax.axvline(x=0, color=\PYGZsq{}k\PYGZsq{})}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} show the plot here}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{fba5a47a1e2ca864e40f34ad9b51580cddd9f78bbe64d73573d5a99d976ddcb7}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Finally, when \(a>0\), \(\mathbf{x}^*=\mathbf{0}\) becomes unstable, due to the exponential growth in the \(x\)\sphinxhyphen{}direction. Most trajectories veer away from \(\mathbf{x}^*\) and head out to infinity, with the exception of those that start on the \(y\)\sphinxhyphen{}axis. Here \(\mathbf{x}^*\) is called a \sphinxstyleemphasis{saddle point}.

\sphinxAtStartPar
In general, if \(\mathbf{x}^*\) is an attracting fixed point if all trajectories that start near it approach it as \(t \rightarrow \infty\). If \sphinxstyleemphasis{all} the trajectories in the phase plane are attracted to it, it is also \sphinxstyleemphasis{globally attracting}

\sphinxAtStartPar
We say that a fixed point \(\mathbf{x}^*\) is \sphinxstyleemphasis{Liapunov stable} if all trajectories that start sufficintly close to it, remain close to it for all time. E.g., the case of \(a=0\) in the aboce example is Liapunov stable, but not attractive. When a fixed point is Liapunov stable but not attractive, we say that it is \sphinxstyleemphasis{neutrally stable}. In that case, nearby trajectories are neither attracted nor repelled from a neutrally stable fixed point.

\sphinxAtStartPar
The equilibrium point of a SHO is neutrally stable. Neutral stability is commonly encountered in mechanical systems in the absence of friction.

\sphinxAtStartPar
If a fixed point is Liapunov stable and attracting, we call it \sphinxstyleemphasis{stable} or \sphinxstyleemphasis{asymptotically stable}. If the fixed point is unstable, it can be neither attractive nor Liapunov stable.

\sphinxAtStartPar
Let’s study the general case of a two\sphinxhyphen{}dimensional linear system i.e. described by a \(2 \times 2\) matrix, with the aim of classifying all the possible phase portraits that can occur.

\sphinxAtStartPar
In the example of the preceding section, the \(x\)\sphinxhyphen{} and \(y\)\sphinxhyphen{}axes played a crucial geometric role. They determined the direction of the trajectories as \(t\rightarrow \pm \infty\). They also contained special straight\sphinxhyphen{}line trajectories: a trajectory starting on one of the coordinate axes stayed on that axis forever, and exhibited simple exponential growth or decay along it.

\sphinxAtStartPar
For the general case, we would like to find the analog of these straight line trajectories.

\sphinxAtStartPar
That is, we seek trajectories of the form:

\sphinxAtStartPar
\(\mathbf{x}(t) = e^{\lambda t} \mathbf{v}\),

\sphinxAtStartPar
where \(\mathbf{v} \neq \mathbf{0}\) is some \sphinxstyleemphasis{fixed} vector to be determined, and \(\lambda\) is a growth rate, also to be determined. If such solutions exist, they correspond to exponential motion along the line spanned by the vector \(\mathbf{v}\).

\sphinxAtStartPar
To find the conditions on \(\mathbf{v}\) and \(\lambda\), we substitute \(\mathbf{x}(t) = e^{\lambda t} \mathbf{v}\) into \(\mathbf{\dot{x}} = A \mathbf{x}\), to obtain:

\sphinxAtStartPar
\( \lambda e^{\lambda t} \mathbf{v} = \lambda e^{\lambda t} A \mathbf{v}\),

\sphinxAtStartPar
to obtain:

\sphinxAtStartPar
\( \lambda \mathbf{v} = A \mathbf{v}\),

\sphinxAtStartPar
which tells us that the desired straight line solutions exist if \(\mathbf{v}\) is an \sphinxstyleemphasis{eigenvector} of \(A\) with corresponding \sphinxstyleemphasis{eigenvalue} \(\lambda\).

\sphinxAtStartPar
For the case of \(A = \left(\matrix{a & b\\ c & d}\right)\), the characteristic equation becomes:

\sphinxAtStartPar
\(\mathrm{det}\left(\matrix{a & b\\ c & d}\right) = 0\),

\sphinxAtStartPar
which yields:

\sphinxAtStartPar
\(\lambda^2 + \tau \lambda + \Delta =0\),

\sphinxAtStartPar
with \(\tau = \mathrm{Tr}(A) = a + d\) and \(\Delta = \mathrm{det}(A) = ad - bc\).

\sphinxAtStartPar
Then:

\sphinxAtStartPar
\(\lambda_{1,2} = \frac{ \tau \pm \sqrt{\tau^2 - 4 \Delta} } { 2}\),

\sphinxAtStartPar
are the solutions of the quadratic equation.

\sphinxAtStartPar
The typical situation is to have distinct eigenvalues \(\lambda_1 \neq \lambda_2\), in this case linear algebra tells us that the corresponding eigenvectors \(\mathbf{v_1}\) and \(\mathbf{v_2}\) are \sphinxstyleemphasis{linearly independent}, and hence they span the entire plane.

\sphinxAtStartPar
For example, any initial condition \(\mathbf{x_0}\) can be written as a linear combination of eigenvectors, say:

\sphinxAtStartPar
\(\mathbf{x_0} = c_1 \mathbf{v_1} + c_2 \mathbf{v_2}\). Then, the \sphinxstyleemphasis{general solution} for \(\mathbf{x}(t)\) is simply:

\sphinxAtStartPar
\(\mathbf{x}(t) = c_1 e^{\lambda_1 t} \mathbf{v_1} + c_2 e^{\lambda_2 t}\mathbf{v_2}\).

\sphinxAtStartPar
(It satisfies the initial condition and it is a linear combination of solutions, hence it is itself a solution.)


\subsection{Example 8.4: Solve the initial value problem \textbackslash{}dot\{x\} = x + y, \textbackslash{}dot\{y\} = 4 x \sphinxhyphen{} 2y with initial condition (x\_0, y\_0) = (2,\sphinxhyphen{}3).}
\label{\detokenize{Chapters/Chapter8/Chapter8:example-8-4-solve-the-initial-value-problem-dot-x-x-y-dot-y-4-x-2y-with-initial-condition-x-0-y-0-2-3}}
\sphinxAtStartPar
Fortunately, we don’t need to go through the procedure of Example 8.4 to draw the phase portraot of a linear system: all we need to know are the eigenvalues and eigenvectors:

\sphinxAtStartPar
If \(\lambda_1, \lambda_2 < 0\), there exists a stable fixed point at the origin. If on the other hand \(\lambda_1, \lambda_2 > 0\), the node is unstable. If one of the eigenvalues is positive and the other negative, the node is a saddle point.

\sphinxAtStartPar
What if the eigenvalues are complex? Then the solution is a \sphinxstyleemphasis{center} or a (stable or unstable) \sphinxstyleemphasis{spiral}.

\sphinxAtStartPar
if the eigenvalues are equal, then we have a \sphinxstyleemphasis{star node}.

\sphinxAtStartPar
(And if there’s only one eigenvalue, the fixed point is a \sphinxstyleemphasis{degenerate node}).


\section{The Phase Plane and Phase Portraits}
\label{\detokenize{Chapters/Chapter8/Chapter8:the-phase-plane-and-phase-portraits}}
\sphinxAtStartPar
Our goal here of course is to study nonlinear systems. In 2D, the general form of a vector field on the phase plane is given by:

\sphinxAtStartPar
\(\dot{x}_1 = f_1(x_1, x_2)\),

\sphinxAtStartPar
\(\dot{x}_2 = f_2(x_1, x_2)\),

\sphinxAtStartPar
where \(f_{1,2}\) are given functions.

\sphinxAtStartPar
We may also write the system more compactly in vector notation as:

\sphinxAtStartPar
\(\mathbf{\dot{x}} = \mathbf{f}(\mathbf{x})\), where \(\mathbf{x} = (x_1, x_2)\) and \(\mathbf{f}(\mathbf{x}) = (f_1(\mathbf{x}), f_2(\mathbf{x}))\).

\sphinxAtStartPar
Here, \(\mathbf{x}\) represents a point on the phase plane and \(\mathbf{\dot{x}}\) is the velocity vector at that point. By flowing along the vector field, a phase point traces out a solution \(\mathbf{x}(t)\), corresponding to a trajectory winding through the phase plane.

\sphinxAtStartPar
Furthermore, the entire phase plane is filled with trajectories, since each point can play the role of an initial condition.

\sphinxAtStartPar
For nonlinear systems, there’s typically no hope of finding the trajectories analytically. Even when explicit formulas are available, they are often too complicated to provide much insight. Instead, we wish to determine first the qualitative behavior of the solutions by analytical considerations, and to probe the quantitative aspects numerically.


\section{Fixed Points and Linearization}
\label{\detokenize{Chapters/Chapter8/Chapter8:fixed-points-and-linearization}}
\sphinxAtStartPar
To examine the nature of fixed points of nonlinear systems, we can apply the \sphinxstyleemphasis{linearization} technique in two dimensions.

\sphinxAtStartPar
Consider the system:

\sphinxAtStartPar
\(\dot{x} = f(x,y)\),

\sphinxAtStartPar
\(\dot{y} = g(x,y)\),

\sphinxAtStartPar
and suppose that \((x^*, y^*)\) is a fixed point, i.e.:

\sphinxAtStartPar
\(f(x^*, y^*) = 0\) and \(g(x^*, y^*) = 0\).

\sphinxAtStartPar
Let \(u = x - x^*\) and \(v = y-y^*\) be small disturbances from the fixed point.

\sphinxAtStartPar
To see whether the disturbance grows or decays, we need to derive differential equations for \(u\) and \(v\):

\sphinxAtStartPar
\(\dot{u} = \dot{x} = f(x^* + u, y^* + v)\).

\sphinxAtStartPar
Taylor\sphinxhyphen{}expand the function on the right\sphinxhyphen{}hand side about \((x^*, y^*)\) to get:

\sphinxAtStartPar
\(\dot{u} = f(x^*, y^*) + u \frac{\partial f}{\partial x} + v \frac{\partial f}{\partial y}  + \mathcal{O}(u^2, v^2, uv)\).

\sphinxAtStartPar
Since \(f(x^*, y^*) = 0\), we end up with:

\sphinxAtStartPar
\(\dot{u} = u \left.\frac{\partial f}{\partial x}\right|_* + v \left.\frac{\partial f}{\partial y}\right|_*  + \mathcal{O}(u^2, v^2, uv)\).

\sphinxAtStartPar
Similarly, for \(v\), we get:

\sphinxAtStartPar
\(\dot{v} = u \left.\frac{\partial g}{\partial x}\right|_*  + v \left.\frac{\partial g}{\partial y}\right|_*   + \mathcal{O}(u^2, v^2, uv)\),

\sphinxAtStartPar
where the \(*\) denotes that the derivatives are evaluated at the fixed point.

\sphinxAtStartPar
Hence, the disturbance \((u,v)\), evolves according to:

\sphinxAtStartPar
\(\left(\matrix{\dot{u}\\\dot{v}}\right) = \left(\matrix{\frac{\partial f}{\partial x} & \frac{\partial f}{\partial y}\\ \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y}}\right)_{(x^*, y^*)} \left(\matrix{u\\v}\right) + \mathrm{quadratic~terms}\).

\sphinxAtStartPar
You may recognize: \(J = \left(\matrix{\frac{\partial f}{\partial x} & \frac{\partial f}{\partial y}\\ \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y}}\right)_{(x^*, y^*)} \) as the Jacobian matrix!

\sphinxAtStartPar
Now, since the quadratic terms are tiny, it is tempting to neglect them altogether and obtain a linearized system:

\sphinxAtStartPar
\(\left(\matrix{\dot{u}\\\dot{v}}\right)=\left(\matrix{\frac{\partial f}{\partial x} & \frac{\partial f}{\partial y}\\ \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y}}\right)_{(x^*, y^*)} \left(\matrix{u\\v}\right)\),

\sphinxAtStartPar
which we know how to analyze!

\sphinxAtStartPar
Is it really safe to neglect the quadratic terms? The answer is yes, as long as the fixed point for the linearized system is not a borderline case (center, degenerate node, star or non\sphinxhyphen{}isolated fixed point).

\sphinxAtStartPar
If the linearized system predicts a saddle, node, or a spiral, then the fixed point \sphinxstyleemphasis{really} is a saddle, node or spiral for the original nonlinear system.


\subsection{Example 8.5: Consider the system \textbackslash{}dot\{x\} = x + e\textasciicircum{}\{\sphinxhyphen{}y\} and \textbackslash{}dot\{y\} = \sphinxhyphen{}y. First use qualitative arguments to obtain information about the phase portrait. Then, use the Runge\sphinxhyphen{}Kutta method to compute several trajectories, and plot them on the phase plane.}
\label{\detokenize{Chapters/Chapter8/Chapter8:example-8-5-consider-the-system-dot-x-x-e-y-and-dot-y-y-first-use-qualitative-arguments-to-obtain-information-about-the-phase-portrait-then-use-the-runge-kutta-method-to-compute-several-trajectories-and-plot-them-on-the-phase-plane}}

\section{The Lorenz Equations and Chaos}
\label{\detokenize{Chapters/Chapter8/Chapter8:the-lorenz-equations-and-chaos}}
\sphinxAtStartPar
We begin our brief introduction to the concept of chaos with the Lorenz equations:

\sphinxAtStartPar
\(\dot{x} = \sigma( y - x)\),

\sphinxAtStartPar
\(\dot{y} = rx - y - xz\),

\sphinxAtStartPar
\(\dot{z} = xy - bz\),

\sphinxAtStartPar
where \(\sigma, r, b > 0\) are parameters.

\sphinxAtStartPar
Ed Lorenz (1963) derived this three\sphinxhyphen{}dimensional system from a drastically simplified model of convection rolls in the atmosphere.

\sphinxAtStartPar
\sphinxincludegraphics{{Convrolls}.PNG}

\sphinxAtStartPar
The same equations also arise in models of lasers and dynamos, and they describe exactly the motion of a certain whaterwheel.

\sphinxAtStartPar
\sphinxurl{https://en.wikipedia.org/wiki/File:Malkus\_Waterwheel\_side\_by\_side.webm}

\sphinxAtStartPar
Lorenz discovered that this simple\sphinxhyphen{}looking, deterministic system could have extremely erratic dynamics. In particular, over a wide range of parameters, the solutions oscillate irregularly, never exactly repeating, but always remaining in a bounded region of phase space.

\sphinxAtStartPar
When he plotted the trajectories in 3D, he discovered that they settled onto a complicated set, now known as a \sphinxstyleemphasis{strange attractor}, a fractal with dimension between 2 and 3.


\section{Simple Properties of the Lorenz Equations}
\label{\detokenize{Chapters/Chapter8/Chapter8:simple-properties-of-the-lorenz-equations}}
\sphinxAtStartPar
\(\dot{x} = \sigma( y - x)\),

\sphinxAtStartPar
\(\dot{y} = rx - y - xz\),

\sphinxAtStartPar
\(\dot{z} = xy - bz\).

\sphinxAtStartPar
Τhe \(\sigma\) parameter is also known as the Prandtl number, \(r\) is known as the Rayleigh number and \(b\) has no name (in the convection problem it is related to the aspect ratio of the convection rolls).

\sphinxAtStartPar
The system has two nonlinearities: \(xy\) and \(xz\). There’s also a symmetry: \((x,y) \rightarrow (-x, -y)\) which leaves the equations unchanged.

\sphinxAtStartPar
The point \((x^*, y^*, z^*) = (0,0,0)\) is a fixed point for all values of the parameters. For \(r>1\), there’s also a symmetric pair of fixed points at:

\sphinxAtStartPar
\(x^* = y^* = \pm \sqrt{b(r-1)}\), \(z^* = r-1\), called \(C^+\) and \(C^-\), respectively. As \(r \rightarrow 1^+\), \(C^+\) and \(C^-\) coalesce with the origin.


\subsection{Linear Stability of the Origin}
\label{\detokenize{Chapters/Chapter8/Chapter8:linear-stability-of-the-origin}}
\sphinxAtStartPar
Linearizing the Lorenz equations at the origin, we get:

\sphinxAtStartPar
\(\dot{x} = \sigma(y-x)\),

\sphinxAtStartPar
\(\dot{y} = rx -y\),

\sphinxAtStartPar
\(\dot{z} = -bz\).

\sphinxAtStartPar
The equation for \(z\) is decoupled and shows that \(z(t) \rightarrow 0\) exponentially fast. The other two directions are governed by the system:

\sphinxAtStartPar
\(\left(\matrix{\dot{x}\\\dot{y}}\right) =\left(\matrix{-\sigma & \sigma\\ r & -1}\right) \left(\matrix{x\\ y}\right)\),

\sphinxAtStartPar
with trace \(\tau = -\sigma -1 < 0\) and determinant \(\Delta = \sigma(1 -r)\).

\sphinxAtStartPar
if \(r>1\) the origin is a saddle point because \(\Delta < 0\). Note that this is a new type of saddle point, since the full system is 3D. If \(r<1\) all the directions are incoming and the origin is a sink and a stable node.

\sphinxAtStartPar
Moreover, it can be shown that for \(r<1\) that every trajectory approaches the origin as \(t \rightarrow \infty\), and therefore the origin is \sphinxstyleemphasis{globally} stable.

\sphinxAtStartPar
For a range of \(r\): \(1 < r < r_H =\frac{ \sigma (\sigma + b + 3) }{\sigma - b -1}\) (assuming \(\sigma - b - 1 > 0\)), the fixed points \(C^{\pm}\) are linearly stable.

\sphinxAtStartPar
For \( r > r_H\), trajectories have a bizarre kind of long\sphinxhyphen{}term behavior. Like balls in a pinball machine, they are repelled from one unstable object after another. At the same time, they are confined to a bounded set of zero volume, yet they manage to move on this set forever, without intersecting themselves or others.


\subsection{Exercise 8.1: Chaos on a Strange Attractor}
\label{\detokenize{Chapters/Chapter8/Chapter8:exercise-8-1-chaos-on-a-strange-attractor}}
\sphinxAtStartPar
(See file Exercise8.1.ipynb)


\subsection{The Definition of Chaos}
\label{\detokenize{Chapters/Chapter8/Chapter8:the-definition-of-chaos}}
\sphinxAtStartPar
No definition of “chaos” is universally accepted, but almost everyone would agree on three ingredients used in the following working definition:

\sphinxAtStartPar
“Chaos is aperiodic long\sphinxhyphen{}term behavior in a deterministic system that exhibits sensitive dependence on initial conditions.”
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
“Aperiodic long\sphinxhyphen{}term behavior” implies that the trajectories do not settle down to fixed points, periodic orbits, or quasiperiodic orbits as \(t\rightarrow \infty\). For practical reasons, we require that such trajectories are not too rare.

\item {} 
\sphinxAtStartPar
“Deterministic” means that the system has no random or noisy inputs or parameters. The irregular behavior of the system arises from the system’s nonlinearity, rather than from noisy driving forces.

\item {} 
\sphinxAtStartPar
“Sensitive dependence on initial conditions” means that nearby trajectories separate exponentially fast, i.e. the system has positive Liapunov exponent.

\end{enumerate}


\section{Lorenz Attractor Animation}
\label{\detokenize{Chapters/Chapter8/Chapter8:lorenz-attractor-animation}}
\sphinxAtStartPar
We end this chapter with an animation of the Lorenz Attractor, demonstrating the exponential deviation of two trajectories with similar initial conditions.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{IPython} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} the name of the function is: }
\PYG{c+c1}{\PYGZsh{} scipy.integrate.solve\PYGZus{}ivp, which by default uses the Runge\PYGZhy{}Kutta \PYGZdq{}45\PYGZdq{} method,}
\PYG{c+c1}{\PYGZsh{} a modified version of the Runge\PYGZhy{}Kutta 4\PYGZhy{}th order algo that has a variable step size. }

\PYG{c+c1}{\PYGZsh{} fix the parameters to have the values that Lorenz used: }
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{28}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{/}\PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} first define the function vector}
\PYG{c+c1}{\PYGZsh{} y is a 3D vector here! t is necessary as well, but our function does not depend on time here}
\PYG{k}{def} \PYG{n+nf}{func}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:} 
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Returns the function vector\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{sigma} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} 
            \PYG{n}{r} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
            \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Now get the solution:}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{solarray} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{t\PYGZus{}eval} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{tmax}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{t\PYGZus{}range} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{tmax}\PYG{p}{)}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{integrate}\PYG{o}{.}\PYG{n}{solve\PYGZus{}ivp}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{t\PYGZus{}range}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{t\PYGZus{}eval}\PYG{o}{=}\PYG{n}{t\PYGZus{}eval}\PYG{p}{)}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{1E\PYGZhy{}2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{sol2} \PYG{o}{=} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{integrate}\PYG{o}{.}\PYG{n}{solve\PYGZus{}ivp}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{t\PYGZus{}range}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{t\PYGZus{}eval}\PYG{o}{=}\PYG{n}{t\PYGZus{}eval}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} PLOT:}

\PYG{n}{dynamicdisplay} \PYG{o}{=} \PYG{n}{display}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{display\PYGZus{}id}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{subplot\PYGZus{}kw}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{projection}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the elements required for matplotlib. This creates a figure containing a single axes.}

\PYG{c+c1}{\PYGZsh{} set the labels and titles:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x(t)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the x label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}y(t)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}zlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}z(t)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the y label}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The Lorenz Attractor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set the title }

\PYG{c+c1}{\PYGZsh{} set the x and y limits:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}zlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{ti} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sol2}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sol2}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sol2}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{dynamicdisplay}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{eb2481a0b0566bf4ac8090547035c266b477e4a6e1750240733ac173f8d0d650}.png}

\noindent\sphinxincludegraphics{{eb2481a0b0566bf4ac8090547035c266b477e4a6e1750240733ac173f8d0d650}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Boundary Value and Eigenvalue Problems}
\label{\detokenize{Chapters/Chapter9/Chapter9:boundary-value-and-eigenvalue-problems}}\label{\detokenize{Chapters/Chapter9/Chapter9::doc}}

\section{Introduction}
\label{\detokenize{Chapters/Chapter9/Chapter9:introduction}}
\sphinxAtStartPar
Many of the important equations of physics can be cast in the form of a linear, second\sphinxhyphen{}order differential equation:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 y }  { \mathrm{d} x^2 } + k^2 (x) y = S(x)\),

\sphinxAtStartPar
where \(S(x)\) is an “inhomogeneous” (or “driving”, or “source” term) and \(k^2(x)\) is a real function.

\sphinxAtStartPar
When \(k^2>0\), the solutions of the homogeneous equation (i.e. with \(S=0\)) are oscillatory, with wavenumber \(k\).

\sphinxAtStartPar
When \(k^2<0\), the solutions grow or decay exponentially at a rate \(\sqrt{-k^2}\).

\sphinxAtStartPar
An example of such a problem is trying to find the electrostatic potential \(\Phi\), generated by a localized charge distribution \(\rho(\mathbf{r})\).

\sphinxAtStartPar
The starting point would be Poisson’s equation: \(\nabla^2 \Phi = - 4 \pi \rho\).

\sphinxAtStartPar
(Note that this is written in Gaussian units, where the permittivity of free space is replaced by \(1/4\pi\): \(\varepsilon_0 \rightarrow 1/4\pi\). See \sphinxurl{https://en.wikipedia.org/wiki/Gaussian\_units} for further detail.)

\sphinxAtStartPar
For \sphinxstyleemphasis{spherically\sphinxhyphen{}symmetric} \(\rho\), and hence \(\Phi\), the Poisson equation turns into:

\sphinxAtStartPar
\(\frac{1}{r^2} \frac{ \mathrm{d} }{\mathrm{d}r} \left( r^2 \frac{ \mathrm{d}\Phi } { \mathrm{d} r} \right) = - 4 \pi \rho\).

\sphinxAtStartPar
The standard substitution: \(\Phi(r) = r^{-1} \phi(r)\) then yields:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 \phi }  { \mathrm{d} r^2 } = -4\pi r\rho\),

\sphinxAtStartPar
which is of the aforementioned form, with \(k^2=0\) and \(S=-4 \pi r \rho\).

\sphinxAtStartPar
Another example is the quantum\sphinxhyphen{}mechanical wave function for a particle of mass \(m\) and energy \(E\), moving in a \sphinxstyleemphasis{central} potential \(V(r)\). This can be written as:

\sphinxAtStartPar
\(\Psi(\mathbf{r}) = r^{-1} R(r) Y_{\ell M} (\theta, \phi)\),

\sphinxAtStartPar
where \(Y_{\ell M}\) are the spherical harmonics, and \(\ell, M\) are quantum numbers relevant for the angular momentum, and the \sphinxstyleemphasis{radial} wave function satisfies:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 R }  { \mathrm{d} r^2 } + k^2 (r) R = 0\),

\sphinxAtStartPar
where \(k^2(r) = \frac{2 m}{\hbar^2} \left[ E - \frac{\ell(\ell+1)}{2 mr^2} \hbar^2  - V(r)\right]\).

\sphinxAtStartPar
The above equation is also in the general form stated above, with \(S=0\).

\sphinxAtStartPar
These equations appear unremarkable and readily treated by the methods discussed in Chapter 7, except for two points:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Boundary conditions imposed by the physics often appear as constraints on the dependent variable at two \sphinxstyleemphasis{separate} points. Therefore, a solution of the problem as an initial value problem is not obviously possible.

\item {} 
\sphinxAtStartPar
The (time\sphinxhyphen{}independent) Schrödinger equation is an eigenvalue problem, in which we must \sphinxstyleemphasis{find} the energies that lead to physically\sphinxhyphen{}acceptable solutions satisfying the appropriate boundary conditions.

\end{itemize}

\sphinxAtStartPar
We begin by deriving an integration algorithm particularly suited to the equations of the desired form, and discuss the boundary value and eigenvalue problems in turn.


\section{The Numerov Algorithm}
\label{\detokenize{Chapters/Chapter9/Chapter9:the-numerov-algorithm}}
\sphinxAtStartPar
There is a particularly simple and efficient method for integrating the second\sphinxhyphen{}order differential equations of the desired form (i.e. without a first\sphinxhyphen{}order derivative). This is known as the Numerov (or Cowling’s) method.

\sphinxAtStartPar
Consider the following expansions of the function \(y\) about \(x\):

\sphinxAtStartPar
\(y(x+h) = y(x) + h y'(x) + \frac{h^2}{2} y''(x) + \frac{h^3}{6} y'''(x) + \frac{h^4}{4!} y''''(x) + \mathcal{O}(h^5)\),

\sphinxAtStartPar
\(y(x-h) = y(x) - h y'(x) + \frac{h^2}{2} y''(x) - \frac{h^3}{6} y'''(x) + \frac{h^4}{4!} y''''(x) - \mathcal{O}(h^5)\),

\sphinxAtStartPar
Add the two together:

\sphinxAtStartPar
\(y(x+h) + y(x-h) = 2y(x) + h^2 y''(x) +  \frac{h^4}{12} y''''(x) + \mathcal{O}(h^6)\),

\sphinxAtStartPar
since the \(\mathcal{O}(h^5)\) terms will cancel out due to opposite signs.

\sphinxAtStartPar
After some minor rearrangements, we get a three\sphinxhyphen{}point approximation for the second derivative \(y''(x)\):

\sphinxAtStartPar
\(y''(x) + \frac{h^2}{12} y''''(x) + \mathcal{O}(h^4) = \frac{ y(x+h) + y(x-h) - 2 y(x) }{h^2}\),

\sphinxAtStartPar
where we have kept the error term \(\frac{h^2}{12} y''''(x)\), which we will further manipulate below.

\sphinxAtStartPar
Before we get to that, according to the above, let’s write down the the three\sphinxhyphen{}point approximation for the second derivative:

\sphinxAtStartPar
\(y''(x_n) = \frac{ y_{n+1} - 2 y_n + y_{n-1} } { h^2 } + \mathcal{O}(h^2)\),

\sphinxAtStartPar
where we have defined the \(n\)\sphinxhyphen{}th iteration of the independent variable as \(x_n = x_0 + nh\).

\sphinxAtStartPar
The differential equation itself tells us that:

\sphinxAtStartPar
\(y'' = -k^2 y + S\).

\sphinxAtStartPar
If we differentiate this twice more and evaluate it at \(x_n\):

\sphinxAtStartPar
\(y''''(x_n) \equiv y_n'''' = \frac{\mathrm{d}^2}{\mathrm{d}x^2} \left.\left(-k^2 y + S\right)\right|_{x=x_n}\).

\sphinxAtStartPar
We can then use the three\sphinxhyphen{}point approximation of the second derivative derived above to deduce that:
\(y_n'''' = -\frac{ (k^2 y)_{n+1} - 2 (k^2 y)_n + (k^2 y)_{n-1} }{h^2} + \frac{ S_{n+1} - 2 S_n + S_{n-1}}{h^2} + \mathcal{O}(h^2)\).

\sphinxAtStartPar
This can be substituted into the “error” term of the three\sphinxhyphen{}point approximation for the second derivative \(y''(x)\) to get:

\sphinxAtStartPar
\(y_n'' + \frac{h^2}{12} \left(-\frac{ (k^2 y)_{n+1} - 2 (k^2 y)_n + (k^2 y)_{n-1} }{h^2} + \frac{ S_{n+1} - 2 S_n + S_{n-1}}{h^2} + \mathcal{O}(h^2)\right) + \mathcal{O}(h^4) = \frac{ y_{n+1} - 2 y_n + y_{n-1} } { h^2 }\).

\sphinxAtStartPar
Multiplying through by \(h^2\) and using the differential equation itself, i.e. \(y_n'' = - (k^2y)_n + S_n\):

\sphinxAtStartPar
\(- (k^2y)_n + S_n + \frac{h^2}{12} \left(-(k^2 y)_{n+1} + 2 (k^2 y)_n - (k^2 y)_{n-1} + S_{n+1} - 2 S_n + S_{n-1} \right) + \mathcal{O}(h^6) = y_{n+1} - 2 y_n + y_{n-1}\).

\sphinxAtStartPar
After further rearrangement, we get a recursion relation for \(y_{n+1}\) in terms of \(y_n\) and \(y_{n-1}\), the previous two steps:

\sphinxAtStartPar
\(y_{n+1} = \frac{ 2(1- \frac{5h^2}{12} k_n^2) y_n - (1+\frac{h^2}{12} k^2_{n-1}) y_{n-1} + \frac{h^2}{12}(S_{n+1} + 10 S_n + S_{n-1}) + \mathcal{O}(h^6) }{ 1 + \frac{h^2}{12} k_{n+1}^2 }\).

\sphinxAtStartPar
Note that one can also solve for \(y_{n-1}\) in terms of \(y_n\) and \(y_{n+1}\) to integrate backward in \(x\).

\sphinxAtStartPar
We emphasize here that the Numerov method is one more order accurate than the fourth\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method, which might be used to integrate the problem as two coupled first\sphinxhyphen{}order equations. The Numerov method is also more efficient, as each step requires computation of \(k^2\) and \(S\) at only the “lattice” points.


\subsection{Example 9.1: Apply the Numerov algorithm to the Simple Harmonic Oscillator problem:}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-1-apply-the-numerov-algorithm-to-the-simple-harmonic-oscillator-problem}}
\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 y } {\mathrm{d}x^2} = - 4 \pi^2 y\), with \(y(0)=1\), \(y'(0)=0\).

\sphinxAtStartPar
Integrate from \(x=0\) to \(x=4\). Note that you will have to use some special procedure to generate the value of \(y_1 \equiv y(h)\), needed to start the three\sphinxhyphen{}term recursion relation.

\sphinxAtStartPar
Plot the resulting function \(y(x)\).


\section{Direct Integration of Boundary Value Problems: the Poisson Equation}
\label{\detokenize{Chapters/Chapter9/Chapter9:direct-integration-of-boundary-value-problems-the-poisson-equation}}
\sphinxAtStartPar
Consider trying to solve Poisson’s equation for a charge density distribution:

\sphinxAtStartPar
\(\rho(r) = \frac{1}{8 \pi} e^{-r}\).

\sphinxAtStartPar
If we integrate the charge density over all space, we obtain the total charge:

\sphinxAtStartPar
\(Q = \int \rho(r) \mathrm{d}^3 r = 4\pi \int_0^\infty \rho(r) r^2 \mathrm{d} r = 1\).

\sphinxAtStartPar
The exact solution to this problem is:

\sphinxAtStartPar
\(\phi(r) = 1 - \frac{1}{2} (r+2) e^{-r}\),

\sphinxAtStartPar
and therefore we can obtain the potential \(\Phi = \phi/r\).

\sphinxAtStartPar
The solution has the expected behavior at large \(r\): since \(\phi \rightarrow 1\), we have \(\Phi \rightarrow 1/r\), the Coulomb potential from a unit charge (\sphinxstyleemphasis{in Gaussian units}).

\sphinxAtStartPar
Let’s try to solve this example as an ordinary initial value problem. The charge density \(\rho\) has no singular behavior at the origin, and therefore we expect \(\Phi\) to be regular there, which implies that \(\phi = r \Phi\) vanishes at the origin, when \(r=0\). We can readily check that this is indeed the case for the explicit solution:

\sphinxAtStartPar
\(\phi(0) = 1 - \frac{1}{2} (0+2) e^{0} = 0\).

\sphinxAtStartPar
We could then integrate \(\frac{ \mathrm{d}^2 \phi }  { \mathrm{d} r^2 } = -4\pi r\rho\) \sphinxstyleemphasis{outward} from the origin using the Numerov method:

\sphinxAtStartPar
\(\phi_{n+1} = 2 \phi_n - \phi_{n-1} + \frac{h^2}{12} (S_{n+1} + 10 S_n + S_{n-1})\),

\sphinxAtStartPar
with source term \(S=-4\pi r\rho = -\frac{1}{2} r e^{-r}\).

\sphinxAtStartPar
However, to be able to accomplish this, we also need to know the value of \(\phi_1 = \phi(h)\) (or equivalently, \(\mathrm{d} \phi/\mathrm{d}r\) at \(r=0\)) in addition to \(\phi_0 = 0\). Note that this is also identical to \(\Phi(0)\), since:

\sphinxAtStartPar
\(\Phi(0) = \lim_{r\rightarrow 0} \frac{\phi}{r} = \left. \frac{ \mathrm{d} \phi } { \mathrm{d} r}\right|_{r\rightarrow 0}\), after applying L’Hôpital’s rule.

\sphinxAtStartPar
This is unfortunate, since \(\phi_1\) is nominally part of the function we are trying to find, and we do not know it a priori.

\sphinxAtStartPar
We will discuss below what to do in the general case, but for now, let’s just take \(\phi_1\) from the analytical solution:

\sphinxAtStartPar
\(\phi_1 = \phi(r=h) = 1 - \frac{1}{2} (h + 2) e^{-h}\).


\subsection{Example 9.2: Apply the Numerov algorithm to solve Poisson’s equation with \textbackslash{}rho(r) = \textbackslash{}frac\{1\}\{8 \textbackslash{}pi\} e\textasciicircum{}\{\sphinxhyphen{}r\}.}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-2-apply-the-numerov-algorithm-to-solve-poisson-s-equation-with-rho-r-frac-1-8-pi-e-r}}
\sphinxAtStartPar
Assume the exact solution \(\phi(r) = 1 - \frac{1}{2} (r+2) e^{-r}\) and plot the error up to \(r=20\).

\sphinxAtStartPar
To start up the recursion, use \(\phi_1 = \phi(r=h) = 1 - \frac{1}{2} (h + 2) e^{-h}\).

\sphinxAtStartPar
After solving Example 9.2, you will have noticed that the error is getting larger at large \(r\)!

\sphinxAtStartPar
Let’s try to understand the origin of this phenomenon by considering a more general case, where we do not have an analytical formula to give us \(\phi\) near the origin that is necessary to get the three\sphinxhyphen{}term recursion relation started.

\sphinxAtStartPar
One way to proceed is to find \(\Phi(0)\) by direct numerical quadrature of the Coulomb potential. At a point \(\mathbf{r}\), the potential will be given by an integral over the whole charge distribution:

\sphinxAtStartPar
\(\Phi(\mathbf{r}) = \int \frac{ \rho (|\mathbf{r}'|)}{|\mathbf{r} - \mathbf{r}'|} \mathrm{d}^3 r'\).

\sphinxAtStartPar
At the origin (\(\mathbf{r}=0\)), this would be easy to calculate:

\sphinxAtStartPar
\(\Phi(0) = \int \frac{ \rho (|\mathbf{r}'|) }{ |\mathbf{r}'| } \mathrm{d}^3 r' = 4\pi \int_0^\infty r' \rho \mathrm{d} r'\), where we have assumed a spherically\sphinxhyphen{}symmetric \(\rho(r)\).

\sphinxAtStartPar
We could achieve this, e.g. by using Simpson’s rule. There will be, however, some error associated with the value obtained. Let’s say this error is 5\%. Let’s just impose such an error in our Example 9.2 result and compare the effect to what we had obtained previously.


\subsection{Example 9.3: Apply a 5\% assumed error on the \textbackslash{}phi\_1 input of Example 9.2 (e.g. by rescaling the exact value by 0.95) and compare your error to the previous one.}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-3-apply-a-5-assumed-error-on-the-phi-1-input-of-example-9-2-e-g-by-rescaling-the-exact-value-by-0-95-and-compare-your-error-to-the-previous-one}}
\sphinxAtStartPar
You will have noticed that disaster has struck: A 5\% change on the initial conditions has induced a 50\% error on the solution at large values of \(r\)!

\sphinxAtStartPar
What’s going on?

\sphinxAtStartPar
To understand what has happened, consider solutions to the \sphinxstyleemphasis{homogeneous} version of our differential equation:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 \phi }  { \mathrm{d} r^2 } = 0\).

\sphinxAtStartPar
Such solutions can be \sphinxstyleemphasis{added} to any particular solution to give another solution.

\sphinxAtStartPar
There are two linearly\sphinxhyphen{}independent homoeneous solutions:

\sphinxAtStartPar
\(\phi \sim r\) and \(\phi \sim \mathrm{constant}\).

\sphinxAtStartPar
The general solution to \(\frac{ \mathrm{d}^2 \phi }  { \mathrm{d} r^2 } = -4\pi r\rho\) in the asymptotic region \(r\rightarrow \infty\), where \(\rho\) vanishes and the equation is in fact homogeneous, can be written as a linear combination of these two functions. Of course, the latter, sub\sphinxhyphen{}dominant solution (which corresponds to \(\Phi \sim 1/r\)) is the physical one.

\sphinxAtStartPar
What has occurred in our problem is that an imprecision in the specification of \(\Phi\) at the origin, or any numerical round\sphinxhyphen{}off error in the integration process, can introduce a small admixture of the \(\phi \sim r\) solution, which will eventually dominate at large \(r\).

\sphinxAtStartPar
There exists a straightforward cure this issue: subtract a multiple of the “bad”, unphysical solution to the homogeneous equation from the numerical result, to guarantee the physical behavior in the asymptotic region. The “bad” results vary linearly with \(r\) for large \(r\). We can fit the last few points of the numerical solution to the form:

\sphinxAtStartPar
\(\phi = mr + b\),

\sphinxAtStartPar
and subtract \(mr\) from the numerical results to reinstate the appropriate large\sphinxhyphen{}\(r\) behavior. Let’s do this in the next example.


\subsection{Example 9.4: Correct the “bad” results with the 5\% error of Example 9.3.}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-4-correct-the-bad-results-with-the-5-error-of-example-9-3}}
\sphinxAtStartPar
The “bad” results vary linearly with \(r\) for large \(r\). Fit the last few points of the numerical solution to the form:

\sphinxAtStartPar
\(\phi = mr + b\),

\sphinxAtStartPar
and subtract \(mr\) from the numerical results to reinstate the appropriate large\sphinxhyphen{}\(r\) behavior.

\sphinxAtStartPar
In this relatively simple example, the instabilities are not too severe, and satisfactory results for moderate values of \(r\) are obtained with outward integration when the exact (or reasonably\sphinxhyphen{}accurate approximation) value of \(\phi_1\) is used.

\sphinxAtStartPar
Alternatively, it is also feasible to integrate inward, starting at large \(r\), with \(\phi = Q\), independent of \(r\). This results in a solution that often satisfies accurately the boundary condition at \(r=0\) and avoids having to perform a quadrature to determine the (approximate) starting value \(\phi_1\).


\section{Green’s Function Solution of Boundary Value Problems}
\label{\detokenize{Chapters/Chapter9/Chapter9:green-s-function-solution-of-boundary-value-problems}}
\sphinxAtStartPar
It’s possible that the two solutions to the homogeneous equation (i.e. with the RHS=0) have very different behaviors. In that case, some extra precautions must be taken.

\sphinxAtStartPar
For example, consider the equation describing the potential from a charge distribution of multipole order \(\ell >0\):

\sphinxAtStartPar
\(\left[ \frac{ \mathrm{d^2}}{ \mathrm{d}r^2} - \frac{ \ell(\ell+1)}{r^2} \right] \phi = -4 \pi r \rho\),

\sphinxAtStartPar
which has two homogeneous solutions:

\sphinxAtStartPar
\(\phi \sim r^{\ell + 1}\) and \(\phi \sim r^{-\ell}\).

\sphinxAtStartPar
For large \(r\), the first of these solutions is much larger than the second, so that ensuring the correct asymptotic behavior by subtracting a multiple of this dominant homogeneous solution from a particular solution obtained by outward integration is subject to large round\sphinxhyphen{}off errors. Inward integration would also be unsatisfactory, since the unphysical solution \(r^{-\ell}\) is likely to dominate at small \(r\).

\sphinxAtStartPar
One possible way to generate an accurate solution is by combining the two methods: inward integration can be used to obtain the potential for \(r\) greater than some intermediate radius \(r_m\), and outward integration can be used for the potential when \(r< r_m\). As long as \(r_m\) is chosen so that neither homogeneous solution is dominant, the outer and inner potentials obtained, respectively from these two integrations will match at \(r_m\) and, together, will describe the entire solution. If the inner and outer potentials don’t quite match, a multiple of the homogeneous solution can be added to the former to correct for any deficiencies in our knowledge of \(\phi' (r=0)\).

\sphinxAtStartPar
Sometimes the two homogeneous solutions have such different behaviors that it is impossible to find a value of \(r_m\) that permits satisfactory integration of the inner and outer potentials. Such cases can be solved by the \sphinxstyleemphasis{Green’s function} of the homogeneous equation.

\sphinxAtStartPar
To illustrate this, consider our prototypical equation:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 y }  { \mathrm{d} x^2 } + k^2 (x) y = S(x)\),

\sphinxAtStartPar
with boundary conditions \(\phi(x=0) = \phi(x=\infty) = 0\).

\sphinxAtStartPar
Since this is a linear problem, the solution to this equation can be written as:

\sphinxAtStartPar
\(\phi(x) = \int_0^\infty G(x,x') S(x') \mathrm{d}x'\),

\sphinxAtStartPar
where \(G\) is a Green’s function that satisfies:

\sphinxAtStartPar
\(\left[ \frac{ \mathrm{d}^2  }  { \mathrm{d} x^2 } + k^2 (x)\right] G(x,x') = \delta(x-x')\).

\sphinxAtStartPar
Evidently, \(G\) satisfies the homogeneous equation for \(x\neq x'\). However, the derivative of \(G\) is discontinuous at \(x=x'\) as can be seen by integrating the above equation from \(x=x'-\varepsilon\) to \(x=x'+\varepsilon\) and letting \(\varepsilon \rightarrow 0\).

\sphinxAtStartPar
We have \(\int \frac{ \mathrm{d}^2 G }  { \mathrm{d} x^2 } \mathrm{d} x= \frac{ \mathrm{d} G  }  { \mathrm{d} x }\), the integral of the \(\delta\) function that includes \(x=x'\) has to be unity, and the second integral \(\int_{x'-\varepsilon}^{x'+\varepsilon} G(x,x') \mathrm{d} x\) vanishes as \(\varepsilon \rightarrow 0\), we are left with:

\sphinxAtStartPar
\(\left.\frac{ \mathrm{d} G  }  { \mathrm{d} x }\right|^{x'+\varepsilon}_{x' - \varepsilon} = 1\).

\sphinxAtStartPar
Then, to construct the Green function, we first solve the homogeneous equation:

\sphinxAtStartPar
\(\left[ \frac{ \mathrm{d}^2  }  { \mathrm{d} x^2 } + k^2 (x)\right] G(x,x') = 0\) for \(x > x'\) and \(x < x'\) and then impose the appropriate boundary conditions, including the discontinuity in the derivative. Let’s recap the process by considering a simple analytical example.


\subsection{Example 9.5: A Simple Analytical Green’s Function Problem}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-5-a-simple-analytical-green-s-function-problem}}
\sphinxAtStartPar
Solve the equation:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 y }  { \mathrm{d} x^2 } + y = S(x)\),

\sphinxAtStartPar
with boundary conditions \(y(0) = y(\pi/2) = 0\), using the Green’s function method.

\sphinxAtStartPar
There’s a general prescription to obtain the Green’s function for our differential equation:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 y }  { \mathrm{d} x^2 } + k^2 (x) y = S(x)\),
\begin{itemize}
\item {} 
\sphinxAtStartPar
Get the two solutions to the homogeneous equation that satisfy the two boundary conditions: \(y_<\) and \(y_>\). The first will satisfy the boundary conditions to the left (e.g. at \(x=0\)), and the second to the right (e.g. at \(x=\infty\)).

\item {} 
\sphinxAtStartPar
These have to be normalized such that their \sphinxstyleemphasis{Wronskian} equals unity:
\(W = \frac{ d y_> } { \mathrm{d} x } y_< - \frac{ d y_< } { \mathrm{d} x } y_> = 1\).

\item {} 
\sphinxAtStartPar
Then the Green’s function is given by:
\(G(x,x') = y_< (x_<) y_> (x_>)\), where \(x_<\) and \(x_>\) are the smaller and larger of \(x\) and \(x'\) respectively. (Check that this conforms with Example 9.5!).

\item {} 
\sphinxAtStartPar
Then the explicit solution is given by:
\(y(x) = y_> (x) \int_0^x y_< (x') S(x') \mathrm{d}x' + y_< (x) \int_x^\infty y_> (x') S(x') \mathrm{d}x'\).

\end{itemize}

\sphinxAtStartPar
In general, this expression can be evaluated by a numerical quadrature and is not subject to any of the stability problems we have seen associated with a direct integration of the inhomogeneous equation.

\sphinxAtStartPar
In the case of arbitrary \(k^2\), the homogeneous solutions \(y_<\) and \(y_>\) can be found numerically by outward and inward integrations, respectively, of initial value problems and then normalized to satisfy the Wronskian relation.

\sphinxAtStartPar
For simple forms of \(k^2(x)\), they are known analytically. For example, for the problem:

\sphinxAtStartPar
\(\left[ \frac{ \mathrm{d^2}}{ \mathrm{d}r^2} - \frac{ \ell(\ell+1)}{r^2} \right] \phi = -4 \pi r \rho\),

\sphinxAtStartPar
it can be shown that:

\sphinxAtStartPar
\(\phi_< (r) = r^{\ell+1}\) and \(\phi_> (r) = - \frac{ 1 } { 2\ell + 1 } r^{-\ell}\), are one possible set of homogeneous solutions satisfying the appropriate boundary conditions and the differential equation.


\subsection{Example 9.6: Solve the problem:}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-6-solve-the-problem}}
\sphinxAtStartPar
\(\frac{ \mathrm{d^2} \phi}{ \mathrm{d}r^2} = -4 \pi r \rho\),

\sphinxAtStartPar
for \(\rho(r) = \frac{1}{8\pi} e^{-r}\) using the Green’s function method.

\sphinxAtStartPar
Compare your results to the exact solution by plotting the error as in the previous examples.


\section{Eigenvalues of the Wave Equation}
\label{\detokenize{Chapters/Chapter9/Chapter9:eigenvalues-of-the-wave-equation}}
\sphinxAtStartPar
Eigenvalue problems involving differential equations often arise in finding normal\sphinxhyphen{}mode solutions of wave equations.

\sphinxAtStartPar
We begin our discussion of eigenvalue problems with a simple example: that of normal modes of a stretched string of uniform mass density.

\sphinxAtStartPar
After suitable scaling of the physical quantities, the equation and boundary conditions defining these modes can be written as:

\sphinxAtStartPar
\(\frac{ \mathrm{d^2} \phi}{ \mathrm{d}x^2} = -k^2 \phi\),

\sphinxAtStartPar
with \(\phi(x=0) = \phi(x=1) = 0\).

\sphinxAtStartPar
Here we have:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(0 < x < 1\) is the coordinate along the string,

\item {} 
\sphinxAtStartPar
\(\phi\) is the transverse displacement of the string,

\item {} 
\sphinxAtStartPar
\(k\) is the constant wavenumber, linearly related to the frequency of vibration.

\end{itemize}

\sphinxAtStartPar
The equation is an eigenvalue equation in the sense that the solutions satisfying the boundary conditions exist only for particular values of \(k\), \(\{k_n\}\), which we must find.

\sphinxAtStartPar
Furthermore, it is linear and homogeneous, the normalization of the eigenfunctions corresponding to any \(k_n\), which we denote as \(\phi_n\), is not fixed, but can be chosen for convenience.

\sphinxAtStartPar
The un\sphinxhyphen{}normalized eigenfunctions and eigenvalues of this problem are of course known analytically:

\sphinxAtStartPar
\(k_n = n \pi\), \(\phi_n = \sin n \pi x\), where \(n\) is a positive integer.

\sphinxAtStartPar
The strategy for solving this problem is an \sphinxstyleemphasis{iterative} one:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Guess a trial eigenvalue and obtain the general solution by integrating the differential equation as an initial value problem (e.g. using the Numerov method).

\item {} 
\sphinxAtStartPar
If the resulting solution does not satisfy the boundary conditions, we change the trial eigenvalue and integrate again, repeating the process until a trial eigenvalue is found for which the b.c.’s are satisfied to within a predetermined tolerance.

\end{itemize}

\sphinxAtStartPar
The above method is known as the “shooting method”.

\sphinxAtStartPar
For the problem at hand: for each trial value of \(k\), we integrate forward from \(x=0\) with the initial conditions:

\sphinxAtStartPar
\(\phi(x=0) = 0\) and \(\phi'(x) = \delta\),

\sphinxAtStartPar
where \(\delta\) is arbitrary and can be chosen for convenience, since the problem we are solving is a homogeneous one, and the normalization of solutions is not specified.

\sphinxAtStartPar
Upon integrating to \(x=1\), we will find, in general, a non\sphinxhyphen{}vanishing value of \(\phi\), since the trial eigenvalue will not be one of the true eigenvalues. We must then readjust \(k\) and integrate again, repeating the process until we find \(\phi(x=1)=0\) to within a specified tolerance.

\sphinxAtStartPar
The problem of finding a value of \(k\) for which \(\phi(1)\) vanishes is a \sphinxstyleemphasis{root\sphinxhyphen{}finding problem}, such as the ones that we have already discussed (Chapter 6). It is safest to use a simple search to locate an approximate eigenvalue, e.g. the bisection method.


\subsection{Example 9.7: Find the lowest eigenvalue of the stretched string problem by employing the shooting method described above.}
\label{\detokenize{Chapters/Chapter9/Chapter9:example-9-7-find-the-lowest-eigenvalue-of-the-stretched-string-problem-by-employing-the-shooting-method-described-above}}
\sphinxAtStartPar
Start your search at \(k=1\) and terminate the search when the eigenvalue is determined within a precision of \(10^{-5}\).


\section{The One\sphinxhyphen{}Dimensional Schrödinger Equation}
\label{\detokenize{Chapters/Chapter9/Chapter9:the-one-dimensional-schrodinger-equation}}
\sphinxAtStartPar
A rich example of the shooting method for eigenvalue problems is the task of finding the stationary quantum states of a particle of mass \(m\) moving in a one\sphinxhyphen{}dimensional potential \(V(x)\).

\sphinxAtStartPar
The time\sphinxhyphen{}independent Schroödinger equation is given by:

\sphinxAtStartPar
\(\frac{-\hbar^2}{2m} \frac{ \mathrm{d}^2}{\mathrm{d}x^2} \psi(x) + V(x)\psi(x) = E\psi(x)\).

\sphinxAtStartPar
If we rescale the \(x\) coordinate by a physical length \(a\), then \(\mathrm{d} x \rightarrow a \mathrm{d}x\), and we can rewrite this as:

\sphinxAtStartPar
\(\frac{-\hbar^2}{2ma^2} \frac{ \mathrm{d}^2}{\mathrm{d}x^2} \psi(x) + V(x)\psi(x) = E\psi(x)\).

\sphinxAtStartPar
We can then divide LHS and RHS by \(V_0\), a characteristic scale of the potential:

\sphinxAtStartPar
\(\frac{-\hbar^2}{2ma^2 V_0} \frac{ \mathrm{d}^2}{\mathrm{d}x^2} \psi(x) + \frac{V(x)}{V_0} \psi(x)= \frac{E}{V_0}\psi(x)\),

\sphinxAtStartPar
to reach the form:

\sphinxAtStartPar
\(\left[-\frac{1}{z_0^2}  \frac{ \mathrm{d}^2}{\mathrm{d}x^2} + v(x) - \epsilon\right] \psi(x) = 0\),

\sphinxAtStartPar
where

\sphinxAtStartPar
\(
z_0^2 = \frac{2 m a^2 V_0}{\hbar^2}\;,
\)

\sphinxAtStartPar
which characterizes the “depth” of the potential, and we have defined the dimensionless energy \(\epsilon = E/V_0\).

\sphinxAtStartPar
The equation is then of the form that we have previously addressed:

\sphinxAtStartPar
\(\frac{ \mathrm{d}^2 \psi}{\mathrm{d}x^2} - z_0^2 \left[v(x) - \epsilon\right] \psi(x) = 0\),

\sphinxAtStartPar
with \(k^2(x) = - z_0^2 \left[v(x) - \epsilon\right]\).

\sphinxAtStartPar
If \(v(x) < 0\) and \(v(x)\) is zero at some boundaries (“walls”), our goal then is to find “bound” solutions with \(-1 < \epsilon < 0\), which are localized within the potential and decay exponentially outside.

\sphinxAtStartPar
This eigenvalue problem can be solved by the shooting method. Suppose that we are seeking a bound state, and therefore start with a negative trial eigenvalue.

\sphinxAtStartPar
We can integrate toward larger \(x\) via the “forward” Numerov algorithm, from some initial value \(x_\mathrm{min}\) to obtain the wave function \(\psi_<(x)\) (the “left” wave function). However, once we reach the “classically forbidden” region, we will start to generate an admixture of the undesirable exponentially\sphinxhyphen{}growing solution. Therefore, as a rule, integration \sphinxstyleemphasis{into} a classically forbidden region is likely to be inaccurate.

\sphinxAtStartPar
Therefore, at each energy, it is wiser to generate a second solution, \(\psi_>(x)\) (the “right” wave function), by integrating from \(x_\mathrm{max}\) toward a smaller \(x\), using a “backward” Numerov algorithm.

\sphinxAtStartPar
To determine whether the energy is an eigenvalue, \(\psi_<(x)\) and \(\psi_>(x)\) can be compared at a matching point \(x_m\), chosen so that neither integration will be inaccurate. A convenient choice for \(x_m\) is the left turning point.

\sphinxAtStartPar
Since both \(\psi_<(x)\) and \(\psi_>(x)\) satisfy a homogeneous equation, their normalizations can always be chosen so that the two functions are equal at \(x_m\):

\sphinxAtStartPar
\(\psi_<(x_m) = \psi_>(x_m)\).

\sphinxAtStartPar
Furthermore, the derivative has to be continuous as well:

\sphinxAtStartPar
\( \int_{x_m- \varepsilon}^{x_m + \varepsilon} \mathrm{d} x \frac{ \mathrm{d}^2 \psi}{\mathrm{d}x^2} = 0\), and so:

\sphinxAtStartPar
\(\left.\frac{ \mathrm{d} \psi_< }{\mathrm{d}x}\right|_\mathrm{x_m} = \left.\frac{\mathrm{d} \psi_>}{\mathrm{d} x}\right|_{x_m}\).

\sphinxAtStartPar
If we approximate the derivatives by their simplest forward\sphinxhyphen{}difference approximations, i.e.:

\sphinxAtStartPar
\(\frac{ \mathrm{d} \psi (x) }{\mathrm{d}x} \approx \frac{ \psi(x) - \psi(x-h) } { h }\),

\sphinxAtStartPar
then an equivalent condition for the continuity condition of the derivatives is:

\sphinxAtStartPar
\(f = \frac{ \psi_<(x_m - h) - \psi_>(x_m - h) } { \phi } \approx 0\),

\sphinxAtStartPar
where \(\phi\) is a normalization factor, chosen to to make \(f\) typically of order unity, e.g. \(\phi\) could be the maximum value of \(\psi_<\) or \(\psi_>\).

\sphinxAtStartPar
Note that if there are no turning points, then \(x_m\) can be chosen anywhere, while if there are more than two turning points, three or more homogeneous solutions, each accurate in different regions, must be patched together.

\sphinxAtStartPar
We will tackle the particular problem of the potential of the finite square well in Exercise 9.2:
\begin{equation*}
\begin{split}
V(x)=
\begin{cases}
-V_0& \quad \text{if $-a \leq x \leq a$;}\\ 
0& \quad \text{if $|x| > a$.}\\ 
\end{cases}
\end{split}
\end{equation*}
\sphinxstepscope


\chapter{Partial Differential Equations}
\label{\detokenize{Chapters/Chapter10/Chapter10:partial-differential-equations}}\label{\detokenize{Chapters/Chapter10/Chapter10::doc}}

\section{Introduction}
\label{\detokenize{Chapters/Chapter10/Chapter10:introduction}}
\sphinxAtStartPar
Partial differential equations (PDEs) are involved in the description of virtually every physical situation where quantities vary in space, or in space and time.

\sphinxAtStartPar
Examples are diffusion, electromagnetic waves, hydrodynamics, quantum mechanics.

\sphinxAtStartPar
In all but the simplest cases, equations cannot be solved analytically, and so numerical methods must be employed for quantitative results.

\sphinxAtStartPar
The typical numerical approach proceeds as follows: the dependent variables (e.g. temperature, electrical potential), are described by their values at discrete points (a lattice) of the independent variables (e.g. space and time).

\sphinxAtStartPar
Therefore, by appropriate discretization, the PDE is reduced to a large set of \sphinxstyleemphasis{difference equations}.

\sphinxAtStartPar
Although difference equations can be solved by matrix methods, the large size of the matrices involved (dimension \(\sim\) number of lattice points), makes this approach impractical.

\sphinxAtStartPar
However, the locality of the original equations (i.e. they involved only low\sphinxhyphen{}order derivatives of the dependent variables) makes the resulting differential equations “sparse”, which implies that most of the elements of the matrices involved vanish.

\sphinxAtStartPar
For such matrices, iterative methods of inversion and diagonalization can be very efficient.

\sphinxAtStartPar
Most of the physically\sphinxhyphen{}important PDEs are of second order, and can be classified into three types:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Parabolic:} Roughly speaking, parabolic equations involve only a first\sphinxhyphen{}order derivative in one variable, but have second\sphinxhyphen{}order derivatives in the remaining variables. Examples the diffusion equation, or the time\sphinxhyphen{}dependent Schrödinger equation: they are first order in time, but second order in space.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Elliptic:} They have second order derivatives in each of the independent variables, each derivative having the \sphinxstyleemphasis{same sign} when all terms of the equation are grouped on one side. Examples are the Poisson equation for the electrical potential and the time\sphinxhyphen{}independent Schrödinger equation, in two or more spatial variables.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Hyperbolic:} They involve second derivatives of opposite sign, e.g. the wave equation describing the vibrations of a stretched string.

\end{enumerate}

\sphinxAtStartPar
In this chapter, we will discuss some numerical methods appropriate for \sphinxstyleemphasis{elliptic} equations and then focus on \sphinxstyleemphasis{parabolic} equations. Hyperbolic equations often can be treated by similar methods, with some unique differences (we won’t discuss these here).


\section{Elliptic Partial Differential Equations}
\label{\detokenize{Chapters/Chapter10/Chapter10:elliptic-partial-differential-equations}}
\sphinxAtStartPar
For concreteness, we will consider particular forms of elliptic boundary value and eigenvalue problems for a field \(\phi\) in two spatial dimensions, \((x,y)\).

\sphinxAtStartPar
Specifically, we will tackle the boundary value problem:

\sphinxAtStartPar
\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\).

\sphinxAtStartPar
Although this is not the most general elliptic form, it covers a wide variety of situations. For example, in electrostatics, \(\phi\) is the potential and \(S\) is related to the charge density (i.e., it is a source term). In steady\sphinxhyphen{}state heat diffusion, \(\phi\) is the temperature, \(S\) is the local rate of heat generation or loss.

\sphinxAtStartPar
The discussion can be generalized straightforwardly to other elliptic cases, e.g. in three dimensions.

\sphinxAtStartPar
Of course, the equation by itself is not complete. The boundary conditions are required. We will take the boundary conditions to be of the “Dirichlet” type, i.e. \(\phi\) is specified on some closed curve on the \((x,y)\) plane. Conveniently, we will take this to be the unit square, and perhaps some additional curves within it.

\sphinxAtStartPar
The boundary value problem is then to use the PDE to find \(\phi\) everywhere within the square.

\sphinxAtStartPar
Other classes of boundary conditions are the “Neumann” type, where the normal derivative of \(\phi\) is specified on the surfaces, or the “mixed” type, where a linear combination of \(\phi\) and its normal derivatives is specified. Both can be handled by very similar methods.

\sphinxAtStartPar
The eigenvalue problems we will be interested in might involve an equation of the form,

\sphinxAtStartPar
\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi + V(x,y)\phi = \varepsilon \phi\),

\sphinxAtStartPar
together with a set of Dirichlet boundary conditions.

\sphinxAtStartPar
As an example, the above could be the time\sphinxhyphen{}independent Schrödinger equation, with \(\phi\) being the wave function, \(V(x,y)\) is related to the potential and \(\varepsilon\) is related to the energy eigenvalue.

\sphinxAtStartPar
The eigenvalue problem is then to find the values \(\varepsilon_\lambda\) and the associated eigenfunctions \(\phi_\lambda\), for which the equation and the b.c.’s are satisfied.


\subsection{Discretization}
\label{\detokenize{Chapters/Chapter10/Chapter10:discretization}}
\sphinxAtStartPar
Let’s first cast the equation:

\sphinxAtStartPar
\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\).

\sphinxAtStartPar
in a form suitable for numerical treatment.

\sphinxAtStartPar
We define a set of lattice points covering the region of interest in the \((x,y)\) plane.

\sphinxAtStartPar
For convenience, we take the lattice spacing \(h\) to be uniform and equal in both directions. Therefore, the unit square is covered by \(N\times N\) lattice squares, with points labeled by \((i,j)\), each of which runs from \(0\) to \(N\). The coordinates of point \((i,j)\) are \(x_i = ih\) and \(y_j = jh\).

\sphinxAtStartPar
We then define \(\phi_{ij} = \phi(x_i, y_j)\) and \(S_{ij} = S(x_i, y_j)\).

\sphinxAtStartPar
It is straightforward to apply a three\sphinxhyphen{}point difference for the second derivative (see, e.g. Chapter 9, section 2 for a derivation using a Taylor series expansion in one dimension):

\sphinxAtStartPar
\(\frac{\partial^2 \phi}{\partial x^2} \simeq \frac{ \phi_{i+1j} + \phi_{i-1j} - 2 \phi_{ij}}{h^2}\),

\sphinxAtStartPar
to get:

\sphinxAtStartPar
\(-\left[\frac{ \phi_{i+1j} + \phi_{i-1j} - 2 \phi_{ij}}{h^2} + \frac{ \phi_{ij+1} + \phi_{ij-1} - 2 \phi_{ij}}{h^2}\right] = S_{ij}\).


\subsection{Variational Principle Approach}
\label{\detokenize{Chapters/Chapter10/Chapter10:variational-principle-approach}}
\sphinxAtStartPar
We will be solving this equation shortly, but first let’s derive it in an alternate way, based on a \sphinxstyleemphasis{variational  principle}.

\sphinxAtStartPar
This approach is handy in cases where the coordinates are not Cartesian, or when more accurate formulas are needed.

\sphinxAtStartPar
The variational principle also provides some insnight into how the solution algorithm works.

\sphinxAtStartPar
Consider a quantity \(\mathcal{E}\), defined to be a \sphinxstyleemphasis{functional} of the field \(\phi\), of the form:

\sphinxAtStartPar
\(\mathcal{E} = \int_0^1 \mathrm{d} x  \int_0^1 \mathrm{d} y \left[ \frac{1}{2} (\nabla \phi)^2 - S \phi \right]\).

\sphinxAtStartPar
In some situations, \(\mathcal{E}\) has a physical interpretation. For example, in electrostatics, \(E = -\nabla \phi\) is the electric field and \(S\) is the charge density, making \(\mathcal{E}\) the total energy of the system.

\sphinxAtStartPar
In other situations, such as steady\sphinxhyphen{}state diffusion, \(\mathcal{E}\) should be viewed simply as a useful quantity.

\sphinxAtStartPar
At a solution to \(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\), \(\mathcal{E}\) is \sphinxstyleemphasis{stationary} under all variations of the solution \(\phi\), called \(\delta \phi\) that respect the Dirichlet boundary conditions imposed.

\sphinxAtStartPar
\(\mathcal{E}\) being stationary implies that:

\sphinxAtStartPar
\(\delta \mathcal{E} = 0\).

\sphinxAtStartPar
Let’s find an expression for \(\delta \mathcal{E}\). The “\(\delta\)” simply acts as any derivative would, and therefore:

\sphinxAtStartPar
\(\delta \mathcal{E} = \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d} y \left[ \mathbf{\nabla} \phi \cdot \mathbf{\nabla} \delta \phi - S \delta \phi\right]\).

\sphinxAtStartPar
To perform the integral of the first term by parts, we need to derive an appropriate integration by parts identity in two dimensions.

\sphinxAtStartPar
Starting with the \sphinxstyleemphasis{divergence theorem} in two dimensions for a vector field \(\mathbf{V}\):

\sphinxAtStartPar
\(\int_C \mathbf{V}\cdot \mathbf{\hat{n}} \mathrm{d}\ell = \int_S \mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A\),

\sphinxAtStartPar
whre the curve \(C\) is the boundary of the surface \(S\), and \(\mathbf{\hat{n}}\) is a unit vector perpendicular to \(C\).

\sphinxAtStartPar
Changing \(\mathbf{V} \rightarrow u\mathbf{V}\), where \(u\) is a scalar function:

\sphinxAtStartPar
\(\int_C u\mathbf{V}\cdot \mathbf{\hat{n}} \mathrm{d}\ell = \int_S \mathbf{\nabla} \cdot (u\mathbf{V}) \mathrm{d}A\).

\sphinxAtStartPar
Consider the RHS and expand:

\sphinxAtStartPar
\(\int_S \mathbf{\nabla} \cdot (u\mathbf{V}) \mathrm{d}A = \int_S u\mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A + \int_S \mathbf{\nabla }u \cdot \mathbf{V} \mathrm{d}A\).

\sphinxAtStartPar
And rearranging:

\sphinxAtStartPar
\(\int_S \mathbf{\nabla}u \cdot \mathbf{V} \mathrm{d}A = \int_S \mathbf{\nabla} \cdot (u\mathbf{V}) \mathrm{d}A - \int_S u\mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A\).

\sphinxAtStartPar
By the divergence theorem as written above:

\sphinxAtStartPar
\(\int_S \mathbf{\nabla}u \cdot \mathbf{V} \mathrm{d}A = \int_C u\mathbf{V}\cdot \mathbf{\hat{n}} \mathrm{d}\ell - \int_S u\mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A\).

\sphinxAtStartPar
If we now choose \(\mathbf{V} = \mathbf{\nabla}\phi\) and \(u = \delta \phi\), we have:

\sphinxAtStartPar
\(\int_S \mathbf{\nabla }\delta \phi \cdot\mathbf{\nabla}\phi \mathrm{d}A = \int_C \delta \phi \mathbf{\nabla} \phi\cdot\mathbf{\hat{n}} \mathrm{d}\ell - \int_S \delta \phi \mathbf{\nabla} \cdot \mathbf{\nabla} \phi \mathrm{d}A \),

\sphinxAtStartPar
an integration by parts formula in the necessary form.

\sphinxAtStartPar
Substituting the above into:

\sphinxAtStartPar
\(\delta \mathcal{E} = \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d} y \left[ \nabla \phi \cdot \nabla \delta \phi - S \delta \phi\right]\),

\sphinxAtStartPar
we get:

\sphinxAtStartPar
\(\delta \mathcal{E} = \int_C \delta \phi \mathbf{\nabla} \phi\cdot \mathbf{\hat{n}} \mathrm{d}\ell + \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d}y\delta \phi  [-\nabla^2 \phi - S]\),

\sphinxAtStartPar
where the line integral is over the boundary of the region of interest (\(C\)). Since we consider only variations that respect the boundary conditions, \(\delta \phi\) must vanish on \(C\), so that the line integral does as well.

\sphinxAtStartPar
Therefore:

\sphinxAtStartPar
\(\delta \mathcal{E} = \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d}y\delta \phi  [-\nabla^2 \phi - S]\),

\sphinxAtStartPar
and demanding that \(\delta \mathcal{E} =0\) for any \(\delta \phi\) implies that:

\sphinxAtStartPar
\(-\nabla^2 \phi - S = 0\), i.e. that \(\mathcal{E}\) is stationary when \(\phi\) is a solution to our differential equation.

\sphinxAtStartPar
Moreover, it can be shown that \(\mathcal{E}\) is not only stationary when \(\phi\) is a solution to the PDE, but that it is a minimum as well (left as an exercise!).

\sphinxAtStartPar
Let’s also derive a discrete approximation to the \(\mathcal{E}\) functional. We employ a two\sphinxhyphen{}point difference formula to approximate each first derivative in \((\mathbf{\nabla}\phi)^2\), at the points halfway between the lattice points, and use the trapezoid rule for the integrals.

\sphinxAtStartPar
As a reminder, the trapezoid rule for integration in one dimension is given by:

\sphinxAtStartPar
\(\int_a^b \mathrm{d} x f(x) = \frac{h}{2} \left[ f(a) + f(b) + 2 \sum_{i=1}^{N-1} f(x_i)\right]\).

\sphinxAtStartPar
In two dimensions, it can be shown that the trapezoid rule has the form:

\sphinxAtStartPar
\textbackslash{}begin\{align\}
\textbackslash{}int\_a\textasciicircum{}b \textbackslash{}mathrm\{d\} x \textbackslash{}int\_c\textasciicircum{}d \textbackslash{}mathrm\{d\} y f(x,y) \&= \textbackslash{}frac\{h\textasciicircum{}2\}\{4\} {[}f(a,c) + f(b,c) + f(a,d) + f(b,d)\textbackslash{}
\&+ 2 \textbackslash{}sum\_\{i=1\}\textasciicircum{}\{N\sphinxhyphen{}1\} f(x\_i, c) + 2 \textbackslash{}sum\_\{i=1\}\textasciicircum{}\{N\sphinxhyphen{}1\} f(x\_i, d)\textbackslash{}
\&+ 2 \textbackslash{}sum\_\{j=1\}\textasciicircum{}\{N\sphinxhyphen{}1\} f(a, y\_j) + 2 \textbackslash{}sum\_\{i=1\}\textasciicircum{}\{N\sphinxhyphen{}1\} f(b, y\_j)\textbackslash{}
\&+ 4 \textbackslash{}sum\_\{i=1\}\textasciicircum{}\{N\sphinxhyphen{}1\} \textbackslash{}sum\_\{j=1\}\textasciicircum{}\{N\sphinxhyphen{}1\} f(x\_i, y\_j){]}
\textbackslash{}end\{align\}

\sphinxAtStartPar
(see, e.g., \sphinxurl{https://math.stackexchange.com/questions/2891298/derivation-of-2d-trapezoid-rule} for a derivation)

\sphinxAtStartPar
This leads to:

\sphinxAtStartPar
\(\mathcal{E} = \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N [(\phi_{ij} - \phi_{i-1j})^2 + (\phi_{ij} - \phi_{ij-1})^2 ] - h^2 \sum_{i=1}^{N-1} \sum_{j=1}^{N-1} S_{ij} \phi_{ij}\).

\sphinxAtStartPar
Note that setting:

\sphinxAtStartPar
\(\frac{ \partial \mathcal{E}}{\partial \phi_{ij}} = 0 \forall ij\),

\sphinxAtStartPar
leads to the difference equation derived in the previous section.

\sphinxAtStartPar
Let’s now discuss where the boundary conditions enter the set of the linear equations:

\sphinxAtStartPar
\(-\left[\frac{ \phi_{i+1j} + \phi_{i-1j} - 2 \phi_{ij}}{h^2} + \frac{ \phi_{ij+1} + \phi_{ij-1} - 2 \phi_{ij}}{h^2}\right] = S_{ij}\).

\sphinxAtStartPar
Unless the coordinate system is well adapted to the geometry of the surfaces on which the boundary conditions are imposed, the lattice points will only roughly describe the geometry. One can always improve the accuracy by using a non\sphinxhyphen{}uniform lattice spacing, and place more points in the regions near the surfaces, or by transforming to a coordinate system in which the boundary conditions are expressed more naturally.

\sphinxAtStartPar
In any event, the boundary conditions will then provide the values of the \(\phi_{ij}\) at some subset of lattice points.

\sphinxAtStartPar
At a point far away from the boundaries, the boundary conditions do not enter directly. However, consider the equation at a point \sphinxstyleemphasis{just next} to the boundary, say \((i, N-1)\). Since \(\phi_{iN}\) is specified as a part of the boundary conditions, we can rewrite the equation as:

\sphinxAtStartPar
\(4 \phi_{iN-1} - \phi_{i+1N-1} - \phi_{i-1N-1} - \phi_{iN-2} = h^2 S_{ij} + \phi_{iN}\).

\sphinxAtStartPar
Therefore, \(\phi_{iN}\) enters \sphinxstyleemphasis{not} as an unknown, but rather as an inhomogeneous, \sphinxstyleemphasis{known} term.

\sphinxAtStartPar
These considerations show that the discrete approximation to the PDE is equivalent to a system of linear equations for the unknown values of \(\phi\) at the interior points.

\sphinxAtStartPar
In matrix notation:

\sphinxAtStartPar
\(\mathbf{M} \mathbf{\phi} = \mathbf{s}\),

\sphinxAtStartPar
where \(\mathbf{M}\) is the matrix appearing in the linear system of equations, and the inhomogeneous term \(\mathbf{s}\) is proportional to \(S\) at the interior points, and linearly related to the boundary conditions on \(\phi\).

\sphinxAtStartPar
In any sort of practical situation, there are a very large number of these equations, e.g. \(N^2 = 2500\) for, say, \(N=50\), so the solution by direct matrix inversion can be impractical.

\sphinxAtStartPar
Fortunately, sincew the discrete approximation to the Laplacian involves only neighboring points, most of the elements of \(\mathbf{M}\) vanish (since it is sparse), and there are efficient iterative techniques for solving the matrix equation.

\sphinxAtStartPar
We begin their discussion by considering an analogous, but simpler one\sphinxhyphen{}dimensional boundary value problem, and then return to the two\sphinxhyphen{}dimensional case.


\subsection{An Iterative Method for Boundary Value Problems}
\label{\detokenize{Chapters/Chapter10/Chapter10:an-iterative-method-for-boundary-value-problems}}
\sphinxAtStartPar
The one\sphinxhyphen{}dimensional boundary value problem analogous to the two\sphinxhyphen{}dimensional problem we have been discussing can be written as:

\sphinxAtStartPar
\( -\frac{ \mathrm{d}^2 \phi }{\mathrm{d} x^2} = S(x)\),

\sphinxAtStartPar
with \(\phi(0)\) and \(\phi(1)\) specified.

\sphinxAtStartPar
The related variational principle involves the quantity:

\sphinxAtStartPar
\(\mathcal{E} = \int_0^1 \mathrm{d} x \left[ \frac{1}{2} \left(\frac{\mathrm{d}\phi}{\mathrm{d}x}\right)^2 - S \phi \right]\).

\sphinxAtStartPar
This can be discretized on a uniform lattice with spacing \(h=1/N\) as:

\sphinxAtStartPar
\(\mathcal{E} = \frac{1}{2h} \sum_i^{N-1} (\phi_i - \phi_{i-1})^2 - h \sum_{i=1}^{N-1} S_i \phi_i\).

\sphinxAtStartPar
Considering variations with respect to \(\phi_i\) yields the difference equation:

\sphinxAtStartPar
\(2 \phi_i - \phi_{i+1} - \phi_{i-1} = h^2 S_i\),

\sphinxAtStartPar
which is nothing but the naive discretization of the differential equation.

\sphinxAtStartPar
We already discussed methods for solving the boundary value problem in one dimension in the previous chapter (using the forward/backward Numerov method), but we can also consider the equation together with the known values \(\phi_0\) and \(\phi_N\), as a set of linear equations.

\sphinxAtStartPar
For a modest number of points, say \(N \lesssim 100\), the system can be solved by direct matrix methods.

\sphinxAtStartPar
However, to illustrate the iterative methods appropriate for large sparse matrices of elliptic PDEs in two or more dimensions, let’s begin by solving for \(\phi\):

\sphinxAtStartPar
\(\phi_i = \frac{1}{2} [ \phi_{i+1} + \phi_{i-1} + h^2 S_i]\).

\sphinxAtStartPar
This equation is not manifestly useful, since we don’t know the \(\phi\)’s on the RHS. However, it can be interpreted as giving as an “improved” value for \(\phi_i\), based on the values of \(\phi\) at the neighboring points.

\sphinxAtStartPar
The strategy, known as Gauss\sphinxhyphen{}Seidel iteration, is then to guess some initial solution, and then to “sweep” systematically through the lattice (e.g. from left to right), successively replacing \(\phi\) at each point by an improved value.

\sphinxAtStartPar
Note that the most “current” values of the \(\phi_{i\pm 1}\) are to be used in the RHS of the equation. By repeating this sweep many times, an initial guess for \(\phi\) can be “relaxed” to the correct solution.

\sphinxAtStartPar
To investigate the convergence of this procedure, we generalize the equation, so that at each step of the relaxation, \(\phi_i\) is replaced by a linear mixture of its old value and the new “improved” one, given by:

\sphinxAtStartPar
\(\phi_i \rightarrow \phi_i' = (1-\omega) \phi_i + \frac{\omega}{2} [\phi_{i+1} + \phi_{i-1} + h^2 S_i]\).

\sphinxAtStartPar
Here, \(\omega\) is a parameter that can be adjusted to control the rate of relaxation.

\sphinxAtStartPar
To see that the above procedure leads to an “improvement” in the solution, we calculate the change in the energy functional (in one dimension), remembering that all the \(\phi\)’s except \(\phi_i\) are to be held fixed. After some algebra, one finds:

\sphinxAtStartPar
\(E'-E = -\frac{ \omega(2-\omega)}{2h} \left[ \frac{1}{2} (\phi_{i+1} + \phi_{i-1} + h^2 S_i) - \phi_i \right]^2 \leq 0\),

\sphinxAtStartPar
so that, as long as \(0 < \omega < 2\), the energy never increases, and should thus converge to the required minimum value as the sweeps proceed.


\subsection{Example 10.1: The relaxation method for partial differential equations in one dimension.}
\label{\detokenize{Chapters/Chapter10/Chapter10:example-10-1-the-relaxation-method-for-partial-differential-equations-in-one-dimension}}
\sphinxAtStartPar
(a) Use the relaxation method in one dimension to solve the boundary value problem defined by the differential equation:

\sphinxAtStartPar
\(-\frac{ \mathrm{d}^2 \phi }{\mathrm{d} x^2} = S(x)\),

\sphinxAtStartPar
with source term \(S(x) = 12 x^2\) and boundary conditions \(\phi(0) = \phi(1) = 0\). Start with \(\phi_i=0\) as your initial guess. Use \(N=40\) lattice steps and perform a few hundred iterations (e.g. 1000) to reach your solution. Perform all calculations for the values of the relaxation parameter \(\omega = 0.5, 1.0, 1.5\).

\sphinxAtStartPar
The relaxation method: Discretize the one\sphinxhyphen{}dimensional space and use the discretized “solved” iterative form:

\sphinxAtStartPar
\(\phi_i \rightarrow \phi'_i = (1-\omega)\phi_i + \frac{\omega}{2} [ \phi_{i+1} + \phi_{i-1} + h^2 S_i]\),

\sphinxAtStartPar
where \(\phi_i'\) is the updated value of \(\phi_i\) at lattice site \(i\), \(h\) is the lattice spacing, and \(\omega\) is a “relaxation” parameter.

\sphinxAtStartPar
Compare to the exact solution: \(\phi( x) = x(1-x^3)\).

\sphinxAtStartPar
(b) Write a function that calculates the energy functional, defined by:

\sphinxAtStartPar
\(\mathcal{E} = \int_0^1 \mathrm{d}x \left[ \frac{1}{2} \left( \frac{\mathrm{d}\phi }{\mathrm{d} x} \right)^2 - S \phi \right]\).

\sphinxAtStartPar
Use the discretized form:

\sphinxAtStartPar
\(\mathcal{E}= \frac{1}{2h} \sum_{i=1}^N (\phi_i - \phi_{i-1})^2 - h \sum_{i=1}^{N-1} S_i \phi_i\).

\sphinxAtStartPar
Calculate the value of the energy at the end of each iteration and plot the energy as a function of iteration.

\sphinxAtStartPar
Compare to the exact solution energy given by: \(\mathcal{E} = -9/14 \simeq -0.64286\).

\sphinxAtStartPar
Despite the rather poor initial guess for \(\phi\) in Example 10.1, the iterations converge and the converged energy is independent of the relaxation parameter, \(\omega\). The rate of convergence clearly depends on \(\omega\). A general analysis shows that the best choice for the relaxation parameter depends upon the lattice size and on the geometry of the problem, and it is found to be usually \(\omega > 1\). The optimal value can be determined empirically by examining the convergence of the solution for only a few iterations, before choosing a value to be used for many iterations.


\subsection{The Relaxation Method in Higher Dimensions}
\label{\detokenize{Chapters/Chapter10/Chapter10:the-relaxation-method-in-higher-dimensions}}
\sphinxAtStartPar
The generalization of the relaxation method to two\sphinxhyphen{}dimensional problems is straightforward.

\sphinxAtStartPar
For the differential equation:

\sphinxAtStartPar
\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\),

\sphinxAtStartPar
we get, for the updated value of the field at a point \((x_i, y_j)\):

\sphinxAtStartPar
\(\phi_{ij} \rightarrow \phi_{ij}' = (1-\omega) \phi_{ij} + \frac{\omega}{4} [\phi_{i+1j} + \phi_{i-1j} + \phi_{ij+1} + \phi_{ij-1} + h^2 S_{ij}]\).

\sphinxAtStartPar
This algorithm can be applied successively to each point on the lattice, say sweeping the rows in order from top to bottom and each row from left to right. One can again show that the energy functional,

\sphinxAtStartPar
\(\mathcal{E} = \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N [(\phi_{ij} - \phi_{i-1j})^2 + (\phi_{ij} - \phi_{ij-1})^2 ] - h^2 \sum_{i=1}^{N-1} \sum_{j=1}^{N-1} S_{ij} \phi_{ij}\),

\sphinxAtStartPar
always decreases, and there will be convergence to the required solution.

\sphinxAtStartPar
Several considerations can serve to enhance the convergence in practice:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Starting from a good guess at the solution, e.g. perhaps one with similar, but simpler, boundary conditions, will reduce the number of iterations required.

\item {} 
\sphinxAtStartPar
An optimal value of the relaxation parameter should be used, either estimated analytically or determined empirically (as described above).

\item {} 
\sphinxAtStartPar
It may sometimes be more efficient to concentrate the relaxation process, for several iterations, in some sub\sphinxhyphen{}area of the lattice, where the trial solution is known to be particularly poor, thus not wasting effort on already\sphinxhyphen{}relaxed parts of the solution.

\item {} 
\sphinxAtStartPar
One can always do a calculation on a relatively coarse lattice that relaxes with a small amount of numerical work, and then interpolate the solution found onto a finer lattice, to be used as the starting guess for further iterations.

\end{enumerate}


\section{Parabolic Partial Differential Equations}
\label{\detokenize{Chapters/Chapter10/Chapter10:parabolic-partial-differential-equations}}
\sphinxAtStartPar
Typical parabolic PDEs one encounters in physical situations are the diffusion equation:

\sphinxAtStartPar
\(\frac{\partial \phi}{\partial t} = \mathbf{\nabla} \cdot ( D \mathbf{\nabla} \phi ) + S\),

\sphinxAtStartPar
where \(D\) is the diffusion constant (possibly space\sphinxhyphen{}dependent) and \(S\) is a source function.

\sphinxAtStartPar
Another example is the Schrödinger equation:

\sphinxAtStartPar
\(i\frac{\partial \phi}{\partial t} = -\frac{ \hbar^2 } { 2 m} \nabla^2 \phi + V\phi\).

\sphinxAtStartPar
In contrast to the boundary value problems, these are generally of the initial value type: we are given the field \(\phi\) at an initial time, and seek to find it at a later time. The evolution is subject to certain spatial boundary conditions, e.g. the Schrödinger wave function vanishes at very large distances, or the temperature or heat flux is specified on some surfaces.

\sphinxAtStartPar
Methods by which such problems are solved on a computer are straightforward, although a few subtleties are involved.


\subsection{Naive Discretization and Instabilities}
\label{\detokenize{Chapters/Chapter10/Chapter10:naive-discretization-and-instabilities}}
\sphinxAtStartPar
We begin by treating diffusion in one dimension, with a uniform diffusion constant \(D=1\).

\sphinxAtStartPar
We take \(x \in [0,1]\) and assume Dirichlet boundary conditions that specify the value of the field at the end points of the interval.

\sphinxAtStartPar
We will focus on the rescaled equation:

\sphinxAtStartPar
\(\frac{\partial \phi}{\partial t} =  \frac{\partial^2 \phi}{\partial x^2} + S(x,t)\).

\sphinxAtStartPar
As before, we will approximate the spatial derivatives by finite differences on a uniform lattice of \(N+1\) points with spacing \(h=1/N\). The time derivative will be approximated by the simplest first\sphinxhyphen{}order difference formula, assuming a time step \(\Delta t\).

\sphinxAtStartPar
We will use a \sphinxstyleemphasis{superscript} \(n\) to label the time step:

\sphinxAtStartPar
\(\phi^n \equiv \phi(t_n)\), with \(t_n = n \Delta t\).

\sphinxAtStartPar
As our first approximation to the equation, we approximate the second derivative on the RHS as follows:

\sphinxAtStartPar
\(\frac{\partial^2 \phi}{\partial x^2} \equiv -\hat{H}\phi \approx \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2}\),

\sphinxAtStartPar
where we have also defined an operator which corresponds to minus the second spatial derivative, with the discretized form:

\sphinxAtStartPar
\(\hat{H} \phi^n_i = - \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2}\).

\sphinxAtStartPar
An “explicit” discretization, or differencing scheme, of the differential equation is then given by:

\sphinxAtStartPar
\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2} + S_i^n\).

\sphinxAtStartPar
If we then solve the differential equation for \(\phi\) at the next time step, we obtain:

\sphinxAtStartPar
\(\phi^{n+1} = (1-\hat{H} \Delta t) \phi^n + S^n \Delta t\),

\sphinxAtStartPar
where we have suppressed the index \(i\), essentially turning the above equation to a matrix equation.


\subsection{Example 10.2: Parabolic PDEs: a first example}
\label{\detokenize{Chapters/Chapter10/Chapter10:example-10-2-parabolic-pdes-a-first-example}}
\sphinxAtStartPar
Solve the differential equation (i.e. find \(\phi\) for later times):

\sphinxAtStartPar
\(\frac{\partial \phi}{\partial t} = \frac{ \partial^2 \phi}{\partial x^2} + S(x,t)\),

\sphinxAtStartPar
for \(S=0\) and \(\phi(0,t) = \phi(1,t) = 0\), satisfied by the initial condition of a Gaussian centered about \(x=1/2\):

\sphinxAtStartPar
\(\phi(x,t=0) = e^{-20(x-1/2)^2} - e^{-20(x-3/2)^2} - e^{-20(x+1/2)^2}\),

\sphinxAtStartPar
where the latter two “image” Gaussians approximately ensure the boundary conditions at \(x=1\) and \(x=0\), respectively.

\sphinxAtStartPar
Use the naive discretization formula:

\sphinxAtStartPar
\(\phi^{n+1} = (1 - \hat{H} \Delta t) \phi^n + S^n \Delta t\),

\sphinxAtStartPar
where \((H\phi)_i\equiv -\frac{1}{h^2} ( \phi_i + \phi_{i-1} - 2 \phi_i)\).

\sphinxAtStartPar
Integrate up to \(t_\mathrm{max} = 0.045\) with a time steps \(\Delta t = 0.00075\) and \(\Delta t = 0.0080\), over a lattice with \(N=25\).

\sphinxAtStartPar
Compare to the analytical solution:

\sphinxAtStartPar
\(\phi(x,t) = \tau^{-1/2} \left[ e^{-20(x-1/2)^2/\tau} - e^{-20(x-3/2)^2/\tau} - e^{-20(x+1/2)^2/\tau} \right]\), where \(\tau = 1 + 80t\).

\sphinxAtStartPar
Both time steps chosen are quite small compared to the natural time scale of the solution, \(t\approx 0.01\). Furthermore, as we increase the time step, we see that things go very wrong: an unphysical instability develops in the numerical solution, which quickly acquires violent oscillations from one lattice point to another.

\sphinxAtStartPar
Let’s try to understand what is happening here. Consider the differential equation with \(S=0\), as we are trying to solve in the above example:

\sphinxAtStartPar
\(\frac{\partial \phi}{\partial t} =  \frac{\partial^2 \phi}{\partial x^2}\).

\sphinxAtStartPar
The RHS can be replaced by the operator \(-\hat{H}\), to obtain:

\sphinxAtStartPar
\(\frac{\partial \phi(x,t)}{\partial t} = -\hat{H} \phi(x,t)\).

\sphinxAtStartPar
This can be formally solved to give:

\sphinxAtStartPar
\(\phi(x,t) = e^{-t\hat{H}} \phi(x,0)\).

\sphinxAtStartPar
If we now discretize time: \(t_n = n \Delta t\), \(\phi(t_n,x) = \phi^n\), as before, we get:

\sphinxAtStartPar
\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\).

\sphinxAtStartPar
Now let the set of states \(\psi_\lambda\) be the \sphinxstyleemphasis{eigenfunctions} of the operator \(\hat{H}\) with eigenvalues \(\epsilon_\lambda\).

\sphinxAtStartPar
Since \(\hat{H}\) is Hermitian, the eigenvalues \(\epsilon_\lambda\) are real and the eigenvectors can be chosen to be orthonormal.

\sphinxAtStartPar
What this implies is that we can expand the solution at any time in terms of this basis:

\sphinxAtStartPar
\(\phi^n = \sum_\lambda \phi^n_\lambda \psi_\lambda\),

\sphinxAtStartPar
where \(\phi^n_\lambda\) are effectively the coefficients of the expansion.

\sphinxAtStartPar
We also expand the initial condition in terms of the eigenvectors:

\sphinxAtStartPar
\(\phi^0 = \sum_{\lambda} \phi^0_\lambda \psi_\lambda\),

\sphinxAtStartPar
then, substituting into the formal discretized solution, \(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\), we obtain:

\sphinxAtStartPar
\(\sum_\lambda \phi^n_\lambda \psi_\lambda = e^{-n \hat{H} \Delta t} \sum_{\lambda} \phi_\lambda^0 \psi_\lambda\),

\sphinxAtStartPar
giving us the evolution of each component of the solution:

\sphinxAtStartPar
\(\phi_\lambda^n =  e^{-n \epsilon_\lambda \Delta t} \phi^0_\lambda\).

\sphinxAtStartPar
This corresponds to the correct behavior of the diffusion equation: short\sphinxhyphen{}wavelenght components (i.e. large eigenvalues \(\epsilon_\lambda\)), disappear more rapidly as the solution “smooths out”.

\sphinxAtStartPar
However, the naive discretization (i.e. the “explicit” scheme):

\sphinxAtStartPar
\(\phi^{n+1} = (1 - \hat{H} \Delta t) \phi^n\),

\sphinxAtStartPar
would result in:

\sphinxAtStartPar
\(\phi^n = (1 - \hat{H} \Delta t)^n \phi_0\),

\sphinxAtStartPar
or:

\sphinxAtStartPar
\(\phi^n_\lambda = (1- \epsilon_\lambda \Delta t)^n \phi^0\).

\sphinxAtStartPar
Recall one of the definitions of the exponential function:

\sphinxAtStartPar
\(e^{\alpha t} = \lim_{n\rightarrow \infty} (1 + \alpha \Delta t)^n\), with \(\Delta t = t/n\).

\sphinxAtStartPar
So the naive discretization in the limit \(\Delta t \rightarrow 0\) would yield the correct evolution:

\sphinxAtStartPar
\(\phi^n_\lambda = e^{-n \epsilon_\lambda \Delta t} \phi^0_\lambda\).

\sphinxAtStartPar
Therefore, as long as \(\Delta t\) is chosen to be small, \((1-\epsilon_\lambda \Delta t)^n\) approximates the exponential, and the short\sphinxhyphen{}wavelength (large \(\epsilon_\lambda\)) components dampen with time.

\sphinxAtStartPar
However, if \(\Delta t\) is too large, one or more of the quantities \(1 - \epsilon_\lambda \Delta t\) has an absolute value greater than unity. The corresponding components, even if present only due to very small numerical round\sphinxhyphen{}off errors, are then amplified with each time step, and soon grow to dominate.

\sphinxAtStartPar
To quantify the limit on \(\Delta t\), we have some guidance in that the eigenvalues of \(\hat{H}\) are known analytically in this simple model problem.

\sphinxAtStartPar
We have: \(\hat{H} = - \frac{ \partial^2 }{ \partial x^2}\). The eigenvalue equation is simply then:

\sphinxAtStartPar
\(\hat{H} \psi_\lambda = \epsilon_\lambda \psi_\lambda\)

\sphinxAtStartPar
\(\Rightarrow \frac{ \partial^2 \psi_\lambda }{ \partial x^2} = - \epsilon_\lambda \psi_\lambda\),

\sphinxAtStartPar
with \(\psi_\lambda(0) = \psi_\lambda(1) = 0\).

\sphinxAtStartPar
The eigenfunctions are then:

\sphinxAtStartPar
\(\psi_\lambda = A \sin \sqrt{\epsilon_\lambda} x\), with eigenvalues \(\sqrt{\epsilon_\lambda} = \lambda \pi\), with \(\lambda = 1,2,...\).

\sphinxAtStartPar
On a lattice with \(x_i = ih\), the discretized solutions are then:

\sphinxAtStartPar
\((\psi_\lambda)_i = A \sin \lambda \pi i h\),

\sphinxAtStartPar
and since \(h = 1/N\):

\sphinxAtStartPar
\((\psi_\lambda)_i = A \sin \frac{\lambda \pi i}{N}\).

\sphinxAtStartPar
The eigenvalues have to change when we move to the lattice. To find them, consider the action of the discretized form of \(\hat{H}\) on the discretized eigenfunctions:

\sphinxAtStartPar
\((\hat{H}\psi_\lambda)_i = -\frac{1}{h^2} \left[ (\psi_\lambda)_{i+1} + (\psi_\lambda)_{i-1} - 2 (\psi_\lambda)_{i} \right]\).

\sphinxAtStartPar
or:

\sphinxAtStartPar
\((\hat{H}\psi_\lambda)_i = -\frac{1}{h^2} \left[ \sin \frac{ \lambda \pi (i+1) } {N} + \sin \frac{ \lambda \pi (i-1) } {N}  - 2 \sin \frac{ \lambda \pi i} {N} \right]\).

\sphinxAtStartPar
Using the trigonometric identities \(\sin(A+B) = \sin A \cos B + \sin B \cos A\) and \(1-\cos \frac{ \lambda \pi } {N} = 2 \sin^2 \frac{ \lambda \pi } { 2N }\), it easy to verify that the eigenvalues after discretization are:

\sphinxAtStartPar
\(\epsilon_\lambda = \frac{4}{h^2} \sin^2 \frac{ \lambda \pi }{2 N}\).

\sphinxAtStartPar
The largest eigenvalue corresponds to: \(\lambda = N-1\), i.e.:

\sphinxAtStartPar
\(\epsilon_\lambda = 4/h^2 \left[ \sin\left(\frac{N\pi}{2N}\right) \cos\left(\frac{\pi}{2N}\right) - \cos\left(\frac{N\pi}{2N}\right) \sin\left(\frac{\pi}{2N}\right) \right]= 4/h^2 \cos\left(\pi/2N \right)\),

\sphinxAtStartPar
and to an eigenvector that changes sign from one lattice point to the next:

\sphinxAtStartPar
\((\psi_{N-1})_i = A \sin\left(\frac{(N-1) \pi i}{N}\right) = A\left[ \sin(\pi i) \cos\left(\frac{\pi i}{N}\right) - \cos(\pi i) \sin\left(\frac{\pi i}{N}\right)\right] \propto \cos \pi i\).

\sphinxAtStartPar
Requiring that \(| 1 - \epsilon_\lambda \Delta t | < 1\), then yields: \(\Delta t \lesssim h^2/2\), which in the case of our example corresponds to \(\Delta t \lesssim 0.0008\).

\sphinxAtStartPar
The question of stability is quite distinct from that of accuracy, as the limit imposed on the time step is set up by the spatial step used and not by the characteristic time scale of the solution, which is much larger.

\sphinxAtStartPar
The explicit scheme which we have discussed is unsatisfactory, as the instability forces us to use a much smaller time step than is required to describe the evolution adequately. Indeed, the situation gets even worse if we try to use a finer spatial lattice to obtain a more accurate solution.

\sphinxAtStartPar
Although the restriction on \(\Delta t\) that we have derived is rigorous only for the simple case we have considered, it does provide a useful guide for more complicated situations, as the eigenvector of \(\hat{H}\) with the largest eigenvalue will always oscillate from one lattice point to the next. Its eigenvalue is therefore quite insensitive to the global features of the problem.


\subsection{Implicit Schemes}
\label{\detokenize{Chapters/Chapter10/Chapter10:implicit-schemes}}
\sphinxAtStartPar
One way around the instability of the explicit algorithm discussed above, is to retain the general form:

\sphinxAtStartPar
\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2} + S_i^n\),

\sphinxAtStartPar
but to replace the second space derivative by that of the solution, \sphinxstyleemphasis{at the new time}, i.e.:

\sphinxAtStartPar
\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i }{h^2} + S_i^n\).

\sphinxAtStartPar
This defines an \sphinxstyleemphasis{implicit} scheme, since the unknown, \(\phi^{n+1}\) appears on both sides of the equation.

\sphinxAtStartPar
In terms of the operator \((\hat{H}\phi^{n+1})_i = -\frac{\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i}{h^2}\), the above implicit equation can be written as:

\sphinxAtStartPar
\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = -\hat{H}\phi^{n+1}_i + S_i^n\).

\sphinxAtStartPar
Solving for \(\phi^{n+1}\), we get:

\sphinxAtStartPar
\(\phi^{n+1} = \frac{1}{1 + \hat{H} \Delta t} \left[ \phi^n + S^n \Delta t \right]\).

\sphinxAtStartPar
This scheme is equivalent to the explicit scheme to lowest order in \(\Delta t\) (as seen by expanding the denominator). However, it is much better in that larger time steps can be used, as the operator \((1 + \hat{H} \Delta t)^{-1}\) has eigenvalues \((1+\epsilon_\lambda \Delta t)^{-1}\), all of whose moduli are less than 1 for any value of \(\Delta t\). Although this decrease is inaccurate (i.e. not exponential as expected by the “formal” solution of the diffusion equation), for the most rapidly oscillating components, such components should not be large in the initial conditions, if the spatial discretization is accurate.

\sphinxAtStartPar
In any event, there’s no amplification of the large\sphinxhyphen{}eigenvalue components, which caused the instability found in the explicit scheme. For the slowly\sphinxhyphen{}varying components of the solution, corresponding to small eigenvalues, the evolution closely approximates the exponential behavior at each step.

\sphinxAtStartPar
A potential drawback is that it requires the solution of a set of linear equations (albeit tri\sphinxhyphen{}diagonal) at each time step to find \(\phi^{n+1}\). This is equivalent to the application of the inverse of the matrix \((1+\hat{H} \Delta t)^{-1}\) to the vector appearing in the brackets. Since the inverse itself is time\sphinxhyphen{}independent, it might be found only once at the beginning of the calculation and then used for all times, but application still requires \(N^2\) operations if done directly.

\sphinxAtStartPar
Fortunately, there exists an algorithm that provides a very efficient solution (\(\mathcal{O}(N)\) operations) of a tri\sphinxhyphen{}diagonal system of equations, known as “Gaussian elimination and back\sphinxhyphen{}substitution”.

\sphinxAtStartPar
The algorithm proceeds as follows: let’s consider trying to solve the tri\sphinxhyphen{}diagonal linear system of equations:

\sphinxAtStartPar
\(\mathbf{A} \mathbf{\phi} = \mathbf{b}\) for the unknowns \(\phi_i\):

\sphinxAtStartPar
\(A_i^- \phi_{i-1}^{n+1} + A^0_i \phi_i^{n+1} + A^+_i \phi_{i+1}^{n+1} = b_i\).

\sphinxAtStartPar
Here, the \(A^{\pm,0}_i\) are the only non\sphinxhyphen{}vanishing elements of \(\mathbf{A}\) and the \(b_i\) are the known quantities. This is exactly the form of the problem posed by the evaluation of our problem:

\sphinxAtStartPar
\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i }{h^2} + S_i^n\).

\sphinxAtStartPar
rearranging:

\sphinxAtStartPar
\(\phi_i^{n+1} - \frac{\Delta t}{h^2} \left[\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i\right] =  \phi_i^n + S_i^n\),

\sphinxAtStartPar
to get:

\sphinxAtStartPar
\( - \frac{\Delta t}{h^2} \phi^{n+1}_{i-1} + \left( 1 - 2\frac{\Delta t} {h^2}\right) \phi^{n+1}_i  - \frac{\Delta t}{h^2} \phi^{n+1}_{i+1} =  \phi_i^n + S_i^n \Delta t\),

\sphinxAtStartPar
which corresponds to:

\sphinxAtStartPar
\(b_i = \phi_i^n + S_i^n \Delta t\),

\sphinxAtStartPar
\(A_i^0 = 1 + 2\frac{\Delta t} {h^2}\),

\sphinxAtStartPar
\(A_i^\pm = - \frac{\Delta t} {h^2}\).

\sphinxAtStartPar
To solve this system of equations, we assume that the solution satisfies a one\sphinxhyphen{}term \sphinxstyleemphasis{forward} recursion relation of the form:

\sphinxAtStartPar
\(\phi^{n+1}_{i+1} = \alpha_i \phi^{n+1}_i + \beta_i\),

\sphinxAtStartPar
where the coefficients \(\alpha_i\) and \(\beta_i\) are to be determined.

\sphinxAtStartPar
Substituting the above relation into the linear system of equations:

\sphinxAtStartPar
\(A^-_i \phi_{i-1}^{n+1} + A_i^0 \phi_i^{n+1} + A_i^+ (\alpha_i \phi^{n+1}_i + \beta_i) = b_i\),

\sphinxAtStartPar
and solving for \(\phi_i^{n+1}\), we get:

\sphinxAtStartPar
\(\phi^{n+1}_i = \gamma_i A_i^- \phi^{n+1}_{i-1} + \gamma_i (A^+_i \beta_i - b_i)\),

\sphinxAtStartPar
with \(\gamma_i = -\frac{ 1 }{A_i^0 + A_i^+ \alpha_i}\).

\sphinxAtStartPar
comparing the above with: \(\phi^{n+1}_{i} = \alpha_{i-1} \phi^{n+1}_{i-1} + \beta_{i-1}\), i.e. the hypothesis with \(i\rightarrow i-1\), we can identify the following recursion relations for the \(\alpha\)’s and \(\beta\)’s:

\sphinxAtStartPar
\(\alpha_{i-1} = \gamma_i A^-_i\),

\sphinxAtStartPar
\(\beta_{i-1} = \gamma_i (A_i^+ \beta_i - b_i)\).

\sphinxAtStartPar
Note that these are \sphinxstyleemphasis{backward} recursion relations.

\sphinxAtStartPar
The strategy to solve the problem then proceeds as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
We use the \(\alpha_{i-1}\), \(\beta_{i-1}\) and \(\gamma_i\) relations to sweep the lattice \sphinxstyleemphasis{backwards} to determine the \(\alpha_i\) and \(\beta_i\), running from \(N-2\) down to 0. The starting values to be used are: \(\alpha_{N-1} = 0\) and \(\beta_{N-1} = \phi_N^n\), which will guarantee the correct value of \(\phi\) at the last lattice point.

\item {} 
\sphinxAtStartPar
Having determined these coefficients, we can then use the recursion relation: \(\phi^{n+1}_{i+1} = \alpha_i \phi^{n+1}_i + \beta_i\) in a \sphinxstyleemphasis{forward} sweep from \(i=0\) to \(i=N-1\) to determine the solution, with the starting value of \(\phi_0^{n+1}\) known from the boundary conditions.

\end{enumerate}

\sphinxAtStartPar
We have then determined the solution in only two sweeps of he lattice, involving \(\mathcal{O}(N)\) arithmetic operations. The increase in numerical effort per time step is about a factor of two.

\sphinxAtStartPar
\sphinxstyleemphasis{Note that}: the \(\alpha_i\) and \(\gamma_i\) are independent of \(\mathbf{b}\), so that it is more efficient to compute these coefficients only once and store them at the beginning of the calculation. Only the \(\beta_i\) are then needed to be computed for each time step.


\subsection{Example 10.3: Application of the Implicit Scheme for Parabolic PDEs}
\label{\detokenize{Chapters/Chapter10/Chapter10:example-10-3-application-of-the-implicit-scheme-for-parabolic-pdes}}
\sphinxAtStartPar
Use the implicit scheme to solve the problem of Example 10.2. Use a lattice with \(N=25\) intervals. Try time steps of \(\Delta t = 0.00075\) and \(\Delta t=0.005\).

\sphinxAtStartPar
Compare to the exact solution by graphing the results at \(t=0.045\).


\subsection{Solution by Direct Matrix Multiplication}
\label{\detokenize{Chapters/Chapter10/Chapter10:solution-by-direct-matrix-multiplication}}
\sphinxAtStartPar
Modern computers are efficient at matrix manipulations. The number of operations for the solution of parabolic PDEs will be higher than what has been discussed in the previous sections, but nevertheless, for small problems, it should be efficient enough.

\sphinxAtStartPar
Let’s write down the form of the \(\hat{H}\) operator in the matrix representation. This is easy, since we know its action (up to a factor of \(-1/h^2\)):

\sphinxAtStartPar
\((\hat{H}\phi)_i \propto \phi_{i+1} + \phi_{i-1} - 2\phi_i\).

\sphinxAtStartPar
E.g. for \(i=1\):

\sphinxAtStartPar
\((\hat{H}\phi)_1 \propto \phi_{2} + \phi_{0} - 2\phi_1\),

\sphinxAtStartPar
for \(i=2\):

\sphinxAtStartPar
\((\hat{H}\phi)_2 \propto \phi_{3} + \phi_{1} - 2\phi_2\),

\sphinxAtStartPar
for \(i=N-1\):

\sphinxAtStartPar
\((\hat{H}\phi)_{N-1} \propto \phi_{N} + \phi_{N-2} - 2\phi_{N-1}\),

\sphinxAtStartPar
or in matrix form:

\sphinxAtStartPar
\(\hat{H} \propto \left(\begin{array}{cccccc} 
0 & 0 & ... & 0 & 0 &  0\\
1 & -2 & 1 & 0 & 0 & ... \\
0 & 1 & -2 & 1 & 0 & ... \\ 
\ddots & \ddots &  \ddots & \ddots & \ddots & \ddots \\
0 & 0 & ... & 1 & -2 & 1 \\
0 & 0 & ... & 0 & 0 &  0\\
\end{array}\right)\).

\sphinxAtStartPar
Therefore, to obtain a solution in the implicit scheme:

\sphinxAtStartPar
\(\phi^{n+1} = [1 + \hat{H} \Delta t]^{-1} \left[ \phi^n + S^n \Delta t \right]\),

\sphinxAtStartPar
with:

\sphinxAtStartPar
\((\hat{H}\phi)_i = -\frac{\phi_{i+1} + \phi_{i-1} - 2 \phi_i}{h^2}\),

\sphinxAtStartPar
all we need to do is find the inverse of the matrix operator:

\sphinxAtStartPar
\([1 + \hat{H} \Delta t]\).

\sphinxAtStartPar
Note that the inverse is calculated in NumPy via:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{np.linalg.inv()}}

\sphinxAtStartPar
On the other hand, we can also use the \sphinxstyleemphasis{full} time evolution formula derived from the formal solution, via the matrix exponential.

\sphinxAtStartPar
Starting from the PDE:

\sphinxAtStartPar
\(\frac{\partial \phi(x,t)}{\partial t} = -\hat{H} \phi(x,t)\).

\sphinxAtStartPar
This can be formally solved to give:

\sphinxAtStartPar
\(\phi(x,t) = e^{-t\hat{H}} \phi(x,0)\),

\sphinxAtStartPar
which implies, in the discretized form, that:

\sphinxAtStartPar
\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\).

\sphinxAtStartPar
A single time step therefore corresponds to:

\sphinxAtStartPar
\(\phi^{n+1} = e^{-\Delta t \hat{H}} \phi^n\).

\sphinxAtStartPar
The matrix exponential can be calculated in SciPy (via a Padé approximant, see \sphinxurl{https://epubs.siam.org/doi/10.1137/09074721X}):

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scipy.linalg.expm()}},

\sphinxAtStartPar
allowing us to perform the direct time step evolution in the simple case we are considering.


\subsection{Example 10.4: Direct inversion of the matrix and the full evolution}
\label{\detokenize{Chapters/Chapter10/Chapter10:example-10-4-direct-inversion-of-the-matrix-and-the-full-evolution}}
\sphinxAtStartPar
Use direct inversion of the tri\sphinxhyphen{}diagonal matrix to calculate the evolution in the problem of Examples 10.3 and 10.4.

\sphinxAtStartPar
(a) Use the implicit formula as the starting point:

\sphinxAtStartPar
\(\phi^{n+1} = \frac{1}{1 + \hat{H} \Delta t} \left[ \phi^n + S^n \Delta t \right]\),

\sphinxAtStartPar
with:

\sphinxAtStartPar
\((\hat{H}\phi)_i = -\frac{\phi_{i+1} + \phi_{i-1} - 2 \phi_i}{h^2}\).

\sphinxAtStartPar
(b) Use the \sphinxstyleemphasis{full} evolution formula:

\sphinxAtStartPar
\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\),

\sphinxAtStartPar
in the form:

\sphinxAtStartPar
\(\phi^{n+1} = e^{-\Delta t \hat{H}} \phi^n\).

\sphinxAtStartPar
You may use the matrix SciPy exponential:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scipy.linalg.expm}}


\subsection{Diffusion and Boundary Value Problems in Higher Dimensions}
\label{\detokenize{Chapters/Chapter10/Chapter10:diffusion-and-boundary-value-problems-in-higher-dimensions}}
\sphinxAtStartPar
We saw that diffusion in one dimension is best handled either by an implicit method or by direct inversion of a tri\sphinxhyphen{}diagonal matrix.

\sphinxAtStartPar
It is therefore natural to extend this approach to two or more spatial dimensions.

\sphinxAtStartPar
For the two\sphinxhyphen{}dimensional diffusion equation:

\sphinxAtStartPar
\(\frac{ \partial \phi }{\partial t} = \nabla^2 \phi\),

\sphinxAtStartPar
the discretization is straightforward, and following our discussion of the one\sphinxhyphen{}dimensional problem, the time evolution should be effected by:

\sphinxAtStartPar
\(\phi^{n+1} = \frac{1}{ 1 + \hat{H} \Delta t} \phi^n\),

\sphinxAtStartPar
where now:

\sphinxAtStartPar
\((\hat{H}\phi)_{ij} = -\frac{1}{h^2} \left[ (\phi_{i+1j} + \phi_{i-1j} - 2\phi_{ij}) + (\phi_{ij+1} + \phi_{ij-1} - 2\phi_{ij}) \right]\).

\sphinxAtStartPar
Despite the fact that \(\hat{H}\) is very sparse, it is not tri\sphinxhyphen{}diagonal, and therefore one\sphinxhyphen{}dimensional algorithm does not apply.

\sphinxAtStartPar
However, \(\hat{H}\) can be written as a sum of operators that separately involve differences only in the \(i\) or \(j\) indices:

\sphinxAtStartPar
\(\hat{H} = \hat{H}_i + \hat{H}_j\),

\sphinxAtStartPar
where \(\hat{H}_i = -\frac{1}{h^2} (\phi_{i+1j} + \phi_{i-1j} - 2\phi_{ij})\) and \(\hat{H}_j = -\frac{1}{h^2} (\phi_{ij+1} + \phi_{ij-1} - 2\phi_{ij})\).

\sphinxAtStartPar
This means that we can write down an equivalent expression up to \(\mathcal{O}(\Delta t)\) to the original one:

\sphinxAtStartPar
\(\phi^{n+1} = \frac{1}{1 + \hat{H}_i \Delta t} \frac{1}{1 + \hat{H}_j \Delta t} \phi^n\).

\sphinxAtStartPar
This now can be evaluated as before, as each of the required inversions involves a tri\sphinxhyphen{}diagonal matrix.

\sphinxAtStartPar
If we define the auxiliary function \(\phi^{n+1/2}\), then we can write:

\sphinxAtStartPar
\(\phi^{n+1/2} = \frac{1}{1 + \hat{H}_j \Delta t} \phi^n\),

\sphinxAtStartPar
and:

\sphinxAtStartPar
\(\phi^{n+1} = \frac{1}{1 + \hat{H}_i \Delta t} \phi^{n+1/2}\).

\sphinxAtStartPar
Thus, \((1 + \hat{H}_j \Delta t)^{-1}\) is applied by forward and backward sweeps of the lattice in the \(j\) direction, independently for each value of \(i\). The application of \((1+\hat{H}_i \Delta t)^{-1}\) is then carried out by forward and backward sweeps in the \(i\) direction, independently for each value of \(j\). This “alternating\sphinxhyphen{}direction” scheme is stable for all values of the time step and is generalized straightforwardly to three dimensions.


\section{Iterative Methods for Eigenvalue Problems}
\label{\detokenize{Chapters/Chapter10/Chapter10:iterative-methods-for-eigenvalue-problems}}
\sphinxAtStartPar
Our analysis of the diffusion equation shows that the net result of time evolution is to enhance those components of the solution with smaller eigenvalues of \(\hat{H}\) relative to those with larger eigenvalues.

\sphinxAtStartPar
Indeed, for very long times, it is only that component with the lowest eigenvalue that is significant, although it has a very small amplitude.

\sphinxAtStartPar
This suggests a scheme for finding the lowest eigenvalue of an elliptic operator, solving the problem:

\sphinxAtStartPar
\(-\left( \frac{ \partial^2 } { \partial x^2 } + \frac{ \partial^2 } { \partial y^2 } \right) \phi + V(x,y) \phi = \epsilon \phi\),

\sphinxAtStartPar
by guessing a trial eigenvector and subjecting it to a \sphinxstyleemphasis{fictitious} time evolution that will “filter” it to the eigenvector having lowest eigenvalue.

\sphinxAtStartPar
Since we are dealing with a linear problem, the relentlessly decreasing or increasing magnitude of the solution can be avoided by renormalizing continuously as time proceeds.

\sphinxAtStartPar
Concretely, consider the time\sphinxhyphen{}independent Schrödinger equation in one dimension with \(\hbar = 2m = 1\). The eigenvalue problem is then:

\sphinxAtStartPar
\(\left[ -\frac{ \mathrm{d}^2 } { \mathrm{d} x^2 } + V(x) \right] \phi = \epsilon \phi\),

\sphinxAtStartPar
with the normalization condition:

\sphinxAtStartPar
\(\int \mathrm{d} x \phi^2 = 1\).

\sphinxAtStartPar
Note that \(\phi\) can always chosen to be real if \(V\) is.

\sphinxAtStartPar
The corresponding energy functional is:

\sphinxAtStartPar
\(\mathcal{E} = \int \mathrm{d}x \left[ \left( \frac{ \mathrm{d} \phi } { \mathrm{d} x} \right)^2 + V(x) \phi^2(x) \right]\).

\sphinxAtStartPar
We know that \(\mathcal{E}\) is stationary at an eigenfunction with respect to variations of \(\phi\) that respect the normalization condition, and that the value of \(\mathcal{E}\) at this eigenfunction is the associated eigenvalue.

\sphinxAtStartPar
To derive a discrete approximation to this problem, we first discretize \(\mathcal{E}\) as:

\sphinxAtStartPar
\(\mathcal{E} = \sum_i h \left[ \frac{ (\phi_i - \phi_{i-1})^2 } { h^2 } + V_i \phi_i^2 \right]\),

\sphinxAtStartPar
and the normalization constraint takes the form:

\sphinxAtStartPar
\(\sum_i h \phi^2_i = 1\).

\sphinxAtStartPar
Variation with respect to \(\phi\) gives the eigenvalue problem:

\sphinxAtStartPar
\((\hat{H} \phi)_i \equiv -\frac{1}{h^2} ( \phi_{i+1} + \phi_{i-1} - 2 \phi_i )  + V_i \phi_i = \epsilon \phi_i\),

\sphinxAtStartPar
(Note that \(\epsilon\) enters as a Lagrange multiplier that ensures the normalization).

\sphinxAtStartPar
The above defines the problem of finding the real eigenvalues and eigenvectors of a (large) symmetric tri\sphinxhyphen{}diagonal matrix representing the operator \(\hat{H}\).

\sphinxAtStartPar
Although we have already discussed direct methods for solving this problem (e.g. the Numerov algorithm), they cannot be applied to the very large matrices that arise in two\sphinxhyphen{} and three\sphinxhyphen{}dimensional problems.

\sphinxAtStartPar
In such cases, one is usually interested in the few highest or lowest eigenvalues of the problem, and for these the diffusion picture is appropriate.

\sphinxAtStartPar
We thus consider the problem:

\sphinxAtStartPar
\(\frac{ \partial \phi } { \partial \tau } = -\hat{H} \phi\),

\sphinxAtStartPar
where \(\tau\) is a “fake” time.

\sphinxAtStartPar
For convenience, we can arrange the problem such that the lowest eigenvalue of \(\hat{H}\) is positive definite. This can be guaranteed by shifting \(\hat{H}\) by a spatially\sphinxhyphen{}independent constant, chosen so that the resultant \(V_i\) is positive \(\forall i\).

\sphinxAtStartPar
To solve this “fake” diffusion problem, any of the algorithms discussed previously in this chapter can be employed.

\sphinxAtStartPar
The simplest is the “explicit” scheme:

\sphinxAtStartPar
\(\phi^{n+1} \sim (1 - \hat{H} \Delta \tau) \phi^n\),

\sphinxAtStartPar
where \(\Delta \tau\) is a small, positive parameter. The symbol \(\sim\) is used to indicate that \(\phi^{n+1}\) is to be normalized to unity according to the discrete normalization condition stated above. For an initial guess, we can choose \(\phi^0\) to be anything not orthogonal to the exact eigenfunction, although guessing something close to the solution will speed the convergence.

\sphinxAtStartPar
At each step in this refining process, computation of the energy furnishes an estimate of the true eigenvalue.

\sphinxAtStartPar
As a first example, let’s consider the infinite square well.


\subsection{Example 10.5: The Infinite Square Well Using the Fake Diffusion Method}
\label{\detokenize{Chapters/Chapter10/Chapter10:example-10-5-the-infinite-square-well-using-the-fake-diffusion-method}}
\sphinxAtStartPar
(a) Use the fake time diffusion method on a lattice with 21 points to find the lowest eigenvalue and the corresponding eigenstate, of the infinite square well.

\sphinxAtStartPar
Start with a trial eigenfunction \(\phi(x) = x(1-x)\) and perform \sphinxstyleemphasis{100} time evolutions with a time step \(\Delta \tau = 0.00075\).

\sphinxAtStartPar
\(V(x) = 0\) for \(0 \leq x \leq 1\), \(V(x)= \infty\) otherwise, with \(\phi(0) = \phi(1) = 0\).

\sphinxAtStartPar
You may set \(\hbar = 2m = 1\) and solve the problem:

\sphinxAtStartPar
\(\left[ -\frac{ \mathrm{d}^2 } { \mathrm{d} x^2 } + V(x) \right] \phi = \epsilon \phi\).

\sphinxAtStartPar
(b) Plot the lowest eigenfunction and compare to the exact one.

\sphinxAtStartPar
(c) Plot the evolution of the eigenvalue for each time step and show that it converges to the correct lowest one.

\sphinxAtStartPar
(d) Use the explicit method to find the \sphinxstyleemphasis{largest eigenvalue}. Use a time step of \(\Delta \tau = 0.0015\). Compare to your expectation from the largest eigenvalue for the discrete case with \(N=21\).

\sphinxAtStartPar
Recall that the exact eigenfunctions and eigenvalues are given by:

\sphinxAtStartPar
\(\psi_\lambda = \sqrt{2}^{1/2} \sin \lambda \pi x\) with \(\epsilon_\lambda = \lambda^2 \pi^2\), where \(\lambda\) is a non\sphinxhyphen{}zero integer.

\sphinxAtStartPar
Also recall that in the discretized form, \(\epsilon_\lambda = \frac{4}{h^2} \sin^2 \frac{ \lambda \pi } { 2N }\).

\sphinxAtStartPar
Although the procedure works, it is unsatisfactory in that the limitation on the size of \(\Delta \tau\) caused by the lattice spacing often results in having to iterate many times to refine a poor trial function. This can be alleviated to some extent by choosing a good trial function. Even better is to use an implicit scheme that does not amplify the large\sphinxhyphen{}eigenvalue components for any value of \(\Delta \tau\).

\sphinxAtStartPar
Another possibility is to use \(\exp(-\hat{H} \Delta \tau)\) to refine the trial function, as we did before.

\sphinxAtStartPar
The method can be used to find other eigenvalues, e.g. the second\sphinxhyphen{}lowest eigenvalue:
\begin{itemize}
\item {} 
\sphinxAtStartPar
First find the lowest eigenvalue and eigenfunction by the method described above.

\item {} 
\sphinxAtStartPar
A trial function for the second eigenfunction is then guessed and refined in the same way, taking care that at each stage of the refinement, the solution remains orthogonal to the lowest eigenfunction already found. This can be done by projecting out the component of the solution not orthogonal to the lowest eigenfunction.

\end{itemize}

\sphinxAtStartPar
Having found the 2nd\sphinxhyphen{}lowest eigenvalue, the third\sphinxhyphen{}lowest can be found similarly, taking care that during its refinement, it remains orthogonal to both of the eigenfunctions with lower eigenvalues.

\sphinxAtStartPar
This process cannot be applied to find more than the few lowest (or highest) eigenvalues, as numerical round\sphinxhyphen{}off errors in the orthogonalizations to the many previously\sphinxhyphen{}found eigenvectors soon grow to dominate.

\sphinxAtStartPar
Although the methods described have been illustrated by a one\sphinxhyphen{}dimensional example, it should be clear that the can be applied directly to find the eigenvalues and eigenfunctions of elliptic operators in two or more dimensions.

\sphinxstepscope


\chapter{More Monte Carlo: The Metropolis Algorithm}
\label{\detokenize{Chapters/Chapter11/Chapter11:more-monte-carlo-the-metropolis-algorithm}}\label{\detokenize{Chapters/Chapter11/Chapter11::doc}}

\section{The Algorithm of Metropolis et al.}
\label{\detokenize{Chapters/Chapter11/Chapter11:the-algorithm-of-metropolis-et-al}}
\sphinxAtStartPar
We have already discussed algorithms for generating random numbers according to a specified distribution (e.g. via von Neumann rejection).

\sphinxAtStartPar
However, it is difficult, or impossible, to generalize them to sample a complicated weight function in many dimensions, and so an alternate approach is required.

\sphinxAtStartPar
A very general way to produce random variables with a given probability distribution of arbitrary form is the algorithm of Metropolis, Rosenbluth, Rosenbluth, Teller and Teller (\sphinxurl{https://doi.org/10.1063/1.1699114}).

\sphinxAtStartPar
This algorithm requires only the ability to calculate the weight function for a given value of the integration variable.

\sphinxAtStartPar
It proceeds as follows: Suppose we want to generate a set of points in a possibly multi\sphinxhyphen{}dimensional space of variables, \(\mathbf{X}\), distributed with probability density \(w(\mathbf{X})\).

\sphinxAtStartPar
The Metropolis et al. algorithm generates a sequence of points:

\sphinxAtStartPar
\(\mathbf{X}_0, \mathbf{X}_1, ...\),

\sphinxAtStartPar
as those visited successively by a random walker moving through \(\mathbf{X}\) space.

\sphinxAtStartPar
As the walk gets longer and longer, the points it connects approximate more closely the desired distribution.

\sphinxAtStartPar
The rules of the random walk through configuration space are as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Suppose a random walker is at point \(\mathbf{X}_n\) in the sequence.

\item {} 
\sphinxAtStartPar
To generate \(\mathbf{X}_{n+1}\), it makes a \sphinxstyleemphasis{trial step} to a new point, \(\mathbf{X}_t\).

\item {} 
\sphinxAtStartPar
This new point can be chosen in any convenient manner, e.g. uniformly at random within a multi\sphinxhyphen{}dimensional cube of small size \(\delta\) about \(\mathbf{X}_n\).

\item {} 
\sphinxAtStartPar
The trial step is then “accepted” or “rejected” according to the ratio:

\end{itemize}

\sphinxAtStartPar
\( r = \frac{ w(\mathbf{X}_t) } { w(\mathbf{X}_n) }\).

\sphinxAtStartPar
If \(r>1\) then the step is accepted and we set \(\mathbf{X}_{n+1} = \mathbf{X}_t\), while if \(r<1\), the step is accepted with probability \(r\).

\sphinxAtStartPar
This is accomplished by comparing \(r\) with a random number \(\eta\), uniformly distributed in \([0,1]\), and accepting the step if \(\eta < r\).

\sphinxAtStartPar
If the trial step is not accepted, then it is rejected and we put \(\mathbf{X}_{n+1} = \mathbf{X}_n\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
This generates \(\mathbf{X}_{n+1}\), and we may then proceed to generate \(\mathbf{X}_{n+2}\) by the same process, making a trial step from \(\mathbf{X}_{n+1}\).

\item {} 
\sphinxAtStartPar
Any arbitrary point \(\mathbf{X}_0\) can be chosen as the starting point for the random walk.

\item {} 
\sphinxAtStartPar
During this process, the code could be made more efficient by saving the weight function at the current point of the random walk, so that it need not be computed again when deciding whether or not to accept the trial step. The evaluation of \(w\) is often the most time\sphinxhyphen{}consuming part of a Monte Carlo calculation using the Metropolis et al. algorithm.

\end{itemize}


\section{Proof of the Metropolis et al. Algorithm}
\label{\detokenize{Chapters/Chapter11/Chapter11:proof-of-the-metropolis-et-al-algorithm}}
\sphinxAtStartPar
To prove that the algorithm does indeed generate a sequence of points distributed according to \(w\), let us consider a large number of walkers, starting from different initial points and moving independently through \(\mathbf{X}\) space.

\sphinxAtStartPar
If \(N_n(\mathbf{X})\) is the density of walkers at \(\mathbf{X}\) after \(n\) steps, then the net number of walkers moving from point \(\mathbf{X}\) to a point \(\mathbf{Y}\) in the next step is:

\sphinxAtStartPar
\(\Delta N(\mathbf{X}) = N_n(\mathbf{X}) P(\mathbf{X} \rightarrow \mathbf{Y}) - N_n(\mathbf{Y}) P(\mathbf{Y} \rightarrow \mathbf{X})\),

\sphinxAtStartPar
where \(P(\mathbf{X} \rightarrow \mathbf{Y})\) is the probability that a walker will make a transition to \(\mathbf{Y}\) if it is at \(\mathbf{X}\).

\sphinxAtStartPar
Taking out a common factor \(N_n (\mathbf{Y}) P(\mathbf{X} \rightarrow \mathbf{Y})\):

\sphinxAtStartPar
\(\Delta N(\mathbf{X}) = N_n (\mathbf{Y}) P(\mathbf{X} \rightarrow \mathbf{Y}) \left[ \frac{ N_n(\mathbf{X})}{N_n (\mathbf{Y})} - \frac{P(\mathbf{Y} \rightarrow \mathbf{X})}{P(\mathbf{X} \rightarrow \mathbf{Y})}\right]\).

\sphinxAtStartPar
The above shows that there is equilibrium, corresponding to no net population change, when:

\sphinxAtStartPar
\(\frac{ N_n(\mathbf{X})}{N_n (\mathbf{Y})} = \frac{ N_e(\mathbf{X})}{N_e (\mathbf{Y})} \equiv \frac{P(\mathbf{Y} \rightarrow \mathbf{X})}{P(\mathbf{X} \rightarrow \mathbf{Y})}\),

\sphinxAtStartPar
and that changes in \(N(\mathbf{X})\) when the system is not in equilibrium tend to drive it toward equilibrium, i.e. \(\Delta N(\mathbf{X}) > 0\) if there are “too many walkers” at \(\mathbf{X}\), or if \(N_n(\mathbf{X})/N_n(\mathbf{Y})\) is greater than its equilibrium value.

\sphinxAtStartPar
Hence it is possible, and it can be shown, that after a large number of steps, the population of the walkers will settle down to its equilibrium distribution \(N_e\).

\sphinxAtStartPar
What remains to be shown is that the transition probabilities of the algorithm lead to an equilibrium distribution of walkers \(N_e(\mathbf{X}) \sim w(\mathbf{X})\).

\sphinxAtStartPar
The probability of making a step from \(\mathbf{X}\) to \(\mathbf{Y}\) is:

\sphinxAtStartPar
\(P(\mathbf{X} \rightarrow \mathbf{Y}) = T(\mathbf{X} \rightarrow \mathbf{Y}) A (\mathbf{X} \rightarrow \mathbf{Y})\),

\sphinxAtStartPar
where \(T\) is the probability of making a trial step from \(\mathbf{X}\) to \(\mathbf{Y}\), and \(A\) is the probability of accepting that step.

\sphinxAtStartPar
If \(\mathbf{Y}\) can be reached from \(\mathbf{X}\) in a single step (i.e. if it is within a cube of side \(\delta\), centered about \(\mathbf{X}\)), then:

\sphinxAtStartPar
\(T(\mathbf{X} \rightarrow \mathbf{Y}) = T(\mathbf{Y} \rightarrow \mathbf{X})\).

\sphinxAtStartPar
so that the equilibrium distribution of the random walkers satisfies:

\sphinxAtStartPar
\(\frac{ N_e(\mathbf{X})}{N_e (\mathbf{Y})} = \frac{A(\mathbf{Y} \rightarrow \mathbf{X})}{A(\mathbf{X} \rightarrow \mathbf{Y})}\).

\sphinxAtStartPar
Now, there are two scenarios for the ratio between \(w\)’s at \(\mathbf{X}\) and \(\mathbf{Y}\):

\sphinxAtStartPar
if \(w(\mathbf{X}) > w(\mathbf{Y})\), then \(A(\mathbf{Y} \rightarrow \mathbf{X}) = 1\), and:

\sphinxAtStartPar
\(A(\mathbf{X} \rightarrow \mathbf{Y}) = \frac{ w(\mathbf{Y}) } {w(\mathbf{X})}\),

\sphinxAtStartPar
while if \(w(\mathbf{X}) < w(\mathbf{Y})\), then \(A(\mathbf{X} \rightarrow \mathbf{Y}) = 1\)

\sphinxAtStartPar
\(A(\mathbf{Y} \rightarrow \mathbf{X}) = \frac{ w(\mathbf{X}) } {w(\mathbf{Y})}\).

\sphinxAtStartPar
Hence, in either case, the equilibrium population of the walkers satisfies:

\sphinxAtStartPar
\(\frac{ N_e(\mathbf{X})}{N_e (\mathbf{Y})} = \frac{ w(\mathbf{X})}{w(\mathbf{Y})}\),

\sphinxAtStartPar
so that the walkers are indeed distributed with the correct distribution.


\section{Applying the Metropolis et al. Algorithm}
\label{\detokenize{Chapters/Chapter11/Chapter11:applying-the-metropolis-et-al-algorithm}}
\sphinxAtStartPar
An obvious question is, how do we choose the step size, \(\delta\)?

\sphinxAtStartPar
To answer this, suppose that \(\mathbf{X}_n\) is at a maximum of \(w\), the most likely place for it to be. If \(\delta\) is large, then \(w(\mathbf{X}_t)\) will likely be very much smaller than \(w(\mathbf{X}_n)\), and most trial steps will be rejected, leading to an inefficient sampling of \(w\). If \(\delta\) is very small, most trial steps will be accepted, but the random walker will never move very far, and so also lead to a poor sampling of the distribution.

\sphinxAtStartPar
A good rule of thumb is that the size of the trial step should be chosen so that about half of the trial steps are accepted.

\sphinxAtStartPar
One bane of applying the algorithm to sample a distribution is that the points that make up the random walk \(\mathbf{X}_0, \mathbf{X}_1, ...\) are \sphinxstyleemphasis{not independent} of one another, simply from the way in which they are generated. That is, \(\mathbf{X}_{n+1}\) is likely to be in the neighborhood of \(\mathbf{X}_n\). Thus, while the points might be distributed properly as the walk becomes very long, they are not statistically independent of one another.

\sphinxAtStartPar
This dictates that some care should be taken in using them to, e.g., calculate integrals.

\sphinxAtStartPar
For example, suppose we wish to calculate:

\sphinxAtStartPar
\(I = \int \mathrm{d} \mathbf{X} w(\mathbf{X}) f(\mathbf{X})\),

\sphinxAtStartPar
where \(w(\mathbf{X})\) is the normalized weight function.

\sphinxAtStartPar
e.g. in one dimension:

\sphinxAtStartPar
\(I = \int \mathrm{d} x w(x) f(x)\), and change variables to \(y\), with \(\mathrm{d}y/\mathrm{d}x = w(x)\) to get \(I = \int \mathrm{d} y f(x(y))\).

\sphinxAtStartPar
We would do this by averaging the values of \(f\) over the points of the random walk. However, the usual estimate of the variance is invalid, because the \(f(\mathbf{X}_i)\) are \sphinxstyleemphasis{not} statistically independent.

\sphinxAtStartPar
The level of statistical dependence can be quantified by calculating the auto\sphinxhyphen{}correlation function:

\sphinxAtStartPar
\(C(k) = \frac{ \left< f_i f_{i+k} \right> - \left< f_i \right>^2 } { \left< f_i^2 \right> - \left< f_i \right>^2 }\),

\sphinxAtStartPar
where \(\left<...\right>\) indicates average over the random walk, e.g.:

\sphinxAtStartPar
\(\left< f_i f_{i+k} \right> = \frac{1}{N-k} \sum_{i=1}^{N-k} f(\mathbf{X}_i) f(\mathbf{X}_{i+k})\).

\sphinxAtStartPar
The non\sphinxhyphen{}vanishing of \(C\) for \(k\neq 0\) means that the \(f\)’s are \sphinxstyleemphasis{not} independent.

\sphinxAtStartPar
What can be done in practice is to compute the integral and its variance using points along the random walk separated by a fixed interval, the interval being chosen so that there is effectively no correlation between the points used. An appropriate sampling interval can be estimated from the value of \(k\) for which becomes small, e.g., say \(C\lesssim  0.1\).

\sphinxAtStartPar
Another issue in applying the algorithm is where to start the random walk, i.e. what to take as \(\mathbf{X}_0\). In principle any location is suitable and the results will be independent of this choice, as the walker will “thermalize” after some number of steps. In practice, an appropriate starting point is a probable one, where \(w\) is large. Some number of thermalization steps then can be taken before actual sampling begins to remove any dependence on the starting point.


\section{Example 11.1: The Metropolis Algorithm for One\sphinxhyphen{}dimensional Integration}
\label{\detokenize{Chapters/Chapter11/Chapter11:example-11-1-the-metropolis-algorithm-for-one-dimensional-integration}}
\sphinxAtStartPar
(a) Use the algorithm of Metropolis et al. to sample the normal distribution in one dimension:

\sphinxAtStartPar
\(w(x) = e^{-x^2/2}/\sqrt{2\pi}\).

\sphinxAtStartPar
For various step sizes, study the acceptance ratio (i.e. the fraction of trial steps accepted), the correlation function (and hence the appropriate sampling frequency), and the overall computational efficiency.

\sphinxAtStartPar
(b) Use the random variables you generate to calculate the integral:

\sphinxAtStartPar
\(I = \frac{1}{\sqrt{2\pi}}\int_{-\infty}^{+\infty} \mathrm{d}x x^2 e^{-x^2/2}\),

\sphinxAtStartPar
and estimate the uncertainty in your answer.


\section{Quantum Monte Carlo}
\label{\detokenize{Chapters/Chapter11/Chapter11:quantum-monte-carlo}}
\sphinxAtStartPar
The algorithm of Metropolis et al. can be combined with a variational method to yield estimates of atomic and molecular ground state energies via quantum mechanics. We will examine one approach that will allow us to calculate an upper bound for the ground state energies of the Helium atom and the Hydrogen molecule (\(H_2\)).


\subsection{The Model}
\label{\detokenize{Chapters/Chapter11/Chapter11:the-model}}
\sphinxAtStartPar
The system we will consider consists of two protons and two electrons. The protons are considered to be fixed (this is known as the Born\sphinxhyphen{}Oppenheimer approximation), and separated by a distance \(S\). For \(S \neq 0\), this represents a model of the \(H_2\) molecule, whereas for \(S=0\), we have a model of the Helium atom. The figure below shows the coordinates defined in the problem, with the position vectors \(\mathbf{r}_1\) and \(\mathbf{r}_2\) of electrons 1 and 2 are not shown for the sake of clarity.

\sphinxAtStartPar
\sphinxincludegraphics{{gsofh}.png}

\sphinxAtStartPar
The Schrödinger equation for the model can be separated into “nuclear” and “electronic” parts in the Born\sphinxhyphen{}Oppenheimer approximation.

\sphinxAtStartPar
The electronic part is given by:

\sphinxAtStartPar
\(\hat{H} \psi_e (r_1, r_2, S) = \left[ -\frac{\hbar^2}{2 m_e} (\nabla_1^2 + \nabla_2^2) + V(r_1, r_2) \right] \psi_e(r_1,r_2,S) = E_0 (S) \psi_e (r_1, r_2, S)\),

\sphinxAtStartPar
and the nuclear part:

\sphinxAtStartPar
\(\left[ \frac{\hbar^2}{2 m_p} \nabla_S^2 + \frac{e^2}{4\pi \epsilon_0 S} + E_0(S)\right] \psi_n (S) = \epsilon \psi_n(S)\),

\sphinxAtStartPar
where \(E_0(S)\) represents the electronic eigenvalue, \(\epsilon\) is the total energy of the system, \(m_{e,p}\) are the electron and proton masses respectively, and \(\psi_{e,n}\) are the electron and proton eigenfunctions, respectively, and \(V(r_1, r_2)\) is the electrostatic potential for the electrons.

\sphinxAtStartPar
Adopting “dimensionless atomic units”, i.e. setting \(a_0 = \frac{\hbar^2} {m_e e^2} \rightarrow 1\), where \(a_0\) is the Bohr radius, lengths are effectively given in Bohr radii. The resulting unit of energy is sometimes referred to as a “Hartree”, where 1 Hartree corresponds to \(\sim 27.192\) eV.

\sphinxAtStartPar
In these units, the electrostatic potential for the electrons, \(V(r_1, r_2)\), is given by:

\sphinxAtStartPar
\(V(r_1, r_2) = -\left[ \frac{1}{r_{1L}} + \frac{1}{r_{1R}} + \frac{1}{r_{2L}} + \frac{1}{r_{2R}} - \frac{1}{r_{12}}\right]\).

\sphinxAtStartPar
The potential governing the protons’ motion at a separation \(S (\neq 0)\), \(U(S)\) is the sum of the inter\sphinxhyphen{}proton electrostatic repulsion and the eigenvalue \(E_0(S)\) of the two\sphinxhyphen{}electron Schrödinger equation:

\sphinxAtStartPar
\(U(S) = \frac{1}{S} + E_0 (S)\).

\sphinxAtStartPar
Our goal here isa to obtain \(E_0(S)\), the electronic eigenvalue.


\subsection{Variational Monte Carlo}
\label{\detokenize{Chapters/Chapter11/Chapter11:variational-monte-carlo}}
\sphinxAtStartPar
Consider a Hamiltonian, \(\hat{H}\), for which we seek to estimate the ground state. The analytic variational method consists of constructing a “trial” wave function \(\psi_a\), which is parameterized by one or more variational parameters, \(a\). The expectation value of the energy is then calculated from:

\sphinxAtStartPar
\(\left< E(a) \right> = \frac{ \left< \psi_a | \hat{H} | \psi_a\right> } { \left< \psi_a| \psi_a\right> }\),

\sphinxAtStartPar
where the denominator is not necessary if the trial wave function is properly normalized.

\sphinxAtStartPar
The expectation value of the energy is then minimized with respect to the variational parameters, \(a\). The minimum value of \(\left< E(a) \right>\) yields an upper bound to the ground state energy of the system.

\sphinxAtStartPar
The Variational Monte Carlo (VMC) method seeks to minimize the energy numerically. In realistic systems, a many\sphinxhyphen{}body wave function assumes large values in small parts of the configuration space, and hence using homogeneously distributed random points to sample it is not sufficient. The algorithm of Metropolis et al. can be used to sample the required distribution, using an ensemble of random walkers moving through configuration space.

\sphinxAtStartPar
The trial wave function, denoted by \(\psi_T(\mathbf{x})\), is used to define the \sphinxstyleemphasis{local energy}:

\sphinxAtStartPar
\(E_L(\mathbf{x}) = \frac{ \hat{H} \psi_T } {\psi_T}\),

\sphinxAtStartPar
where \(\mathbf{x}\) is a multi\sphinxhyphen{}coordinate which represents the coordinates of all the particles in the system.

\sphinxAtStartPar
Using the above definition of the local energy, the expectation value of the energy can be written as:

\sphinxAtStartPar
\(\left< E\right> = \frac{ \int \mathrm{d} \mathbf{x} \psi^2_T(\mathbf{x}) E_L(\mathbf{x}) } { \int \mathrm{d} \mathbf{x} \psi^2_T(\mathbf{x})  }\).

\sphinxAtStartPar
The algorithm then consists of producing an initial random configuration of walkers that move around configuration space. The walker is moved within a distance \(d\) of about its initial position \(\mathbf{x}\), to a new position \(\mathbf{x}'\). The trial step is accepted or rejected, according to the usual Metropolis algorithm, with the ratio given by:

\sphinxAtStartPar
\(\rho = \frac{  \psi^2_T(\mathbf{x}') } { \psi^2_T(\mathbf{x})}\).

\sphinxAtStartPar
The expectation value of the energy is calculated by averaging the \sphinxstyleemphasis{local energy} over the random walk, taking into account the correct sampling interval, and excluding the thermalization steps at the start.

\sphinxAtStartPar
The size of the trial step can be chosen so that the acceptance ratio is equal to about \(0.5\) for each value of the variational parameter.

\sphinxAtStartPar
As a preparation to the full treatment of the \(He\) atom and \(H_2\) molecule, we investigate the Hydrogen atom in the following example. Note that a problem arises when attempting to calculate the auto\sphinxhyphen{}correlation function, because the trial wave function suggested by the problem is \sphinxstyleemphasis{too} close to the actual wave function. By examining the auto\sphinxhyphen{}correlation function, one notices that as \(a \rightarrow 1\) (i.e. as the trial function approaches the actual wave function), then \(C(k)\) becomes indeterminate, since the variance becomes zero at \(a=1\).


\subsection{Example 11.2 Variational Monte Carlo for the Hydrogen Atom}
\label{\detokenize{Chapters/Chapter11/Chapter11:example-11-2-variational-monte-carlo-for-the-hydrogen-atom}}
\sphinxAtStartPar
Use the Variational Monte Carlo Method to calculate the ground state of the Hydrogen atom.

\sphinxAtStartPar
The Hamiltonian (energy) operator is:

\sphinxAtStartPar
\(\hat{H} = -\frac{1}{2} \nabla^2 - \frac{1}{r}\).

\sphinxAtStartPar
Use a trial wave function of the form:

\sphinxAtStartPar
\(\psi_a(r) = e^{-ar}\).

\sphinxAtStartPar
Note that for \(a=1\), the trial wave function becomes proportional to the exact ground state wave function.

\sphinxAtStartPar
The local energy for the H atom is:

\sphinxAtStartPar
\(E_L(r) = -\frac{1}{r} - \frac{1}{2} a \left( a - \frac{2}{r} \right)\).

\sphinxAtStartPar
Start with a set of \(N_w = 60\) walkers distributed at random in a cube of side \(d=20\).

\sphinxAtStartPar
Each walker should attempt trial steps by adding a random vector \(\Delta \mathbf{r}\) to the initial position \(\vec{r}\).

\sphinxAtStartPar
The trial step should be accepted or rejected according to the ratio:

\sphinxAtStartPar
\(\rho = \psi^2_a(\mathbf{r} + \Delta \mathbf{r}) / \psi^2_a (\mathbf{r})\).

\sphinxAtStartPar
The trial step can be varied from 0.5 to 1, adjusted to keep the acceptance ratio to \(\sim 0.5\) as we vary the parameter \(a\).

\sphinxAtStartPar
You may use a sampling interval of a length of \(\sim 25\). The minimum is expected to occur at \(a=1\), with an energy \(E=0.5=13.6\) eV, with zero variance!


\subsection{VMC for the H\_2 Molecule and He Atom}
\label{\detokenize{Chapters/Chapter11/Chapter11:vmc-for-the-h-2-molecule-and-he-atom}}
\sphinxAtStartPar
The trial wave function suitable for the \(H_2\) problem is a special case of the Padé\sphinxhyphen{}Jastrow wave functions. It consists of a correlated product of molecular orbitals:

\sphinxAtStartPar
\(\Phi(\mathbf{r}_1, \mathbf{r}_2) = \phi(\mathbf{r}_1) \phi(\mathbf{r}_2) f(\mathbf{r}_{12})\),

\sphinxAtStartPar
where:

\sphinxAtStartPar
\(\phi(\mathbf{r}_i) = e^{-r_{iL}/c} + e^{-r_{iR}/c}\),

\sphinxAtStartPar
and

\sphinxAtStartPar
\(f(\mathbf{r}_{12}) = \exp \left[ \frac{r_{12}}{b(1 + a r_{12})} \right]\),

\sphinxAtStartPar
where \(a, b, c\) are variational parameters, and the coordinates are defined in the figure describing the model.

\sphinxAtStartPar
Certain conditions are imposed on these parameters, called “cusp” conditions, which cancel the divergences in the Coulomb potential as \(\mathbf{r}_{1L,R}, \mathbf{r}_{2L, R}, \mathbf{r}_{12} \rightarrow 0\).

\sphinxAtStartPar
To derive the cusp conditions, what needs to be considered for each vector separately is, e.g.:

\sphinxAtStartPar
\(\lim_{r_{1L} \rightarrow 0} \left[ - \frac{1}{2\phi(\mathbf{r}_1)} \nabla_1^2 \phi(\mathbf{r}_1) - \frac{1}{r_{1L}} \right] =\) finite terms.

\sphinxAtStartPar
After performing the differentiation for the Laplacian, the variational parameters \(b, c\) are chosen so as to cancel the negative divergence of the Coulomb potential. This procedure yields:

\sphinxAtStartPar
\(b=2\) and \(c = \frac{1}{1+ e^{-S/c}}\), where \(S\) is the inter\sphinxhyphen{}proton distance.

\sphinxAtStartPar
The second equation is transcendental and can be solved, e.g. via the Newton\sphinxhyphen{}Raphson method, each time the inter\sphinxhyphen{}proton separation is varied.

\sphinxAtStartPar
The remaining parameter, \(a\) can be varied in order to obtain the minimum variational energy.

\sphinxAtStartPar
What remains is to calculate the local energy for the system:

\sphinxAtStartPar
\(E_L(\mathbf{r}_1, \mathbf{r}_2) = \frac{\hat{H}\Phi(\mathbf{r}_1, \mathbf{r}_2)}{\Phi(\mathbf{r}_1, \mathbf{r}_2)  } = \frac{1}{\Phi(\mathbf{r}_1, \mathbf{r}_2)} \left[ -\frac{\hbar^2}{2 m_e} (\nabla_1^2 + \nabla_2^2) + V(r_1, r_2) \right] \Phi(\mathbf{r}_1, \mathbf{r}_2)\).

\sphinxAtStartPar
The following identity can be employed:

\sphinxAtStartPar
\(\nabla_1^2 \left[ f(\mathbf{r}_{12}) \phi(\mathbf{r}_1) \right] =  \phi(\mathbf{r}_1) \nabla^2_1 f(\mathbf{r}_{12}) + 2 \left[ \nabla_1 f(\mathbf{r}_12)\right] \cdot \left[ \nabla_1 \phi(\mathbf{r}_1)\right] + f(\mathbf{r}_{12}) \nabla^2_1 \phi(\mathbf{r}_1)\).

\sphinxAtStartPar
The distances to the “left” (L) and “right” (R) proton, and the inter\sphinxhyphen{}electron distance can be written as:

\sphinxAtStartPar
\(r_{iL} = \sqrt{ x_i^2 + y_i^2 + (z_1 + \frac{1}{2} S)^2}\),

\sphinxAtStartPar
\(r_{iR} = \sqrt{ x_i^2 + y_i^2 + (z_1 - \frac{1}{2} S)^2}\),

\sphinxAtStartPar
for \(i = 1,2\), and

\sphinxAtStartPar
\(r_{12} = \sqrt{ (x_1 - x_2)^2 + (y_1 - y_2)^2 + (z_1 - z_2)^2}\).

\sphinxAtStartPar
One finds that:

\sphinxAtStartPar
\(\nabla_i^2 \phi(\mathbf{r}_i) = -\frac{2}{c} \left[ \frac{e^{-r_{iL}/c}}{r_{iL}} + \frac{e^{-r_{iR}/c}}{r_{iR}} \right] + \frac{ \phi(\mathbf{r_i})}{c^2}\),

\sphinxAtStartPar
\(\nabla_i^2 f(\mathbf{r}_{12}) = f(\mathbf{r}_{12}) \left[ \frac{1}{b^2 ( 1 + a r_{12} )^4} + \frac{2}{b(1+a r_{12})^3 r_{12}} \right]\),

\sphinxAtStartPar
and

\sphinxAtStartPar
\(2 \left[ \nabla_1 f(\mathbf{r}_12)\right] \cdot \left[ \nabla_1 \phi(\mathbf{r}_1)\right] = \frac{2 (-1)^i f(\mathbf{r}_{12})}{bc(1 + ar_{12})^2 } \left[ \hat{\mathbf{r}}_{iL} \cdot \hat{\mathbf{r}}_{12} e^{-r_{iL}/c} +  \hat{\mathbf{r}}_{iR} \cdot \hat{\mathbf{r}}_{12} e^{-r_{iR/c}}\right]\),

\sphinxAtStartPar
for \(i=1,2\), representing each electron.

\sphinxAtStartPar
Putting everything together, we obtain:

\sphinxAtStartPar
\(E_L(\mathbf{r}_1, \mathbf{r}_2) = V(\mathbf{r}_1, \mathbf{r}_2) + E_1 + E_2\), with:

\sphinxAtStartPar
\(E_i = -\frac{1}{2} \left[ \frac{1}{(1+ ar_{12})^3} + \frac{1}{c^2} + \frac{1}{4} \frac{1}{(1 + a r_{12})^4} - \frac{2}{c} \frac{ e^{r_{iL}/c}/r_{iL} + e^{r_{iR}/c}/r_{iR} } {e^{r_{iL}/c}+ e^{r_{iR}/c}} + \frac{(-1)^i}{c} \frac{1}{(1+a r_{12})^2} \frac{ e^{r_{iL}/c} \hat{\mathbf{r}}_{iL} \cdot \hat{\mathbf{r}}_{12} + e^{-r_{iR/c}}\hat{\mathbf{r}}_{iR} \cdot \hat{\mathbf{r}}_{12} }{e^{r_{iL}/c}+ e^{r_{iR}/c}} \right]\).

\sphinxAtStartPar
The Metropolis algorithm is applied in this case using a distribution of \sphinxstyleemphasis{six\sphinxhyphen{}dimensional} walkers, each representing the two electrons in the system. The minimum variational energy for the \(H_2\) molecule can be determined by varying the parameter \(a\) at each inter\sphinxhyphen{}proton separation \(S\). Note that the potential energy curve for the protons in this case needs to take into account the protons’ electrostatic repulsion.

\sphinxAtStartPar
To determine the upper bound for the ground state of the Helium atom, the inter\sphinxhyphen{}proton distance should be set to zero and the variational parameter should be varied.


\subsection{Example 11.3 Variational Monte Carlo for the Helium Atom}
\label{\detokenize{Chapters/Chapter11/Chapter11:example-11-3-variational-monte-carlo-for-the-helium-atom}}
\sphinxAtStartPar
Use the Variational Monte Carlo Method to calculate the ground state of the Helium atom (two protons in the nucleus).

\sphinxAtStartPar
Compare to the known value for the ground state energy of He: \(\simeq 79.005\) eV (\sphinxurl{https://www.nist.gov/pml/atomic-spectra-database})

\sphinxAtStartPar
You may use the local energy provided below:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{EnergyLocal}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{n}{S}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Calculates the local energy for a 6\PYGZhy{}dimensional position vector r and interproton distance S and variational parameter a\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} get the components:}
    \PYG{n}{r1x} \PYG{o}{=} \PYG{n}{r}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{r1y} \PYG{o}{=} \PYG{n}{r}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{r1z} \PYG{o}{=} \PYG{n}{r}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
    \PYG{n}{r2x} \PYG{o}{=} \PYG{n}{r}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
    \PYG{n}{r2y} \PYG{o}{=} \PYG{n}{r}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}
    \PYG{n}{r2z} \PYG{o}{=} \PYG{n}{r}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}
    
    \PYG{c+c1}{\PYGZsh{} the vector connecting the electrons}
    \PYG{n}{r12x} \PYG{o}{=} \PYG{n}{r1x} \PYG{o}{\PYGZhy{}} \PYG{n}{r2x}
    \PYG{n}{r12y} \PYG{o}{=} \PYG{n}{r1y} \PYG{o}{\PYGZhy{}} \PYG{n}{r2y}
    \PYG{n}{r12z} \PYG{o}{=} \PYG{n}{r1z} \PYG{o}{\PYGZhy{}} \PYG{n}{r2z}

    \PYG{c+c1}{\PYGZsh{} the unit vector connecting the electrons:}
    \PYG{n}{r12} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{r12x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r12y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r12z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{r12x} \PYG{o}{=} \PYG{n}{r12x} \PYG{o}{/} \PYG{n}{r12}
    \PYG{n}{r12y} \PYG{o}{=} \PYG{n}{r12y} \PYG{o}{/} \PYG{n}{r12}
    \PYG{n}{r12z} \PYG{o}{=} \PYG{n}{r12z} \PYG{o}{/} \PYG{n}{r12}

    \PYG{c+c1}{\PYGZsh{} get the unit vectors for proton L and R for electron 1}
    \PYG{n}{r1L} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{r1x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r1y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r1z} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{r1R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{r1x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r1y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r1z} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{r1Lx} \PYG{o}{=} \PYG{n}{r1x} \PYG{o}{/} \PYG{n}{r1L}
    \PYG{n}{r1Ly} \PYG{o}{=} \PYG{n}{r1y} \PYG{o}{/} \PYG{n}{r1L}
    \PYG{n}{r1Lz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{r1z} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{r1L}
    \PYG{n}{r1Rx} \PYG{o}{=} \PYG{n}{r1x} \PYG{o}{/} \PYG{n}{r1R}
    \PYG{n}{r1Ry} \PYG{o}{=} \PYG{n}{r1y} \PYG{o}{/} \PYG{n}{r1R}
    \PYG{n}{r1Rz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{r1z} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{r1R}

    \PYG{c+c1}{\PYGZsh{} get the unit vectors for proton L and R for electron 2}
    \PYG{n}{r2L} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{r2x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r2y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r2z} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{r2R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{r2x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r2y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r2z} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{r2Lx} \PYG{o}{=} \PYG{n}{r2x} \PYG{o}{/} \PYG{n}{r2L}
    \PYG{n}{r2Ly} \PYG{o}{=} \PYG{n}{r2y} \PYG{o}{/} \PYG{n}{r2L}
    \PYG{n}{r2Lz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{r2z} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{r2L}
    \PYG{n}{r2Rx} \PYG{o}{=} \PYG{n}{r2x} \PYG{o}{/} \PYG{n}{r2R}\PYG{p}{;}
    \PYG{n}{r2Ry} \PYG{o}{=} \PYG{n}{r2y} \PYG{o}{/} \PYG{n}{r2R}\PYG{p}{;}
    \PYG{n}{r2Rz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{r2z} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{S}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{r2R}\PYG{p}{;}
    \PYG{c+c1}{\PYGZsh{} get the dot product between the unit vectors from protons L and R to electron 1 and the unit vector connecting}
    \PYG{c+c1}{\PYGZsh{} electrons 1 and 2:}
    \PYG{n}{r1Lr12} \PYG{o}{=} \PYG{n}{r1Lx} \PYG{o}{*} \PYG{n}{r12x} \PYG{o}{+} \PYG{n}{r1Ly} \PYG{o}{*} \PYG{n}{r12y} \PYG{o}{+} \PYG{n}{r1Lz} \PYG{o}{*} \PYG{n}{r12z}\PYG{p}{;}
    \PYG{n}{r1Rr12} \PYG{o}{=} \PYG{n}{r1Rx} \PYG{o}{*} \PYG{n}{r12x} \PYG{o}{+} \PYG{n}{r1Ry} \PYG{o}{*} \PYG{n}{r12y} \PYG{o}{+} \PYG{n}{r1Rz} \PYG{o}{*} \PYG{n}{r12z}\PYG{p}{;}
    \PYG{c+c1}{\PYGZsh{} get the dot product between the unit vectors from protons L and R to electron 2 and the unit vector connecting}
    \PYG{c+c1}{\PYGZsh{} electrons 1 and 2:}
    \PYG{n}{r2Lr12} \PYG{o}{=} \PYG{n}{r2Lx} \PYG{o}{*} \PYG{n}{r12x} \PYG{o}{+} \PYG{n}{r2Ly} \PYG{o}{*} \PYG{n}{r12y} \PYG{o}{+} \PYG{n}{r2Lz} \PYG{o}{*} \PYG{n}{r12z}\PYG{p}{;}
    \PYG{n}{r2Rr12} \PYG{o}{=} \PYG{n}{r2Rx} \PYG{o}{*} \PYG{n}{r12x} \PYG{o}{+} \PYG{n}{r2Ry} \PYG{o}{*} \PYG{n}{r12y} \PYG{o}{+} \PYG{n}{r2Rz} \PYG{o}{*} \PYG{n}{r12z}\PYG{p}{;}

	\PYG{c+c1}{\PYGZsh{}get c by solving the transcendetal equation}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{NPsolve}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    
	\PYG{c+c1}{\PYGZsh{}a is the variational param}
    \PYG{n}{E1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(} \PYG{p}{(}\PYG{p}{(} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{a} \PYG{o}{*} \PYG{n}{r12} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r12} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{c}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.25} \PYG{o}{*} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{a} \PYG{o}{*} \PYG{n}{r12} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{\PYGZhy{}} 
		\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r1L} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r1R}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{p}{)}
		\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+} \PYG{n}{a} \PYG{o}{*} \PYG{n}{r12}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{n}{r1Lr12} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{n}{r1Rr12}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r1R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}

    
    \PYG{n}{E2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(} \PYG{p}{(}\PYG{p}{(} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{a} \PYG{o}{*} \PYG{n}{r12} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r12} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{c}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.25} \PYG{o}{*} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{a} \PYG{o}{*} \PYG{n}{r12} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{\PYGZhy{}} 
		\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r2L} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)}\PYG{o}{/}\PYG{n}{r2R}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{p}{)}
     		\PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+} \PYG{n}{a} \PYG{o}{*} \PYG{n}{r12}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{n}{r2Lr12} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{*} \PYG{n}{r2Rr12}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2L} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{r2R} \PYG{o}{/} \PYG{n}{c}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}

    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{r1L} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{r1R} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{r2L} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{r2R} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{r12}\PYG{p}{;}

    \PYG{c+c1}{\PYGZsh{} sum up and return}
    \PYG{c+c1}{\PYGZsh{}localE = V + E12 + E1 + E2}
    \PYG{n}{localE} \PYG{o}{=} \PYG{n}{V} \PYG{o}{+} \PYG{n}{E1} \PYG{o}{+} \PYG{n}{E2}
    \PYG{k}{return} \PYG{n}{localE}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Example 11.4: Variational Monte Carlo for the Hydrogen Molecule}
\label{\detokenize{Chapters/Chapter11/Chapter11:example-11-4-variational-monte-carlo-for-the-hydrogen-molecule}}
\sphinxAtStartPar
Use the Variational Monte Carlo Method to calculate the ground state of the Hydrogen molecule (\(H_2\)).







\renewcommand{\indexname}{Index}
\printindex
\end{document}